Apache/SELinux plus documentation
=================================

OVERVIEW
--------
The Apache/SELinux plus is a set of modules which gives us a set of features
to work web applications with individual security context for each requests.
At the past days,

List of modules:
 * mod_selinux.so
 * mod_authn_sepgsql.so
 * mod_selinux.pp

The mod_selinux.so enables to launch contents-handler (it contains references
to static contents and invocations of web applications) with one-time worker
thread and assign individual security context based on the result of httpd-
authentication.
The apache/httpd daemon process handles the requests come from the clients,
and it also means all the requests are processed with a uniformed set of
privileges, without few exceptions such as SuExec/CGI.
From the viewpoint of operating system, its access control feature cannot
discriminate all the web-application instances, so cannot apply any valid
access controls. It impose on every web-applications a burden of correct
access controls, but it is not basically good design, because fewer points
to be checked is better to reduce security bugs.

The mod_authn_sepgsql.so performs as an authentication provider using
SE-PostgreSQL backend. It allows to store authentication information
in the databases without exposing password in plain text.
In addition, it enables to point out mod_selinux.so what domain/range
pair to be assigned on the contents-handler for the given authenticated
user.

The mod_selinux.pp is a security policy module of SELinux.
It gives us a few pre-defined web application domains (user_webapp_t and
anon_webapp_t), and enables to launch apache/httpd with multi categories.
The mod_selinux.so drops unnecessary categories at the startup time,
then we can assign rest of categories to contents-handler.

REQUIREMENTS
------------

It needs the following packages:

 - kernel (2.6.28 or later)
 - httpd and httpd-devel (2.2.0 or later)
 - libselinux and libselinux-devel
 - selinux-policy
 - checkpolicy (2.0.19 or later)
 - policycoreutils

BUILD and INSTALLATION
----------------------

* RPM Installation (preferable)

 # rpm -Uvh mod_selinux-2.2.xxxx-x.xxx.<arch>.rpm

 It installs the modules and configurations on the standard path,
 and it also installs its security policy module.

* Build from the tarball

 % tar zxvf mod_selinux-2.2.xxxx.tgz
 % cd mod_selinux-2.2.xxxx
 % make
 % make -f /usr/share/selinux/devel/Makefile
 % su
 # make install
 # semodule -i mod_selinux.pp


CONFIGURATION (mod_selinux.so)
------------------------------

The mod_selinux.so has the following four configurations:

 * selinuxServerDomain  <domain/range pair>
  It specifies the security context of daemon process which accepts
  the connection come from clients. The mod_selinux.pp security policy
  module adds a range_transition rule to perform with mcs_systemhigh
  categories at first. However, in most cases, all the categories are
  not required for httpd daemon process.
  This directive allows us to drop unnecessary categories prior to
  connection accepting. If you only uses category from c0 to c15,
  we recommend you to set up the directive as follows.

   Example)
    selinuxServerDomain    *:s0-s0:c0.c15

 * selinuxDomainMap     <filename>
  It specifies the user/domain mapping file which defines the
  relationship between username (authenticated by httpd) and
  a domain/range pair.

   Example)
    selinuxDomainMap    /var/www/mod_selinux.map

 * selinuxDomainEnv <environment variable>
  It specifies an environment variable which tells a domain/range
  pair to be assigned. We can set up an environment variable using
  SetEnfIf directive conditionally, and some of authentication module
  have a plan to set up it to show expected domain/range pair.

   Example)
    SetEnvIf Remote_Addr "192.168.1.[0-9]+$" SELINUX_DOMAIN=*:s0:c1
    SetEnvIf Remote_Addr "192.168.2.[0-9]+$" SELINUX_DOMAIN=*:s0:c2
    selinuxDomainEnv    SELINUX_DOMAIN

 * selinuxDomainVal    <domain/range pair>
  It specifies a domain/range pair to be assigned to content handlers.
  In normal cases, this directive is placed on the tail of the series
  of configuration to perform as a fallback when the request does not
  match selinuxDomainMap/selinuxDomainEnv rules.

   Example)
    SetEnvIf Remote_Addr "192.168.1.[0-9]+$" SELINUX_DOMAIN=*:s0:c1
    SetEnvIf Remote_Addr "192.168.2.[0-9]+$" SELINUX_DOMAIN=*:s0:c2
    selinuxDomainMap    /var/www/mod_selinux.map   ... (1)
    selinuxDomainEnv    SELINUX_DOMAIN             ... (2)
    selinuxDomainVal    anon_webapp_t:s0           ... (3)

  In this example, the (1) is checked at first. If the given request is
  already authenticated and matched to the mapfile, the mod_selinux.so
  launches the contents handler with an appropriate domain/range pair.
  Then, (2) is checked. The SELINUX_DOMAIN is set based on Remote_Addr,
  so it may have a valid value, if the request come from certain networks.
  Otherwise, the (3) will be checked and any other request is executed
  with the domain/range pair of "anon_webapp_t:so".

 * selinuxAllowCaches (On|Off)
  As the apache/httpd official documentation noted, it checks
  contents caches prior to authentications and domain transition,
  so it may allow users to bypass access controls.
  The mod_selinux.so disables contents caches as far as the
  configuration is not explicitly set.
  Please understand the risk to use contents caches, before you
  enables it.

   Example)
    selinuxAllowCaches        On

CONFIGURATION (mapping files)
-----------------------------

The selinuxDomainMap can specify a certain mapping file which allows
to describe relationships between a http-authenticated username and
a pair of domain/range.
Each lines of the mapfile mean a relationship as follows:

  kaigai	staff_webapp_t:s0

The lefthand is a username, and the righthand is a domain/range pair.
We have two special usernames. The "*" matches all the usernames and
anonymous (unauthenticated) requests, and "__anonymous__" matches
all the anonymous requests but does not for authenticated users.

When both or either of domain/range part is "*", it means mod_selinux
does not change the current ones. For example, when "*:s0:c0" is given
for a user; himainu, his request will be run with "s0:c0" in MCS, but
it inherits server processes domain.

The '#' and the following characters are handled as comments.

 Example)
  #
  # user <--> domain/range mapping
  #
  kaigai		*:s0:c0
  himainu		*::s0:c1
  panda			staff_webapp_t:s0:c2
  __anonymous__		anon_webapp_t:s0


TIPS (virtual-host based separation)
------------------------------------

If you want to separate the security context per virtual host,
but not necessary for users, we can utilize selinuxDomainVal
to set up the domain/range pair for each virtual host.
In the following example, all the request for dog.example.com
will be handled with "s0:c1" category, but ones for others are
handled with "s0:c2" category.

 Example)
  NameVirtualHost *:80
  
  <VirtualHost *:80>
  DocumentRoot          /var/www/html
  ServerName            dog.example.com
  selinuxDomainVal       *:s0:c1
  </VirtualHost>

  <VirtualHost *:80>
  DocumentRoot          /var/www/html
  ServerName            cat.example.com
  selinuxDomainVal      *:s0:c2
  </VirtualHost>

CONFIGURATION (mod_authn_sepgsql.so)
------------------------------------

The mod_authn_sepgsql.so provides an authentication mechanism collaborating
with SE-PostgreSQL. When apache/httpd receives a request, it calls registered
authentication modules sequencially, and also invokes mod_authn_sepgsql.
It makes a query to the database to check whether the given pair of user and
password is correct, or to return a hash token generated from password text.
It expects the configured query can return a record for a valid web-user which
contains a field to shows the required result.
One useful feature is exporting the extra information of returned record to
other modules via environment variable. For example, mod_selinux.so can
assign individual security context based on the extra user information.

 == Database connection parameters ==
 The following parameters allow to set up connection to database.
 We can set up hostname, port number, database name, user and password
 with specific directive. If you want to specify more detailed connection
 parameter (such as LDAP or SSL option), the AuthSepgsqlConnInfo directive
 allows to specify a raw connection string.
 Please note that when AuthSepgsqlConnInfo has an explicit value, rest of
 database connection parameters are ignored.

 * AuthSepgsqlHost         <host>  (default: local unix domain socket)
   The hostname server working on.

 * AuthSepgsqlPort         <port>  (default: 5432)
   The port number server accepting connection.

 * AuthSepgsqlDatabase     <database> (default: username of httpd daemon)
   The database name to be logged in.

 * AuthSepgsqlUser         <username> (default: username of httpd daemon)
   The database username to be logged in.

 * AuthSepgsqlPassword     <password> (default: empty)
   The database password to be used for database authentication.

 * AuthSepgsqlConnInfo     <connection string>
   The raw connection information string.

 == Query for authentication ==
 The following parameters allow to specify query string used for basic or
 digest authentication, and field name optionally which stores the result
 of authentication or generation of hash string.
 The given query can have some of special variables which are replaced by
 run-time informations, such as username, password and so on.

  - $(user)        ... replaced by the given username to be authorized
  - $(password)    ... replaced by the given password.
                       (*) It is not valid for digest authentication.
  - $(realm)       ... replaced by the given realm to be used to generate
                       a hash string in digest authentication.
                       (*) It is not valid for basic authentication.
  - $(remote_addr) ... replaced by the ip address of remote host.
  - $(method)      ... replaced by the request method.
  - $(uri)         ... replaced by the request URI.

 example)
   AuthSepgsqlCheckQuery  check_result    \
       "SELECT upassword = $(password) AS check_result FROM uaccount WHERE uname = $(user)"

 The AuthSepgsqlCheckQuery is a query used for basic authentication, and
 the AuthSepgsqlHashQuery is a query used for digest authentication.
 They need to return a tuple for valid-user. If no records were returned,
 it is considered as user-not-found, not an authentication denied.

 * AuthSepgsqlCheckQuery   [<field name>] <query string>
 It specifies a query string for basic authentication. The field name needs
 to be BOOL type which shows whether the given $(user) and $(password) were
 matched, or not. When it is true ('t'), the required authentication gets
 granted, otherwise denied.
 If the field name is omitted, the first field is used for the result.

 * AuthSepgsqlHashQuery    [<field name>] <query string>
 It specified a query string for digest authentication. The field name needs
 to be TEXT or compatible type which returns a computed hash token used for
 digest authentication. It has to be computed as:
   MD5($(user):$(realm):<password>)
 The digest authentication does not deliver the plain password, the query
 needs to create the hash token from the given $(user) and $(realm), and
 password stored within database.
 The returned hash token matches with expected one, the required
 authentication gets graned, otherwise denied.
 If the field name is omitted, the first field is used for the result.

 == Collaboration parameters ==
 * AuthSepgsqlSetEnv       <field name> [<environ variable>]

 A record can contain extra information related to authenticated users,
 such as real-name, e-mail address, security context to be performed on.
 This directive enables to export a certain field to other modules via
 environment variable.

 example)
   AuthSepgsqlSetEnv	umail	USER_EMAIL_ADDRESS

 This example enables to export 'umail' field of the result record via
 the environment variable of USER_EMAIL_ADDRESS, if the valid record
 found in the authentication. Then, contents-handlers (web applications)
 are invoked, and they can refer the extra information.
 If the second argument is omitted, AUTH_SEPGSQL_<field name> is used
 for the name of environ variable.

 Please note that mod_selinux.so supports selinuxDomainEnv directive
 which allows to assign a domain/range pair set in a certain environ
 variable. The combination of these configuration enables to store
 whole of web-user account info (username, password, domain/range, ...)
 within the database.

CONTACT
-------

Author: KaiGai Kohei <kaigai@ak.jp.nec.com>


COPYRIGHT and LICENSE
---------------------
Copyright (c) 2009 NEC Corporation

This is free software, available under the terms of the Apache Software
License 2.0. See the file LICENSE for details.
