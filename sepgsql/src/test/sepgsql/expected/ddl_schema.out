--@SECURITY_CONTEXT=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c15
SET sepostgresql_mcstrans TO off;
SELECT sepgsql_getcon();
                   sepgsql_getcon                    
-----------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c15
(1 row)

-- Note that the current standard security policy does not contains
-- the definitions of db_schema object class (It is waiting for the
-- SE-PgSQL patch getting merged). SELinux allows all the requests
-- on the undefined object class, so we don't check any valid permission
-- checks here. It only checks default security context (inherited from
-- the db_database class) and statement support.
-- cleanup previous tests
SET client_min_messages TO 'error';
DROP SCHEMA IF EXISTS scm1 CASCADE;
DROP SCHEMA IF EXISTS scm2 CASCADE;
DROP SCHEMA IF EXISTS scm3 CASCADE;
DROP SCHEMA IF EXISTS scm4 CASCADE;
DROP SCHEMA IF EXISTS scm5 CASCADE;
RESET client_min_messages;
-- CREATE SCHEMA with SECURITY_CONTEXT option
CREATE SCHEMA scm1;
CREATE SCHEMA scm2
       CREATE TABLE t2 (a int);
CREATE SCHEMA scm3
       SECURITY_CONTEXT = 'system_u:object_r:sepgsql_db_t:s0:c0';
CREATE SCHEMA scm4
       SECURITY_CONTEXT = 'system_u:object_r:sepgsql_db_t:s0:c1'
       CREATE TABLE t4 (x int);
CREATE SCHEMA scm4
       SECURITY_CONTEXT = 'invalid security context';			-- to be failed
ERROR:  invalid security context "invalid security context"
SELECT nspname, sepgsql_schema_getcon(oid), nspsecon FROM pg_namespace
       WHERE nspname in ('scm1', 'scm2', 'scm3', 'scm4', 'scm5');
 nspname |         sepgsql_schema_getcon         |               nspsecon                
---------+---------------------------------------+---------------------------------------
 scm1    | unconfined_u:object_r:sepgsql_db_t:s0 | unconfined_u:object_r:sepgsql_db_t:s0
 scm2    | unconfined_u:object_r:sepgsql_db_t:s0 | unconfined_u:object_r:sepgsql_db_t:s0
 scm3    | system_u:object_r:sepgsql_db_t:s0:c0  | system_u:object_r:sepgsql_db_t:s0:c0
 scm4    | system_u:object_r:sepgsql_db_t:s0:c1  | system_u:object_r:sepgsql_db_t:s0:c1
(4 rows)

-- ALTER SCHEMA with SECURITY_CONTEXT option
ALTER SCHEMA scm1
      SECURITY_CONTEXT TO 'system_u:object_r:sepgsql_db_t:s0:c2';
ALTER SCHEMA scm2
      SECURITY_CONTEXT TO 'invalid security context';			-- to be failed
ERROR:  invalid security context "invalid security context"
ALTER SCHEMA scm4
      SECURITY_CONTEXT TO 'system_u:object_r:sepgsql_db_t:s0:c3';	-- no such schema
SELECT nspname, sepgsql_schema_getcon(oid), nspsecon FROM pg_namespace
       WHERE nspname in ('scm1', 'scm2', 'scm3', 'scm4', 'scm5');
 nspname |         sepgsql_schema_getcon         |               nspsecon                
---------+---------------------------------------+---------------------------------------
 scm2    | unconfined_u:object_r:sepgsql_db_t:s0 | unconfined_u:object_r:sepgsql_db_t:s0
 scm3    | system_u:object_r:sepgsql_db_t:s0:c0  | system_u:object_r:sepgsql_db_t:s0:c0
 scm1    | system_u:object_r:sepgsql_db_t:s0:c2  | system_u:object_r:sepgsql_db_t:s0:c2
 scm4    | system_u:object_r:sepgsql_db_t:s0:c3  | system_u:object_r:sepgsql_db_t:s0:c3
(4 rows)

-- disallow to modify system catalog by hand
UPDATE pg_namespace SET nspsecon = NULL
       WHERE nspname = 'scm1';						-- to be denied
ERROR:  SE-PgSQL prevents to modify "pg_namespace" by hand
-- cleanups
SET client_min_messages TO 'error';
DROP SCHEMA IF EXISTS scm1 CASCADE;
DROP SCHEMA IF EXISTS scm2 CASCADE;
DROP SCHEMA IF EXISTS scm3 CASCADE;
DROP SCHEMA IF EXISTS scm4 CASCADE;
DROP SCHEMA IF EXISTS scm5 CASCADE;
RESET client_min_messages;
