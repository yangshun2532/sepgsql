
SE-PostgreSQL developer documentation
=====================================

TABLE OF CONTENTS
=================

1. Overview
1-1. Brief overview of SE-PostgreSQL
1-2. Mandatory access control
1-3. Security context
1-4. Misc features
2. Internal architecture
2-1. communication with SELinux
2-2. management of security context
2-3. privilege of the client
2-4. security hooks
2-5. initialization
3. Object classes and permissions
3-1. common permissions of database object
3-2. db_database object class
3-3. db_schema object class
3-4. db_table object class
3-5. db_column object class
4. Code examples
4-1. Example of SE-PgSQL hooks
4-2. Example of third party module

1. Overview
============================================================

1-1. Brief overview of SE-PostgreSQL
------------------------------------
SE-PostgreSQL (hereafter SE-PgSQL) is a feature of PostgreSQL which applies
MAC policy on the given SQL queries. Its most significant feature is any access
control decisions are provided by SELinux, and SE-PgSQL correctly performs
according to the decisions.

SELinux is a subsystem in the Linux kernel. It also provides its access control
decision for various kind of kernel subsystems. For example, when we tries to
write on a certain file, VFS mechanism ask SELinux whether the given system
call can be executable, or not. SELinux returns its access control decision
based on the security policy, then the caller (VFS) controls accesses according
to the decision.

We can consider SELinux as something like a function which returns a binary
state ("allowed" or "denied") for the given arguments. It requires a set of
required permissions and a pair of the security contexts of subject and object.
For example, when we write something on a certain file using shell commands,
VFS layer hooks write(2) calls to invoke SELinux, and it also gives a pair of
security contexts of the shell process and the file to be written, and codes
corresponding to "file:{write}" permission.

In the system with SELinux, we can confirm security context of the current
process with "id -Z" command.

  [kaigai@saba ~]$ id -Z
  unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

We can confirm security context of the files with "ls -Z" command.

  [kaigai@saba ~]$ ls -Z /etc/passwd /etc/shadow
  -rw-r--r--. root root system_u:object_r:etc_t:s0       /etc/passwd
  -r--------. root root system_u:object_r:shadow_t:s0    /etc/shadow

SELinux lookups an entry matched with the given pair of security context from
the security policy which is a massive set of rules, and every rule has allowed
set of actions. If it contains all the required actions, "allowed" should be
returned, otherwise "denied".

We can apply this design on accesses to database objects, not only kernel, as
long as RDBMS correctly manages the security context of them.
SE-PgSQL assigns an individual security context on the managed database objects,
and asks SELinux whether the given accesses should be allowed, or not.


1-2. Mandatory access control
-----------------------------

SELinux provides MAC based policy, so here are several differences from
the default PG model (known as a kind of DAC). The characteristics of MAC
are a centralized security policy and unbypassable access controls.

The default PG model allows owners to grant/revoke discretionary access rights
on the owned objects. On the other hand, only a centralized security policy
controls all the accesses in MAC model. So, it does not allow users to set up
discretionary access rights without allowance by the policy, even if they are
owner of the database objects.

In addition, its access control is unbypassable, even if the client has
database superuser privileges. It checks all the needed permissions on
the database objects without any exception.
If we implicitly allows to bypass any permission checks on certain users, it
makes impossible to analyze data-flows from the viewpoint of security policy.

So, the point is no omission for MAC checks, even if it already checks 

For example, the default PG model does not apply access controls for database
superusers. It simply skips routines to check database acls. It is correct
manner in DAC, but undesirable manner in MAC.
If DAC checks are enclosed by something like "if (superuser())" block, SE-PgSQL
checks have to be invoked outside of the block.


1-3. Security context
---------------------

SELinux identifies any entities (such as processes, files, tables, ...) using
its security context. The security context is a short formatted text as:

  system_u:object_r:sepgsql_table_t:s0

It is the only identifier in SELinux model, instead of user-id or permission
bits. When the default PG model makes its access control decision, it checks
whats are allowed/disallowed on a certain pair of user-id and ACLs of the object
to be accessed. Note that user-id is a property of the client, and the ACLs is
also a property of the object to be accessed.
In similar way, SELinux makes its access control decision. It checks what is
allowed/disallowed on a certain pair of the security contexts of client and
object to be accessed.

A security context is separated into four fields, as follows:

  <selinux user>:<role>:<domain/type>:<range>

SELinux has a few kind of access control strategies (aka, RBAC, TE, MLS),
every fields are corresponding to a certain strategy. But it is encapsulated
within kernel code, all SE-PgSQL has to do is to follow the decision of SELinux.

When user create a new database object, a default security context shall be
assigned on the new object. It is provided by the security policy in kernel,
and SE-PgSQL assigns the offered one in the default.
The default security context is decided for a pair of security contexts of
the client and its parent object. See the later chapter for more details.


1-4. Misc features
------------------

o Enforcing/Permissive mode

These are a working mode in SELinux. In enforcing mode, it actually applies
its access controls, and raises an error if violated. On the other hand, it
also checks the security policy but does not prevent anything in permissive
mode, except for access violation logs.
The purpose of permissive mode is to debug the security policy itself.

A GUC option: sepostgresql controls this behavior.

  sepostgresql = [default | enforcing | permissive | disabled ]

    default    : It follows system setting.
    enforcing  : Always enforcing, if SELinux is enabled on the system
    permissive : Always permissive, if SELinux is enabled on the system
    disabled   : Always disabled (default setting)


o Security audit

The security policy also has rules to control generation of security audit.
It suggests SE-PgSQL to generate security audit logs on access violations
or access allowed. It is called 'auditdeny' and 'auditallow' rules.
In the default, it generates audit logs on access violations, but do nothing
when accesses are allowed.

Below is an example when SE-PgSQL prevent violated accesses on a column.

  LOG:  SELinux: denied { select }  \
      scontext=staff_u:staff_r:staff_t:Unclassified  \
      tcontext=system_u:object_r:sepgsql_secret_table_t:Unclassified  \
      tclass=db_column name=customer.ccredit


o MCS translation

The forth field of security context means its range in MLS (Multi Level
Security) rules. It is represented with a combination of symbols, so it is not
well human-readable. MCS translation enables to associate them with a human
readable alias.

For example, if "s0:c0" means an unclassified document in finance division
labeled as "Unclassified-Finance", the raw range is replaced by the human
readable form as follows:

    Raw-format  : system_u:object_r:sepgsql_table_t:s0:c0
  Human readable: system_u:object_r:sepgsql_table_t:Unclassified-Finance
                                                    ^^^^^^^^^^^^^^^^^^^^
SELinux provides an API to translate them. All the security contexts are stored
in raw-format, and it is translated on printing time.

A GUC option: sepostgresql_mcstrans = [on | off] controls this behavior.
If it is turned off, it print out security context in raw-format.


2. Internal architecture
============================================================

2-1. communication with SELinux
-------------------------------

SELinux provides a set of APIs to communicate between kernel and applications,
encapsulated in libselinux. It allows applications to ask SELinux whether the
given user's request should be executed, or not.
The following two APIs are especially important ones for SE-PgSQL.

o security_compute_av()

It returns a set of allowed permissions on a pair of security contexts and
a certain object class, so the caller can know what permissions are allowed.

This example shows a case when we ask SELinux what is the allowed set of
permissions on a pair of a client with "system_u:system_r:httpd_t:s0" and
a table with "system_u:object_r:sepgsql_table_t:s0" for the "db_table" object
class.
This API set up the av_decision structure correctly, then we can check returned
bitmask which contains allowed permissions later. If a bit corresponding to
the db_table:{select} permission is set, it should be allowed.

  Example)
    struct av_decision avd;
    char   *scontext = "system_u:system_r:httpd_t:s0";
    char   *tcontext = "system_u:object_r:sepgsql_table_t:s0";
    int16   tclass;
    uint32  permission;
              :
    tclass = string_to_security_class("db_table");
    if (security_compute_av(scontext, tcontext, 0, tclass, &avd) < 0)
        elog(ERROR, "SELinux internal error");
              :
    permission = string_to_av_perm(tclass, "select");
    if (avd.allowed & permission)
        elog(NOTICE, "%s is allowed to select %s", scontext, tcontext);
    else
        elog(NOTICE, "%s is disallowed to select %s", scontext, tcontext)


o security_compute_create()

It returns a default security context of a newly created object on a pair
of security contexts and a certain object class, so the caller can know what
security context should be assigned on the new one.

This example shows a case when we ask SELinux what security context should be
assigned on the new table created by a client with "system_u:system_r:httpd_t:s0"
in the schema with "system_u:object_r:sepgsql_schema_t:s0".
This API set up a default security context correctly, then we can assign it on
the new object later.

  Example)
    char   *scontext = "system_u:system_r:httpd_t:s0";
    char   *tcontext = "system_u:object_r:sepgsql_schema_t:s0";
    char   *ncontext;
    int16   tclass;
              :
    tclass = string_to_security_class("db_table");
    if (security_compute_create(scontext, tcontext, tclass, &ncontext) < 0)
        elog(ERROR, "SELinux internal error");
              :
    elog(NOTICE, "New security context is %s", ncontext);
              :
    freecon(ncontext);      /* must be free */


2-2. management of security context
-----------------------------------

A limited number of database object classes have its own security context in
this version, so we decided to store them as a text field of the following
system catalogs:

 - pg_database.datsecon   = security context of the database
 - pg_namespace.nspsecon  = security context of the schema
 - pg_class.relsecon      = security context of the table
                         (if relkind = RELKIND_RELATION, otherwise no label)
 - pg_attribute.attsecon  = security context of the column
                         (if it owned by the regular table, otherwise no label)

We have a plan to provide a facility to manage security context of various
kind of database objects, including individual tuples within user defined
tables. But it is postponed to keep the change-set more simple and small.

These fields means security context of the (managed) database objects.
In this version, only four object classes (database, schema, table and column)
are managed, so SE-PgSQL makes its access control decisions on them only.

When we create a new object, a default security context shall be assigned on
the fields, then it is used for its security identifier for SE-PgSQL.
If SE-PgSQL is disabled, NULL shall be set on.

From the viewpoint of implementation, SE-PgSQL provides a few hooks to check
permission to create a new object. It also returns the security context to be
assigned on the new object.

For example, it is a hook to check db_schema:{create} permission.

  extern Value *
  sepgsql_schema_create(const char *nspName, bool isTemp, Node *nspLabel);

The caller has to give required informations as arguments. This hook checks
permission, and returns the security context to be assigned.
We also modified the caller side a bit. It copies the returned security context
on the pg_namespace.nspsecon as a TEXT value before simple_heap_insert().
If hook returned NULL, the caller also set NULL on the pg_namespace.nspsecon.
(Note that the hook always returns NULL when SE-PgSQL is disabled.)


2-3. privilege of the client
----------------------------

SELinux also provides an interesting API: getpeercon(3). It enables to obtain
the security context of the peer process for the given file-descriptor of the
network socket.

If the given connection is unix domain socket, we don't need any special
configurations. If remote connection, it is necessary to set up labeled ipsec
connection between server and clients to deliver the security context of the
peer process when key exchange negotiations.
(we can set up static-fallback'ed security context based on the ip address of
clients for a case when SELinux is not unavailable on the client side.)

This example shows a case when we obtain a security context of the peer.

  Example)

    char   *scontext;
              :
    if (getpeercon(MyProcPort->sock, &scontext) < 0)
        elog(ERROR, "SELinux internal error");
              :
    elog(NOTICE, "security context of the client: %s", scontext);
              :
    freecon(scontext);


2-4. security hooks
-------------------

SE-PgSQL needs to deploy its security hooks on the strategic points.
These hooks are designed not to affect anything for code paths, if SE-PgSQL
is disabled on either compile-time or run-time.

Its specifications and purposes are described as source code comments, so we
can find detailed information at src/backend/security/sepgsql/*.c files.
The caller has to provide needed information for the hooks.

For example, sepgsql_check_rte_perms() which checks access permissions for
the given RangeTblEntry (which contains OID of the target relation and
Bitmapset of selected/modified columns). The caller has to give enough
information SE-PgSQL to make its access control decision correctly.

The sepgsql_check_rte_perms() makes its access control decision based on
the given information (RangeTblEntry object to be checked) and MAC policy
in the kernel. If allowed, it simply returns to the called. Otherwise, it
raises an error to abort current transaction.
The specification and behavior of individual security hooks are described
in the source code comments.


2-5. Initialization
-------------------

The initdb command set up a initial database on an empty directory.
At first, it launches PgSQL in bootstraping mode (--boot) to insert initial
contents of system catalogs from the postgres.bki, then it launches PgSQL in
single-user mode (--single) to apply rest of initialization.

In the bootstraping mode, SE-PgSQL is automatically disabled, because it does
not have enough data integrity to apply its security policy correctly.
For example, it computes a default security context of the table based on the
pair of client and schema which owns the new table, but pg_namespace catalog
is declared after the pg_catalog catalog.

So, SE-PgSQL initializes security contexts of the managed database objects
in the "template1" database on the second phase in initdb.
If initdb is launched with "--enable-selinux" option, it invokes a special
purpose function to assign initial security contexts on them. This function 
is available only when single-user mode for the security reason.


3. Object classes and permissions
============================================================

Object class is a terminology that means a certain type of object, such as
files, processes, tables in database and so on. Every object classes have
its own set of permissions which reflect characteristics of the object class,
but some of permissions are commonly defined for various kind of database
object classes to handle common object behavior; creation, deletion, setting
and getting its attributes, and relabeling its own security context.

Unless an explicit explanation, these permission is checked on a pair of the
client and the object to be accessed. In other word, security_compute_av()
will take the following arguments:

 subject context = security context of the client
 target context  = security context of the object to be accessed

For example, when a client with "user_u:user_r:user_t:s0" tries to drop
a table with "system_u:object_r:sepgsql_ro_table_t:s0", SE-PgSQL calls
security_compute_av() with both of security context and the code for
db_table object class. Then, it checks whether the allowed set of permissions
contains a bit for db_table:{drop} permission, or not.


3-1. common permissions of database object
------------------------------------------

The following six permissions are commonly defined for database object classes.

o create

It is checked when a client creates a new database object on the new object
labeled with a default or an explicit security context.

Prior to access control decision, a new object has to be labeled correctly.
There are two ways to label the new object. If user gives an explicit security
context on its creation, it shall be assigned with validation checks.
Othrwise, SE-PgSQL compute a default security context and it shall be assigned.
In either cases, a security context shall be assigned on the new object, then
SE-PgSQL checks db_xxx:{create} permission on the new object with the security
context.

For example, when a client labeled as "staff_u:staff_r:staff_t:s0" create a new
table, SE-PgSQL computes its default security context with communication to
SELinux. If "staff_u:object_r:sepgsql_table_t:s0" is returned, SE-PgSQL assigns
it on the new table, then checks db_table:{create} permission on a pair of
security contexts.

Some statements have OR REPLACE option. In the case when a client replaces
an existing database object, "setattr" should be applied instead of "create",
even if CREATE statement is used, because it can be considered as modification
of the object's properties, not creation.


o drop

It is checked when a client drop an existing database object.
This check is also applied on cascaded deletions, not only original one,
triggered by user's operation.

Note that "drop" always doesn't mean deletion from system catalog.
For example, ALTER TABLE ... DROP COLUMN just marks an pg_attribute entry as
already dropped, using simple_heap_update(). In fact, it is modification of
property of the column, but we consider it as a deletion.

Note that no needs to check for objects deletion by system internal
stuff, such as cleanups of temporary objects.


o getattr (not implemented yet)

It is checked when a client read properties of database object.

Typically, it is required on scanning database objects within system catalogs,
such as "SELECT * FROM pg_class". Because this check requires row-level access
control facilities, it is not implemented yet in this version.

Note that no need to check this permission, unless fetched properties are
consumed internally without returning to clients. For example, catcache stuff
provides system internal stuff an easy way to refer system catalog. It is used
to implement backend routines, and fetched properties are not returned to the
client in normal way, so we don't check this permission here.


o setattr

It is checked when a client modifies properties of database object.

Typically, ALTER statement is used to modify properties of database object.

Note that an entry of a certain system catalog is all the properties of the
database objects. For example, an entry of pg_class indeed represents the
properties of a certain relation. But it is not all. An entry corresponding
to a certain relation in pg_description catalog is also a property of the
table, so we also need to check db_table:{setattr} permission to create,
replace or remove the comment.
It depends on characteristics of individual database objects. In basically,
SE-PgSQL follows the way to handle this in the default PG model.


o relabelfrom

It is checked when a client relabel security context of a certain database
object on the older security context, in addition to {setattr} permission.
Security context is a part of the properties, so we need to check {setattr}
here. 


o relabelto

It is checked when a client relabel security context of a certain database
object on the newer security context.
Briefly, SE-PgSQL requires three permissions (setattr, relabelfrom and
relabelto) to relabel security context of a certain database object.


3-2. db_database object class
-----------------------------

The db_database class represents the database itself. An individual tuple
in the pg_database system catalog corresponds them.
It has three its own permissions and inherits the common sixes.

o default security context

The default security context for db_database class shall be computed based on
a pair of the client and its template database.

For example, when a client ("staff_u:staff_r:staff_t:s0") creates a new
database with "template0" labeled as "system_u:object_r:sepgsql_db_t:s0",
SE-PgSQL gives the two contexts for security_compute_create(3) which
returns a default security context from SELinux in the kernel.

Note that we label the first database ("template1") with an explicit
security context, not a default security context. SE-PgSQL is disabled
in the bootstraping mode, so all the database objects are created without
any security context. Then, initdb kicks queries to assign initial security
context on all the managed database objects, if --enable-selinux is given.
In this time, we gives an explicit security context provided by configuration
of SELinux.


o access

It is checked when the client open a connection to the database.
If violated, the connection shall be closed soon. So, all the clients must
be allowed to access any database objects owned by the database at least.


o load_module (not implemented yet)

It is checked when a dynamic link library is loaded to the server process
due to client's requests.

Note this permission shall be checked on a pair of the current database and
the dynamic link library file. In other word, it checks capability of database
to load a certain shared library.

The security_compute_av() takes security context of the current database
as subject and the dynamic link library file as object in the arguments,
then it returns access control decision.

Also note that we don't check anything on libraries listed on the
"shared_preload_libraries" option, because it is not a request from client.


o superuser

It is checked when the client tries to perform as a superuser on the current
database. If violated, client performs as a non-privileged database user,
even if the default PG model allows them to perform as a database superuser.

Note that this permission only controls whether the client can performs as
a database superuser in the default PG access control, or not. If a given
query needs more permissions, these are independently checked based on the
security policy.


3-2. db_schema object class
---------------------------

The db_schema class represents the schema object. An individual tuple in
the pg_namespace system catalog corresponds them.
It has three its own permissions and inherits the common sixes.

o default security context

The default security context for db_schema class shall be computed based on
a pair of the client and database owning the new schema in creation.

o search

It is checked when the client resolves name of the database objects owned by
a certain schema object.
The client cannot resolve any named database objects anyway, unless this
permission is allowed. Its behavior is similar to ACL_USAGE permission on
the namespace objects in the default PG model. If it is checked on
constructing the schema search path and violated, the unallowed schema shall
be dropped from the path. Otherwise, it raises an error.

o add_name

It is checked when the client adds a new name into a certain schema.

Typically, it is checked on creation of a new object, renaming an object and
moving an object to other schema.

o remove_name

It is checked when the client removes an existing name from a certain schema.

Typically, it is checked on deletion of a new object, renaming an object and
moving an object to other schema.

Note that "ALTER xxx RENAME TO" is considered as a pair of operations.
So, it requires add_name and remove_name permissions on the same schame.
Needless to say, it is an atomic operation, so both of permissions must
be allowed on the pair of client and schema.


3-3. db_table object class
--------------------------

The db_table class represents the table object. An individual tuple in the
pg_class system catalog with relkind = RELKIND_RELATION corresponds them.
It has five its own permissions and inherits the common sixes.

o default security context

The default security context for db_table class shall be computed based on
a pair of the client and database owning the new schema in creation.

o select

It is checked when the client refers tuples in the table contents.

o insert

It is checked when the client add tuples into the table contents.

o update

It is checked when the client modify tuples in the table contents.

o delete

It is checked when the client remove tuples from the table contens.

These four permissions are a key to control data-flows between clients and
table contents. Note that it is one of the most significant feature in MAC
system.
The db_table:{select} permission controls data-flows from the table contents
to the client. Rest of the three permissions also control data-flows from the
client to the table contents.

For example, if a client X can write data to the table T, and a client Y can
read data from the table T, we can observe an communication channel between X
and Y via T.


o lock

It is checked when the client acquires explicit table locks.
Note that it shall be applied on only explicit locks, not implicit one.


o inherit (not implemented yet)

It is checked when we set up an inheritance relationship between two tables
on a pair of the tables.

Note this permission shall be checked on a pair of the parent table and the
child table. In other word, it checks capability of two tables to set up an
inheritance relationship.

Also note that this permission shall be checked when relabeling the tables,
not only CREATE or ALTER TABLE with INHERIT option.


3-4. db_column object class
---------------------------

The db_column class represents the column object. An individual tuple in
the pg_attribute system catalog owned by regular tables (its relkind is
RELKIND_RELATION) corresponds them.
It has three its own permissions and inherits the common sixes.

Here is a hardwired constraint that columns inherited from the parent tables
must have identical security context with its source. When we create a table
inherited from others, the table inherits column's definition including its
security context. In this case, the client must have permission to create
a new column with inherited security context.

o default security context

The default security context for db_column class shall be computed based on
a pair of the client and the table owning the new columns in creation.

o select

It is checked when the client refers a value via the column.
It also includes the case when UPDATE or DELETE statement contains WHERE
clause with references to certain columns.

o update

It is checked when the client modifies a value on the column.

o insert

It is checked when the client inserts a new value on the column.
Note that it is not checked when a value is given due to DEFAULT setting,
not provided by clients.


4. Code examples
============================================================










