日本語版ドキュメント

本文書は、Security-Enhanced PostgreSQL (SE-PostgreSQL) の公式のドキュメントであり、導入や設定、管理、開発等の目的に有益な情報が含まれています。

= １章．はじめに =

Security Enhanced PostgreSQL (SE-PostgreSQL) は、オープンソースのリレーショナルデータベースシステム (RDBMS) である PostgreSQL に、SELinuxのアーキテクチャに基づいた追加的なアクセス制御メカニズムを提供し、エンタープライズシステムの基盤となるデータベースのセキュリティに革新的な向上をもたらします。

SE-PostgreSQLの核となるアイデアは、 *セキュアOS(SELinux)との統合* と *細粒度の強制アクセス制御* であり、これらの特徴はデータベースシステムをOSと一体化した情報フロー制御の枠組みに組み込むことを可能にし、情報資産の漏えいや改ざん、破壊といった脅威から保護します。

*セキュアOSとの統合*

 従来、データベースユーザの権限は、それがOS上でどの様な権限を持っているかとは無関係に決められていました。そのため、一貫したセキュリティポリシーを適用することができず、OS上で *機密* とラベル付けされたファイルに対してアクセス権を持たないプロセスが、特権ユーザとしてデータベースにログインして *機密* データを含む全てのデータにアクセスすることも可能でした。
 SE-PostgreSQLは、データベースクライアントに適用する権限をOS上でのそれと一致させます。即ち、OS上で *機密* データにアクセスが不可能なプロセスは、データベースにログオンしても同様に *機密* データにアクセスできません。
 また、SE-PostgreSQLの全てのアクセス制御は SELinux のセキュリティポリシーに基づいて行われます。このため、システム全体にわたって一貫したセキュリティポリシーを記述・適用することが可能になり、たとえ機密レベルの異なる情報をデータベースに格納したとしても、あたかもOS(SELinux)が実施しているかのようなアクセス制御を適用することができます。
 
 (注釈) SELinuxに関する情報は、「付録・SELinuxについて」を参照してください。


*細粒度の強制アクセス制御*

 データベースシステムにおけるアクセス制御とは、認証を経たクライアントに対して、テーブルや関数等のデータベースオブジェクトに対するアクセスを許可するか否かという意思決定のプロセスです。
 データベース製品の種類によってアクセス制御の対象となるデータベースオブジェクトの種類は異なりますが、SE-PostgreSQLは、ごく限られた商用データベースシステムでしかサポートされていない行レベル/列レベルのアクセス制御を提供します。リレーショナルデータベースにおいて、行および列は最も小さな単位のデータベースオブジェクトであり、データベース管理者は最大限に柔軟な設定を加えることが可能です。
 
 また、SE-PostgreSQLの提供するアクセス制御は、全てのデータベースユーザに対して例外なく実施されます。ネイティブのPostgreSQLでは、特権ユーザという特別なユーザに対してアクセス制御リストの評価を実施せず、全てのアクセスを許可しますが、SE-PostgreSQLを利用することによって特権ユーザに対してもアクセス制御を加えることが可能になります。

== ライセンスと著作権 ==

SE-PostgreSQL は PostgreSQL と同一の BSDライセンスを適用します。原文は以下のリンクを参照してください。
 http://www.postgresql.org/about/licence

言うまでもなく、SE-PostgreSQL は PostgreSQL の派生物です。SE-PostgreSQLは将来的に PostgreSQL への統合を目指しており、その障害となるであろう技術的でない障害を予め排除するために BSDライセンスの適用を決定しました。

将来、仮に PostgreSQL のライセンス体系が変更された場合には、SE-PostgreSQL のライセンス体系もそれに連動して変更される可能性があります。

== このドキュメントの構成 ==

 * ２章「インストールと設定」では、SE-PostgreSQLの入手とインストール・設定までの手順を解説します。対象とするLinuxディストリビューションは Fedora Core 6 です。
 * ３章「SE-PostgreSQLの利用」では、サンプルデータベースを構築して SE-PostgreSQL の機能を利用する方法を紹介します。
 * ４章「セキュリティデザイン」では、SE-PostgreSQLのセキュリティ機能がどの様に機能するかを解説します。
 * ５章「内部情報」では、SE-PostgreSQLの実装の全体像と、キーとなるソフトウェアコンポーネントについて解説します。
 * 付録では、その他の関連情報を掲載しています。

PostgreSQLコミュニティは、非常に詳細で網羅的なドキュメントを提供しています。SE-PostgreSQLに固有でない事項については、下記のオンラインドキュメントが有益な情報を与えてくれるでしょう。
 * 英語版：http://www.postgresql.org/docs/manuals/
 * 日本語版：http://www.postgresql.jp/document/current/html/

= ２章．インストールと設定 =


== RPMからのインストール ==


== ソースコードからのインストール ==


== SELinuxの設定 ==





= ３章．SE-PostgreSQLの利用 =

== サンプルデータベースの構築 ==

== security_context システム行 ==

== アクセス制御の効果を確認する ==

== 列レベルでのアクセス制御を設定する ==

== Trusted Procedure を設定する ==

=== READ不可能な password フィールドを用いた認証 ===

== ビューの展開 ==

== バックアップとリストア ==


= ４章．セキュリティデザイン =

== 概要 ==


== クエリの実行に必要な権限セット ==


== 暗黙的なセキュリティコンテキストの付与 ==


== Trusted Procedure ==

== オブジェクトクラスとアクセスベクタ ==
SE-PostgreSQLのセキュリティデザインを記述するために、以下の表に示す6つのオブジェクトクラスと、合計55種類のアクセスベクタが追加されました。残念ながら2007年２月現在、これらのオブジェクトクラス・アクセスベクタはまだSELinuxコミュニティによってメンテナンスされている標準のセキュリティポリシーには取り込まれていません。

|| *database* || *table* || *procedure* || *column* || *blob* || *tuple* ||
|| create || create || create || create || create || relabelfrom ||
|| drop || drop || drop || drop || drop || relabelto ||
|| getattr || getattr || getattr || getattr || getattr || select ||
|| setattr || setattr || setattr || setattr || setattr || update ||
|| relabelfrom || relabelfrom || relabelfrom || relabelfrom || relabelfrom || insert ||
|| relabelto || relabelto || relabelto || relabelto || relabelto || delete ||
|| access || select || execute || select || read || ||
|| install_module || update || entrypoint || update || write || ||
|| load_module || insert || || insert || import || ||
|| get_param || delete || || || export || ||
|| set_param || lock || || || || ||

=== 共通の振る舞い ===

*create*

*drop*

*getattr*

*setattr*

*relabelfrom*

*relabelto*



=== databaseクラス ===
*database* クラスはデータベース自身と、固有のオブジェクトクラスを持たないデータベースオブジェクトに対する権限セットを定義します。固有のオブジェクトクラスを持たないデータベースオブジェクトとは、例えばデータベースユーザやトリガのことです。

*暗黙的ラベリング*
 CREATE DATABASE 構文を用いて新たにデータベースを作成するとき、クライアントプロセス及びSE-PostgreSQLサーバプロセスのセキュリティコンテキストに基づいて、データベースのセキュリティコンテキストが暗黙のうちに決定されます。
 
 CREATE _<hoge>_ 構文を用いて新たに固有のオブジェクトクラスを持たないデータベースオブジェクトを作成するとき、クライアントプロセス及びデータベースのセキュリティコンテキストに基づいて、データベースオブジェクトのセキュリティコンテキストが暗黙のうちに決定されます。

*access*

*install_module*

*load_module*

*get_param*

*set_param*

=== tableクラス ===
*table* クラスはテーブルに対する権限セットを定義します。

=== procedureクラス ===
*procedure* クラスは関数 (stored procedure) に対する権限セットを定義します。

=== columnクラス ===
*column* クラスはカラムに対する権限セットを定義します。なお、ネイティブのPostgreSQLにはカラムに対するアクセス制御は存在しません。


=== blobクラス ===
*blob* クラスは Binary Large Object (BLOB) に対する権限セットを定義します。なお、ネイティブのPostgreSQLにはBLOBに対するアクセス制御機能は存在しません。


=== tupleクラス ===
*tuple* クラスはタプルに対する権限セットを定義します。なお、ネイティブのPostgreSQLにはタプルに対するアクセス制御は存在しません。



== 特別なケース ==
=== テーブルの継承 ===
=== 外部キーと制約条件 ===
=== TRUNCATE構文 ===


== 標準のセキュリティポリシー ==






= ５章．内部情報 =
== SE-PostgreSQLアーキテクチャ ==
== pg_selinuxシステムカタログ ==
== PSID(Persistent Security IDentifier) ==
== userspace AVC ==



= 付録 =

== 拡張SQL構文・関数 ==

SE-PostgreSQLのセキュリティ機能を活用するために、SE-PostgreSQLでは幾つかのSQL構文が拡張され、SQL関数が新しく追加されています。本章では、これらの拡張機能について解説します。

=== ALTER DATABSE 構文 ===
*書式*

 ALTER DATABASE _dbname_ CONTEXT = _'context'_

*説明*
 PostgreSQL の ALTER DATABASE 構文の拡張によって、データベースのセキュリティコンテキストを変更することが可能になりました。

 この構文を実行すると、_dbname_ で指定されたデータベースのセキュリティコンテキストを _'context'_ に変更します。
 クライアントはデータベースに対して *database:{setattr relabelfrom}* 権限を、そして新しく付与するセキュリティコンテキストに対して *database:{relabelto}* 権限を有していなければいけません。

*例*
{{{
kaigai=# alter DATABASE testdb context = 'user_u:object_r:sepgsql_db_t:s0:c0';
ALTER DATABASE
kaigai=#
}}}

*注釈*
 この構文を実行した結果、データベースのセキュリティコンテキストが変化しない場合、*database:{relabelfrom relabelto}* 権限は評価されません。

=== ALTER TABLE 構文 ===
*書式*

 ALTER TABLE _tblname_ CONTEXT = _'context'_
 
 ALTER TABLE _tblname_ ALTER _colname_ CONTEXT = _'context'_

*説明*
 PostgreSQLの ALTER TABLE 構文の拡張によって、テーブル又はカラムのセキュリティコンテキストを変更することが可能になりました。

 最初の構文を実行すると、_tblname_ で指定されたテーブルのセキュリティコンテキストを、_'context'_ に変更します。
 クライアントはテーブルに対して *table:{setattr relabelfrom}* 権限を、そして新しく付与するセキュリティコンテキストに対して *table:{relabelto}* 権限を有していなければいけません。
 
 後ろの構文を実行すると、_tblname_ . _colname_ で指定されたカラムのセキュリティコンテキストを、 _'context'_ に変更します。クライアントはカラムに対して *column:{setattr relabelfrom}* 権限を、そして新しく付与するセキュリティコンテキストに対して *column:{relabelto}* 権限を有していなければいけません。

*例*
{{{
kaigai=# ALTER TABLE drink CONTEXT = 'user_u:object_r:sepgsql_secret_table_t';
ALTER TABLE
kaigai=#
}}}

*注釈*
 この構文を実行した結果、テーブルのセキュリティコンテキストに変化がない場合、*table:{relabelfrom relabelto}* 権限は評価されません。同様にカラムのセキュリティコンテキストに変化がない場合、*column:{relabelto}* 権限は評価されません。

=== ALTER FUNCTION 構文 ===
*書式*

 ALTER FUNCTION _funcname_ CONTEXT = _'context'_

*説明*
 PostgreSQL の ALTER FUNCTION 構文の拡張によって、関数のセキュリティコンテキストを変更することが可能になりました。

 この構文を実行すると、_funcname_ で指定された関数のセキュリティコンテキストを _'context'_ に変更します。
 クライアントはデータベースに対して *procedure:{setattr relabelfrom}* 権限を、そして新しく付与するセキュリティコンテキストに対して *procedure:{relabelto}* 権限を有していなければいけません。

*例*
{{{
kaigai=# alter function check_person_passwd(integer, text)
      context = 'user_u:object_r:sepgsql_trusted_proc_t';
ALTER FUNCTION
kaigai=#
}}}

*注釈*
 この構文を実行した結果、関数のセキュリティコンテキストが変化しない場合、*procedure:{relabelfrom relabelto}* 権限は評価されません。

=== sepgsel_getcon() 関数 ===
*定義*

 sepgsql_getcon() returns *psid*

*説明*
 この関数はクライアントのセキュリティコンテキストを取得するために新たに追加されました。
 
 sepgsql_getcon() 関数を実行すると、現在のセキュリティコンテキストを返します。Trusted Procedureの内部から呼び出された場合には、ドメイン遷移を行った先のセキュリティコンテキストを行います。

*例*
{{{
kaigai=# select sepgsql_getcon();
                 sepgsql_getcon
-------------------------------------------------
 root:system_r:unconfined_t:SystemLow-SystemHigh
(1 row)
}}}

=== lo_get_security() 関数 ===
*定義*

 lo_get_security( *Oid* _loid_ ) returns *psid*

*説明*
 この関数はラージオブジェクトのセキュリティコンテキストを取得するために新たに追加されました。
 
 lo_get_security()関数を実行すると、 _loid_ で指定したラージオブジェクトのセキュリティコンテキストを返却します。クライアントは、ラージオブジェクトに対して *blob:{getattr}* 権限を有していなければいけません。

*例*
{{{
kaigai=# select lo_get_security(16410);
        lo_get_security
--------------------------------
 user_u:object_r:sepgsql_blob_t
(1 row)
}}}

=== lo_set_security() 関数 ===
*定義*

 lo_set_security( *Oid* _loid_, *psid* _context_ ) returns *bool*

*説明*
 この関数はラージオブジェクトのセキュリティコンテキストを変更するために新たに追加されました。
 
 lo_set_security()関数を実行すると、 _loid_ で指定したラージオブジェクトのセキュリティコンテキストを_context_ に変更します。クライアントは、ラージオブジェクトに対して *blob:{setattr relabelfrom}* 権限を、そして新しく付与するセキュリティコンテキストに対して *blob:{relabelto}* 権限を有していなければいけません。

*例*
{{{
kaigai=# select lo_set_security(16410, 'user_u:object_r:sepgsql_secret_blob_t');
 lo_set_security
-----------------
 t
(1 row)
}}}


== SELinuxについて ==
=== Security Context ===
=== Type Enforcement (TE)===
=== Domain Transition ===
=== Multi Level Security (MLS) ===
=== Role Based Access Control (RBAC) ===
=== Boolean ===
=== Labeled Networking ===

== 今後のロードマップ ==
=== Polyinstantiation データベース ===
=== pl/pgSQLスクリプト言語のサポート ===




