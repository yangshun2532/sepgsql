#summary Introduction of the Apache/SELinux plus

<font size="6" face="Impact,Chicago"><i><u>Apache/SELinux plus</u></i></font>

<wiki:toc max_depth="2" />

= 概要 =

Apache/SELinux plus は apache/httpd 2.2.x 系列に対応した外部モジュールで、Fedora Projectにおいて [https://admin.fedoraproject.org/pkgdb/packages/name/mod_selinux mod_selinux] としてパッケージ化されています。
本モジュールは、WebアプリケーションのインスタンスにHTTP認証に基づいた個別のセキュリティコンテキストを割り当てて起動する事を可能にします。この機能は、Webユーザの概念とSELinuxのセキュリティコンテキストとのマッピングとして理解する事もできるでしょう。つまり、Webユーザ/アプリケーションに対してSELinuxが有効なアクセス制御を実施できるようになったという事です。
本モジュールは LAPP/SELinux スタックを構成する重要な要素であり、細粒度でシステムワイドな強制アクセス制御にSELinuxを適用するためのコミュニティの活動により生まれました。

本モジュールのビルド、インストール、及び実行には以下のパッケージが必要です。

 * Linux kernel >= 2.6.28 (SELinux有効)
 * httpd >= 2.2.0
 * libselinux
 * libsepol >= 2.0.34
 * policycoreutils
 * httpd-devel >= 2.2.0 (ビルド時に必要)
 * checkpolicy >= 2.0.17 (ビルド時に必要)
 * libselinux-devel (ビルド時に必要)

これらのパッケージは Fedora 11 で利用可能ですので、その利用をお勧めします。

== 設計におけるアナロジー ==

SELinuxがWebシステムでどのように機能するかを明確にするため、伝統的なシェル・ログインとApache/SELinux plusの間のアナロジーを紹介します。

本節では、（特に形容詞を伴わない）利用者とは情報システムの管理下にあるリソース（例えばPDF文書です）にアクセスしようとしている人間を意味します。人間は一般的にハードウェアデバイスを直接アクセスするのに不向きです（もし彼が直接ハードウェアに触れる事ができるなら、それはSELinuxの範疇外です）。したがって、利用者は彼の代わりにリソースにアクセスするエージェントを作り出す必要があります。このエージェントとは、OS上ではプロセス、WebシステムではWebアプリケーションインスタンスと呼ばれるものです。

エージェントは利用者の代わりに情報システム内で働く物であるので、正しく利用者に対応した権限セット（例：セキュリティコンテキスト）を持つ必要があります。識別・認証の機構がその正しさを担保し、SELinuxのようなアクセス制御機構は、もしエージェントが不正な動作をしてもそれを禁止する事ができます。

http://sepgsql.googlecode.com/files/LAPP_SELinux_Fig02.png

利用者がsshログイン経由でリソースにアクセスしようとする時、sshサーバはコネクションに対して識別・認証を行ない、子プロセスを生成してログインシェルを適切な権限で実行します。この場合、ログインシェルプロセスが利用者のエージェントとして働きます。利用者はエージェントに対してリソースにアクセスするためのコマンド列を送出し、SELinuxがそれを許可する限り、エージェントはそれを実行します。最終的に、利用者はエージェントから結果又はエラーを受け取ります。

同様に、Webインターフェースを通じてリソースにアクセスする時、Webサーバは識別・認証を行う事ができます（匿名でのアクセスも許可します）。そして、Webサーバは受け取ったHTTP要求を処理するため、利用者のエージェントとしてWebアプリケーションインスタンスを起動します
エージェントは要求されたリソースにアクセスしようとします。しかし、SELinuxは有効なアクセス制御を行う事ができません（それがWebコンテンツとして公開されていないものにアクセスしようとする場合を除く）。なぜなら、WebサーバはWebアプリケーションインスタンスに正しく権限を関連付けていないからです。したがって、Webアプリケーションインスタンスは常にWebサーバのセキュリティコンテキストを継承しますが、SELinuxには全てのエージェントが一様なセキュリティコンテキストを持っているように見えるのです。

Apache/SELinux plus は、HTTP認証に基づいて、エージェントの起動前に適切な権限を設定します。これは、あたかもエージェントがシェル・ログイン経由でアクセスしているかのように、SELinuxがWebユーザ毎の有効なアクセス制御を実施できるようになった事を意味します。

== 内部設計 ==

Apache/SELinux plus の実装はシンプルです。

WebサーバがHTTP要求を受け取ると、HTTP要求ヘッダを解析し、必要であればHTTP認証を適用します。この認証プロセスはWebサーバのコンテキストで実行される事に留意してください。
次に、mod_selinux.soモジュールは一時的な作業スレッドを作成し、作業スレッドが終了するまでスリープします。
作業スレッドは、コンテンツハンドラ（Webアプリケーションのエントリポイントを含む）の起動前に、自身のセキュリティコンテキストを変更します。新しいセキュリティコンテキストが、古いセキュリティコンテキストの被制限ドメインである場合に限り、最近のSELinux（2.6.28カーネル以降）ではスレッド単位にセキュリティコンテキストを設定する事ができます。詳細は[#制限ドメイン 制限ドメイン]を参照してください。

最終的に、コンテンツハンドラは新しいセキュリティコンテキストをセットした作業スレッドで実行されます。

http://sepgsql.googlecode.com/files/LAPP_SELinux_Fig04.png

`mod_selinux.so`がインストールされていない場合、apache/httpdはコンテンツハンドラを同一のコンテキストで同期的に実行します。サーバ側のバックエンドはHTTP要求を繰り返し受信・実行するため、直接セキュリティコンテキストを設定する事は不可能です。ひとたび権限の弱いセキュリティコンテキストを設定した場合、そのバックエンドは二度と他のリクエストを実行できなくなるでしょう。しかし、認証プロセスの前にどのセキュリティコンテキストを設定すべきか特定できないため、（伝統的な`accept(2)`-`fork(2)`モデルのように）一時的な作業スレッドを生成する事が必要です。

動的ドメイン遷移は、`execve(2)`ベースのドメイン遷移よりも弱い分離である事に留意してください。サーバプロセスが既に不可視なファイルをローカルなメモリ空間にロードしていた場合、論理的には、弱い権限をセットされた作業用スレッドから参照可能です。
しかしながら、この枠組みはWebアプリケーションによる自発的な違反アクセスのチェック・防止に役立ちます。

----

= 背景 =

== LAPP/SELinux ==

[http://en.wikipedia.org/wiki/LAPP LAPP]とは、Linux、Apache、PostgreSQLとPHP/Perl/Pythonスクリプトから成る、ありふれたOSSのWebアプリケーションスタックです。LAPP/SELinuxとは、我々のSELinuxを利用したWebアプリケーションのセキュリティ改善のコンセプトです。

[http://www.nsa.gov/research/selinux/index.shtml SELinux]とは、Linuxオペレーティングシステムにおける[http://en.wikipedia.org/wiki/Reference_monitor リファレンスモニタ]の実装で、一元管理されたセキュリティポリシーに基づく細粒度の強制アクセス制御が特徴です。５年以上も前から、本流のLinuxカーネルや主要ディストリビューション（Fedora, RedHatELなど）にも採用されています。
SELinuxは、バグったアプリケーションや悪意あるユーザからの、システムリソースへの予期していないアクセスを効果的に禁止し、Linuxの優位性に貢献しています。

しかし、SELinuxに対する不満として「どうやってWebアプリケーションのセキュリティを改善するんだ？」という声をしばしば耳にします。
事実、情報システムに対する脅威は、その傾向が数年の間に大きく変わりました。
以下のグラフは_[http://www.lac.co.jp/info/jsoc_report/ 侵入傾向分析レポート: vol.12]_からの引用です。これによると、2008年度の重大インシデントのうち93%がWebシステムに対するもので、2006年度の53%という数字から大きく変化しています。

[http://sepgsql.googlecode.com/files/LAPP_SELinux_Fig00.png]

Webシステムに対する攻撃の割合は、明らかにオンライン市場の成長とWebシステムを通じてやり取りが行なわれる情報資産の価値の増大と軌を一にしています。したがって、この領域のセキュリティを改善するソリューションが必要なわけですが、2～3の困難な課題があります。

一つは、DBオブジェクトに対するアクセス制御。SELinuxはオペレーティングシステムのリファレンスモニタとして機能するため、OS管理下のリソースに対するアクセスを全てチェックする事ができます。しかしこれは、SELinuxはOS管理外のリソース（DBオブジェクトなど）に対しては何もできない事をも意味しています。
SE-PostgreSQLはPostgreSQLの拡張で、SELinuxのセキュリティポリシーに基づいた細粒度の強制アクセス制御を可能にします。これはまた、SELinuxのカバレッジがLAPPスタックのDB層に拡大した事を意味します。

もう一つは、Webアプリケーションインスタンスの権限です。Apache/httpdは全てのHTTP要求を受け付け、一様なセキュリティコンテキストの下でこれを処理します。これは、SELinuxにはWebユーザに基づいた有効なアクセス制御を行えない事を意味します。
Apache/SELinux plus は apache/httpd の外部モジュールで、権限の制約されたセキュリティコンテキストを（Webアプリケーションのエントリポイントを含む）コンテンツハンドラの実行前にセットする事を可能にします。これはまた、SELinuxのカバレッジがLAPPスタックのWeb層に拡大した事を意味します。


[http://sepgsql.googlecode.com/files/LAPP_SELinux_Fig01.png]

昔は、SELinuxが制御できたのはOS管理下のリソースに対してのみでした。現在では、WebシステムのLAPPスタックのうち、LAPまでカバーする事ができます（加えて、X-windowのような幾つかの重要なアプリケーションも）。我々としては、LAPPスタック全体をSELinuxで保護するための道筋を考えています。
最後の P は象徴的にはPHP/Perl/PythonのようなLL言語として理解されています。しかし、それらには限定されません。あらゆる種類のアプリケーションサーバ（例えばTomcat）はここにマップされるかもしれない候補で、将来的な我々のアクションアイテムでもあります。

== SE-PostgreSQL ==

現在では膨大な数のWebアプリケーションがデータベースを利用しており、アクセス制御の観点からの非常に重要な機能です。

前述の通り、カーネル内のSELinuxはユーザ空間で管理されているオブジェクトに対するアクセスをチェックする事ができません。これは、DBオブジェクトに対するアクセスが、SELinuxからは盲点となっている事を意味しており、我々にできたのはシステムコールのレベルでデータベースへの接続を制御する事だけでしたが、この種の All-or-Nothing のポリシーは柔軟性に欠けています。

SE-PostgreSQL は PostgreSQL におけるリファレンスモニタとして機能し、カーネル内のSELinuxと連携して動作します。
これはまた、SQLクエリとシステムコールの間のアナロジーとして理解する事ができます。

http://sepgsql.googlecode.com/files/LAPP_SELinux_Fig03.png

（利用者のエージェントとして働く）プロセスがOS管理下のファイルシステムオブジェクトにアクセスする時、アクセスの手段としてシステムコールを利用します。そして、SELinuxは要求されたオブジェクトに対するプロセスの権限をチェックします。
プロセスとオブジェクトの双方がセキュリティコンテキストを持っており、SELinuxはセキュリティポリシーの中からこれら双方のセキュリティコンテキストの組み合わせに対応したルールを探し出します。
もし明示的に許可されていれば、SELinuxは何もしません。それ以外の場合、SELinuxはエラーを返します。

同様に、クライアントプロセスが（文字通りDB管理システムの管理下にある）DBオブジェクトにアクセスする時、アクセス手段としてSQLクエリを送出します。そして、SE-PostgreSQLサブシステムはカーネル内のSELinuxの持っているセキュリティポリシーに基づいて、要求されたDBオブジェクトに対するクライアントの権限をチェックします。（SELinuxはソケットの接続端点のセキュリティコンテキストを取得するAPIを提供している事に留意してください）
SE-PostgreSQLはまたDBオブジェクトのセキュリティコンテキストも管理しています。SE-PostgreSQLはカーネル内のSELinuxに、セキュリティポリシーが所与のセキュリティコンテキストの間に要求された操作を許可しているか否かを問合せます。もしそれを許可すべきなら、SE-PostgreSQLは何もSQLクエリの実行を妨げません。それ以外の場合、SE-PostgreSQLはエラーを返します。

詳細については http://wiki.postgresql.org/wiki/SEPostgreSQL をご覧ください。

== 制限ドメイン（Bounds domain）==

Apache/SELinux plusは、Webアプリケーションインスタンスを起動するために一時的な作業スレッドを利用し、その作業スレッドは自分自身に新しいセキュリティコンテキストを割り当てます。SELinuxにはスレッド毎のセキュリティコンテキストを設定する際に制約があり、スレッドに設定される新しいセキュリティコンテキストは、元々のセキュリティコンテキストによって制限されている必要があります。この関係はセキュリティポリシーの中で定義されています。

マルチスレッドプロセスでは、複数のスレッドがプロセスローカルメモリを共有します。したがって、SELinuxは異なるドメイン間のデータフローの捕捉とチェックが不可能でした（リファレンスモニタとしての性質による）。これが、従来のカーネルはマルチスレッドプロセスに新しいセキュリティコンテキストを割り当てる事を許していなかった理由です。

制限ドメインの機能は、非制限ドメインに許可を与える事のできる権限の範囲を制限します。
あるドメインが別のドメインによって制限されている場合、あらゆる権限は、制限ドメインがそれを持っていない限り、被制限ドメインに対して許可される事は決してありません。

http://sepgsql.googlecode.com/files/LAPP_SELinux_Fig05.png

上記の例では、次の`typebounds`構文ポリシーによって、`anon_webapp_t`ドメインが`httpd_t`ドメインによって制限されています。
{{{
typebounds httpd_t anon_webapp_t;
}}}

ルールは、`anon_webapp_t`に許可されている全ての権限は、`httpd_t`にも許可されていなければならないという事です。
ポリシーの作成において、もし`anon_webapp_t`に`/etc/shadow`へのアクセスを許可しようとしても、`httpd_t`には許可されていないため、実行時にその権限は落とされてしまいます。
この図において、`httpd_enable_cgi`がOnの時、双方のドメインは`/var/www/cgi-bin/test.cgi`へのアクセスを許可されています。`httpd_enable_cgi`は`httpd_t`ドメインの権限にのみ作用しますが、この状態で`httpd_t`ドメインは権限を失っているため、これをOffにする事は同時に`anon_webapp_t`の権限を落とすことにもなります。

制限ドメインとは、元々のドメインが一部の権限を失った特別な状態であると考える事もできます。したがって、新しいドメインが古いドメインによって制限されている限りにおいて、SELinuxはマルチスレッドプロセス内の特定のスレッドのセキュリティコンテキストを変更する事を認めているのです。

Apache/SELinux plusは、認証されたユーザに応じた個々のセキュリティコンテキストを特定のスレッドに割り当てるために、この制限ドメインを利用しています。

----

= インストール =

== RPM インストール ==

Apache/SELinux plus をセットアップするにはRPMインストールがお勧めです。

もし既にFedora11がインストール済みなら、`yum`コマンドを利用して下さい。必要なのは、以下のコマンドをタイプする事だけです。
{{{
# yum install mod_selinux
}}}
これで、パッケージを探し出し、ダウンロードし、インストールまでを自動的に行ってくれます。

もしRPMパッケージを手動でインストールしたいなら、以下のパッケージとバージョンを確認して下さい。
 * Linux kernel >= 2.6.28, with SELinux enabled
 * httpd >= 2.2.0
 * libselinux
 * libsepol >= 2.0.34
 * policycoreutils

RPMパッケージは[http://fedoraproject.org/ Fedora Project]にホストされています。
以下のURLから、あなたの環境に応じた`mod_selinux`パッケージを探してください。

 http://download.fedora.redhat.com/pub/fedora/linux/development/

そして、`rpm`コマンドを実行します。
これにより、`mod_selinux.pp`ポリシーモジュールもインストールされる事に留意して下さい。これはちょっとだけ時間のかかる処理です。
{{{
[root@saba ~]# wget http://...(snip).../mod_selinux-2.2.1930-1.fc11.i586.rpm
--2009-05-26 13:29:06--  http://...(snip).../Packages/mod_selinux-2.2.1930-1.fc11.i586.rpm
Resolving download.fedora.redhat.com... 209.132.176.220
Connecting to download.fedora.redhat.com|209.132.176.220|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 55810 (55K) [application/x-rpm]
Saving to: `mod_selinux-2.2.1930-1.fc11.i586.rpm'

100%[=============================================>] 53,776      --.-K/s   in 0.1s

2009-05-26 13:27:33 (460 KB/s) - `mod_selinux-2.2.1930-1.fc11.i586.rpm' saved [53776/53776]

[root@saba ~]# rpm -Uvh mod_selinux-2.2.1930-1.fc11.i586.rpm
Preparing...                ################################### [100%]
   1:mod_selinux            ################################### [100%]
}}}

== ソースインストール ==

特に明確な理由の無い限り、ソースからのインストールはお勧めしません。

インストールの前に、以下のパッケージとバージョンを確認して下さい。
 * Linux kernel >= 2.6.28, with SELinux enabled
 * httpd >= 2.2.0
 * libselinux
 * libsepol >= 2.0.34
 * policycoreutils
 * httpd-devel >= 2.2.0（ビルド時に必要）
 * checkpolicy >= 2.0.17（ビルド時に必要）
 * libselinux-devel（ビルド時に必要）

=== 1. ソースの取得 ===

[Apache_SELinux_plus#List_of_sources List of Sources]セクションからソースコードをダウンロードする事ができます。
現在のところ、最新版が最もお勧めです。

{{{
[kaigai@saba ~]$ wget http://sepgsql.googlecode.com/files/mod_selinux-2.2.1930.tgz
--2009-05-26 13:42:32--  http://sepgsql.googlecode.com/files/mod_selinux-2.2.1930.tgz
Resolving sepgsql.googlecode.com... 72.14.203.82
Connecting to sepgsql.googlecode.com|72.14.203.82|:80... connected.
HTTP request sent, awaiting response... 200 OK
Length: 14028 (14K) [application/empty]
Saving to: `mod_selinux-2.2.1930.tgz'

100%[=============================================>] 14,028      56.2K/s   in 0.2s

2009-05-26 13:42:34 (56.2 KB/s) - `mod_selinux-2.2.1930.tgz' saved [14028/14028]
}}}

=== 2. モジュールとポリシーのビルド ===

ソースの*.tgzファイルを展開します
{{{
[kaigai@saba ~]$ tar zxvf mod_selinux-2.2.1930.tgz
mod_selinux-2.2.1930/
mod_selinux-2.2.1930/Makefile
mod_selinux-2.2.1930/mod_selinux.if
mod_selinux-2.2.1930/.deps
mod_selinux-2.2.1930/LICENSE
mod_selinux-2.2.1930/README
mod_selinux-2.2.1930/modules.mk
mod_selinux-2.2.1930/mod_selinux.te
mod_selinux-2.2.1930/mod_selinux.c
[kaigai@saba ~]$ cd mod_selinux-2.2.1930
}}}

`make`でモジュールをビルドします。
{{{
[kaigai@saba mod_selinux-2.2.1930]$ make
/usr/lib64/apr-1/build/libtool --silent --mode=compile gcc -pthread  -O2 -g -pipe -Wall   \
       -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4   \
       -m64 -mtune=generic  -DLINUX=2 -D_REENTRANT -D_GNU_SOURCE    -I/usr/include/httpd  \
       -I. -I/usr/include/apr-1 -prefer-pic -c mod_selinux.c && touch mod_selinux.slo
/usr/lib64/apr-1/build/libtool --silent --mode=link gcc -pthread  -O2 -g -pipe -Wall      \
       -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector --param=ssp-buffer-size=4   \
       -m64 -mtune=generic     -Wl,-z,relro   -o mod_selinux.la -rpath /usr/lib/httpd/modules \
       -module -avoid-version -lselinux mod_selinux.lo
}}}

セキュリティポリシーもビルドします。
{{{
[kaigai@saba mod_selinux-2.2.1930]$ make -f /usr/share/selinux/devel/Makefile
Compiling targeted mod_selinux module
/usr/bin/checkmodule:  loading policy configuration from tmp/mod_selinux.tmp
/usr/bin/checkmodule:  policy configuration loaded
/usr/bin/checkmodule:  writing binary representation (version 10) to tmp/mod_selinux.mod
Creating targeted mod_selinux.pp policy package
rm tmp/mod_selinux.mod.fc tmp/mod_selinux.mod
}}}

=== 3. モジュールのインストール ===

`mod_selinux.so`と`mod_selinux.pp`をインストールします。

{{{
[kaigai@masu mod_selinux-2.2.1930]$ su
Password:
[root@saba mod_selinux-2.2.1930]# make install
make[1]: Entering directory `/home/kaigai/mod_selinux-2.2.1930'
/usr/lib/apr-1/build/libtool --silent --mode=install cp mod_selinux.la /usr/lib/httpd/modules/
make[1]: Leaving directory `/home/kaigai/mod_selinux-2.2.1930'
/usr/lib/apr-1/build/libtool --silent --mode=install cp mod_selinux.la /usr/lib/httpd/modules/
[root@saba mod_selinux-2.2.1930]# semodule -i mod_selinux.pp
}}}

=== 4. ファイルの再ラベリング ===

インストールされた`mod_selinux.so`が`httpd_modules_t`とラベル付けされていない場合、`/sbin/restorecon`を実行してください。
しかし、大抵の場合は必要ありません。
{{{
[root@saba ~]# restorecon -R /usr/lib/httpd/modules
}}}

----

= 設定 =

== ディレクティブ ==

`mod_selinux.so`は以下のディレクティブをサポートしています。

`selinuxServerDomain`はグローバルな設定である事が必要です。
残りの設定項目は任意の場所に記述する事ができます。
複数のディレクティブが一つのブロックにある場合、先に記述したものが、実行時にも先に評価されます。そして、残りのディレクティブは、HTTP要求が前のディレクティブにマッチしない時に評価されます。

=== selinuxServerDomain <ドメイン/レンジ ペア> ===

デーモンプロセスが起動するときのセキュリティコンテキストを指定します。
`mod_selinux.pp`ポリシーモジュールは、デーモンが`mcs_systemhigh`カテゴリ（全ての有効なカテゴリに展開される）で動作するよう`range_transition`ルールを追加しますが、大抵の場合、apache/httpdデーモンプロセスには過剰です。

`selinuxServerDomain`ディレクティブはスタートアップ時にこれをドロップする事を可能にします。
ドメイン/レンジペアはコロン(`:`)区切りの文字列で、最初のコロンの左側がドメインとして、残りの部分がレンジとして扱われます。
もしコロンが省略された場合、文字列の全体がドメインとして利用されます。アスタリスク(`*`)には特別な意味があり、現在の当該フィールドの値をそのまま利用するという事を意味します。

指定されたセキュリティコンテキストに変更できなかった場合、`mod_selinux.so`はエラーを起こし、プロセスの起動を中断します。

ディレクティブの例
{{{
selinuxServerDomain     *:s0-s0:c0.c15
}}}

これはドメインを現在の値のままとし、レンジに`s0-s0:c0.c15`をセットします。

=== selinuxDomainMap <マップファイル> ===

ユーザ/ドメインのマップファイルのパスを指定します。このファイルには、HTTP認証ユーザとドメイン/レンジペアの対応関係を記述します。

ディレクティブの例
{{{
selinuxDomainMap        /var/www/mod_selinux.map
}}}

マップファイルの例
{{{
#
# Apache/SELinux plus - user/domain mapping file
# ----------------------------------------------

# Format:
# <http user>      <domain/range pair>
#

foo                *:s0:c0
var                *:s0:c1
baz                *:s0:c2
__anonymous__      anon_webapp_t:s0
*                  user_webapp_t:s0
}}}

ドメイン/レンジペアの書式は`selinuxServerDomain`の記述と同様です。
`__anonymous__`は特別な語句で、全ての未認証リクエストにマッチします。
`*`も特別な語句で、全ての認証済み/未認証リクエストにマッチします。

=== selinuxDomainEnv <環境変数> ===

Webアプリケーションのコンテキストに設定すべきドメイン/レンジペアを与える環境変数を指定します。
いくつかの外部モジュールは、HTTP要求のメタ情報に応じて環境変数を設定する機能を提供しています。
ドメイン/レンジペアの書式は`selinuxServerDomain`の記述と同様です。

例えば、`SetEnvIf`ディレクティブは、リモートアドレスが所与のパターンにマッチした場合に特定の環境変数をセットアップする事ができます。

例：
{{{
SetEnvIf Remote_Addr "192.168.1.[0-9]+$" SELINUX_DOMAIN=*:s0:c1
SetEnvIf Remote_Addr "192.168.2.[0-9]+$" SELINUX_DOMAIN=*:s0:c2
selinuxDomainEnv    SELINUX_DOMAIN
}}}

この例は、`192.168.1.0/24`からのHTTP要求に"`s0:c1`"を割り当て、`192.168.2.0/24`からのHTTP要求に"`s0:c2`"を割り当てる設定です。しかし、それ以外のリクエストに対しては何もしません。

=== selinuxDomainVal <ドメイン/レンジペア> ===

コンテンツハンドラに割り当てるべきドメイン/レンジペアを指定します。
ドメイン/レンジペアの書式は`selinuxServerDomain`の記述と同様です。

通常、HTTP要求は他の`selinuxDomainMap`や`selinuxDomainEnv`にマッチしなかった場合のフォールバックとして、このディレクティブは設定の最後に置かれます。

例：
{{{
SetEnvIf Remote_Addr "192.168.1.[0-9]+$" SELINUX_DOMAIN=*:s0:c1
SetEnvIf Remote_Addr "192.168.2.[0-9]+$" SELINUX_DOMAIN=*:s0:c2
selinuxDomainMap    /var/www/mod_selinux.map      ... (1)
selinuxDomainEnv    SELINUX_DOMAIN                ... (2)
selinuxDomainVal    anon_webapp_t:s0              ... (3)
}}}

この例では、最初に(1)がチェックされます。HTTP要求がマップファイル内のエントリにマッチしたら、`mod_selinux.so`はコンテンツハンドラを指定されたドメイン/レンジペアで起動します。
次に(2)がチェックされます。環境変数`SELINUX_DOMAIN`は`Remote_Addr`に基づいてセットされますが、HTTP要求が特定のネットワークから来ていた場合、この環境変数は有効な値を持ちます。
それ以外の場合、(1)及び(2)にマッチしなかったHTTP要求に対して(3)が適用され、`anon_webapp_t:s0`で起動されることでしょう。

=== selinuxAllowCaches (on|off) ===

Apache/httpdの公式ドキュメントが言及しているように、コンテンツキャッシュは認証及びドメイン遷移より前に動きます。
これは、ユーザにアクセス制御をバイパスさせる事を意味します。
標準では、`selinuxAllowCaches`が明示的に`On`とセットされない限り、`mod_selinux.so`はコンテンツキャッシュを無効化します。

このディレクティブはコンテンツキャッシュの利用を許可しますが、これを`on`にする前に、そのリスクを理解するようにしてください。

例：
{{{
selinuxAllowCaches      On
}}}

----

= よくある例 =

本節では、`mod_selinux.so`設定のよくある例を紹介します。

== バーチャルホスト単位の分離 ==

もし`selinuxDomainVal`が単独で記述されたら、全てのHTTP要求は常に指定された権限で動作する事を意味します。
これをバーチャルホスト単位の分離に利用する事ができます。

この例では、`dog.example.com`への全てのHTTP要求は`s0:c1`で処理され、`cat.example.com`への要求は`s0:c2`で処理されます。
{{{
NameVirtualHost *:80

<VirtualHost *:80>
DocumentRoot          /var/www/html-dog
ServerName            dog.example.com
selinuxDomainVal      *:s0:c1
</VirtualHost>

<VirtualHost *:80>
DocumentRoot          /var/www/html-cat
ServerName            cat.example.com
selinuxDomainVal      *:s0:c2
</VirtualHost>
}}}

== DB連携による認証 ==

`mod_authn_dbd.so`モジュールはバックエンドのデータベースつかったユーザ認証を可能にします。
このモジュールは、設定されたクエリによってDBレコードを引き出し、さらに環境変数としてその情報をエクスポートする事ができます。
`selinuxDomainEnv`ディレクティブはこの情報を利用する事ができ、それにより、マップファイル無しでユーザとドメイン/レンジペアを対応付ける事ができます。

この例では、以下の`uaccount`テーブルが`web`データベースにセットアップ済みであり、DBユーザ`apache`がこのテーブルにアクセス可能であると仮定します。この接続はapache/httpdサーバのドメインから行われている事に留意して下さい。SE-PostgreSQLは`selinuxServerDomain`で設定したドメインからの接続を許可している必要があります。
{{{
CREATE TABLE uaccount (
        uname       TEXT PRIMARY KEY,
        upass       TEXT NOTE NULL,
        udomain     TEXT
);

INSERT INTO uaccount VALUES ('foo', 'xxx', 'user_webapp_t:s0:c0');
INSERT INTO uaccount VALUES ('var', 'yyy', 'staff_webapp_t:s0:c1');
INSERT INTO uaccount VALUES ('baz', 'zzz', 'anon_webapp_t:s0:c2');
}}}

Apache/httpdの設定例：
{{{
#
# 1. Load the dbd drivers
#
LoadModule dbd_module        modules/mod_dbd.so
LoadModule authn_dbd_module  modules/mod_authn_dbd.so

#
# 2. Database connection parameters
#

DBDriver    pgsql
DBDParams   "dbname=web user=apache"

<Directory "/var/www/html">
#
# 3. Digest authentication
#
AuthType               Digest
AuthName               "Secret Zone"
AuthDigestProvider     dbd
AuthDBDUserRealmQuery  \
    "SELECT md5(uname || ':' || $2 || ':' || upass), udomain, \
            %s=%s as dummy FROM uaccount WHERE uname = $1"

#
# 4. SELinux context mapping
#
selinuxDomainEnv         AUTHENTICATE_UDOMAIN
selinuxDomainVal         anon_webapp_t:s0
</Directory>
}}}
最初に、デフォルトの設定はdbdドライバをロードしないため、これをグローバル領域でロードする必要があります。
(2)ではデータベース接続パラメータを指定します。`DBDriver`はdbdドライバの種類。この場合、`apr-util-pgsql`パッケージの追加インストールが必要です。`DBDParams`は接続文字列で、詳細に関してはPostgreSQLのドキュメントを参照してください。

(3)は認証パラメータを指定します。BASIC認証の場合、`mod_authn_dbd`モジュールはクエリがハッシュ化されたパスワード文字列を返すよう求めていますが、PostgreSQLはこのハッシュ化方式を標準でサポートしていません。なので、ここではDigest認証を利用します。
`mod_authn_dbd`へはハッシュ化された文字列`md5(username : realm : password)`を返却する必要があります。`username`と`realm`はモジュールから渡され、ハッシュ値はクライアントから来た認証トークンと比較されます。

クエリが複数のフィールドを返す場合、`mod_authn_dbd`は（先頭のフィールドを除き）これらを環境変数`AUTHENTICATE_<フィールド名>`としてエクスポートします。したがって、2番目と3番目のフィールドは`mod_selinux`に渡されます。

3番目のフィールドは奇妙なパラメータの使い方（`%s=%s as dummy`）に見えるかもしれません。
`mod_dbd`モジュールは、`%s`をプリペアード・ステートメントのパラメータに置換しますが、現在のところ、その順番は固定です。最初のパラメータは常にユーザ名に置換され、2番目はレルム文字列です。しかし、レルム文字列をユーザ名より前に置く事が必要なので、ここでは`$1`と`$2`をクエリ中に直接記載し、無害化のためにダミーの`%s`を置いています。

(4)ではまず、`AUTHENTICATE_UDOMAIN`環境変数に基づいてセキュリティコンテキストの設定を試み、もし値が設定されていなかった場合、`selinuxDomainVal`がフォールバックとして利用されます。

----

= ソースコードの一覧 =

英語版ドキュメントの [Apache_SELinux_plus#List_of_sources List of sources] を参照してください。
