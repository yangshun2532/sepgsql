#labels Phase-Design
= The SE-PostgreSQL Documents =

http://sepgsql.googlecode.com/files/sepgsql_logo.png

The Security-Enhanced PostgreSQL (SE-PostgreSQL) is a built-in enhancement of PostgreSQL to provide additional access controls based on SELinux's security policy. The series of documents provides comprehensive explanations for SE-PostgreSQL.

= Indexes =

 * [TheSepgsqlDocument#Introduction Introduction]
 * [TheSepgsqlDocument#Architecture Architecture]
 * [TheSepgsqlDocument#Specification Speficication]
 * [TheSepgsqlDocument#SELinux_overview SELinux overview]
 * [TheSepgsqlDocument#Administration Administration]
 * [TheSepgsqlDocument#References References]

= Introduction =

This chapter shows the overview and the target of SE-PostgreSQL.

== What is SE-PostgreSQL ==

As widely understood, nowaday databases are significant facilities to manage our information assets.
It enables to search, fetch and store them in more elegant way than what we did on filesystem.
However, some of requirements have complaint for its access control mechanism from the viewpoint of consistency whole of the system including operating system and database management system.

Some of modern operating system has enhanced access controls features like SELinux.
Most of them are designed based on the reference monitor model come from '80s researches, and it enables to manage all the accesses to the system by the centralized security policy.
The reference monitor model assumes that object managers (like operating system) can trap all the accesses and makes its decision whether it should be allowed, or not.
It is correct, but it's not always true that object manager is operating system.
RDBMS is an object manager for any database objects as like as operating system doing on filesystem objects, and it has to make its decision on access controls, but prior RDBMS has worked independently from the centralized security policy. Thus, we had to take meticulous care to keep its consistency.

The Security-Enhanced PostgreSQL (SE-PostgreSQL) is a built-in enhancement of PostgreSQL to apply fine-grained mandatory access controls on database objects, collaborating with SELinux.
It makes access control decision based on SELinux's security policy, as if user accesses to filesystem objects managed by operating system.
It has the following three significant features.

*Mandatory access controls*:

 PostgreSQL has a concept of database superuser, who can bypass all the access controls of native PostgreSQL. On the contrary, SE-PostgreSQL enforces its access controls on any client without any exception, even if the client is a database superuser.
 Only when the accesses are allowed by both the native PostgreSQL and SE-PostgreSQL, the client can access to required database objects. The relationship is similar to one between discretionary access controls (DAC) and mandatory access controls (MAC) on operating system.

*Fine-grained access controls*:

 Granularity of access controls depend on the kind of RDBMS. Only a few commercial RDBMS support column and row level access controls option, but SE-PostgreSQL also enables us to set up its access controls in column and row level.
 These are the smallest unit of database objects, so it allows database administrator to apply the most flexible access controls on them.

*Consistency in access controls*:

 SELinux requires each processes and objects have its security context to represent its privileges and attributes. SE-PostgreSQL assigns a security context for each database tuples, and makes its access control decision based on the attribute as SELinux doing in the kernel. 
 The `libselinux` provides an interesting API named as `getpeercon()`, which enables to get the security context of peer process connects to the server process. SE-PostgreSQL applies the peer security context to make its decision. It is a significant feature for consistency in access controls that privileges of client and attributes of objects are represented in same forms.

== Why we need consistency in access controls ==

We can consider RDBMS, including PostgreSQL, is one of the inter-process communication channels like filesystems, networks, IPC and so on.

It is the most significant purpose for security mechanisms to protect leaking classified information, but it is obvious that malicious attacker can choose the most vulnerable inter-process communication channel, not well protected ones. The matter come from subsystems have individual criteria of access controls, not a centralized one.

SELinux is an operating system feature to apply a single unified security policy whole of the operating system with trapping system calls. It is a correct approach to enforce the policy with minimum cost, however, we have to keep in mind that several userspace object manager (like X-window, RDBMS, ...) can be used as a inter-process communication channel. The resources managed in userspace are invisible from the kernel, so we have two options. The one is traditional all-or-nothing policy which does not allow to share userspace objects, but unrealistic. The other is enhancement of userspace object manager which makes its access control decision based on a signle unified security policy of SELinux.

http://sepgsql.googlecode.com/files/sepgsql-docs-figure.01.png

The above figure shows the example of this kind of consistency called as data flow controls. It requires classified information does not leak to unclassified domain via inter-process communication channels, independent from the sort of them.

When a user with clearance logged in this system, his user process is labeled as `SystemHigh` which is allowed to refer secret information asset labeled as `Secret`.
In contrast, when a user without clearance logged in, his user process is labeled as `SystemLow` which does not allowed to refer secret ones.
In addition, it does not allow `SystemHigh` process to send messages to `SystemLow` process independent from the sort of inter-process communication channels.

If user processes without clearance tries to read secret information stored within objects managed by kernel, or user processes with clearance tries to write secret ones into unclassified object, in-kernel SELinux directly prevents these operation according to the security policy.

When the same actions are invoked on RDBMS, SE-PostgreSQL asks in-kernel SELinux whether the required operation is violated, or not. Then it applies the decision made by SELinux, so it means SELinux indirectly controls accesses in userspace.

----------------------------------------


= Architecture =

This chapter introduces the architecture of SE-PostgreSQL.

== Interactions between subsystems ==

SE-PostgreSQL takes a hand in SQL query processing at two places.
The first one is a phase just after query rewriting, the other is the head and during the executor running.

http://sepgsql.googlecode.com/files/sepgsql-docs-figure.02.png

At first, the client sends SQL queries in string format, it invokes all the following subsystems.
Then, the given SQL queries are delivered to the query parser to split up the string into tree-structured tokens. Then, the tokens are delivered to the query analyzer to resolve identifier of object names and to confirm its existances. If views are used in the given queries, the query rewriter expand the views into raw expression described in `SELECT` statement.

The first interposition of SE-PostgreSQL is here. It walks on the given query trees and picks up all appeared tables, columns and procedures to make a list of accessed objects to check privileges later. Please note that all views are already expanded at this moment. SE-PostgreSQL does not care about any views and all the access controls are applied on expanded relations, because it focuses on what relation is accessed, not how the relation is accessed.

Then, the query trees are delivered to the optimizer to make execution plan tree. It is delivered to the executor and it accesses to databases to make a result set to be returned to user.

The later interposition of SE-PostgreSQL is also here. It is invoked at the head of the executor to check access privileges to appeared database objects on the list. It makes access control decision with communicating to in-kernel SELinux, if necessary. If the given query contains violated accesses to tables, columns and procedures, it raised an error to abort query execution. 
The rest of interposition is invoked while the executor scanns required relations. When a tupls is fetched from relation, the executor invokes SE-PostgreSQL to check whether the client has proper privileges to tuple tuple, or not. If it is violated, the tuple is dropped from the result set, so it seems to client as if filtered tuples are not here. The reason why row-level access controls are applied in separating is we cannot know what tuples are fetched until the queries are executed.
At the last, the result set is returned to the client.


== PGACE security framework ==

The core PostgreSQL invokes SE-PostgreSQL subsystem via series of wrapper functions called as PGACE (PostgreSQL Access Control Extention) security framework. It provides a few dozen of hooks deployed on strategic points of PostgreSQL. These hooks are declared as `static inline` functions, and they contain codes to invoke SE-PostgreSQL which is activated only when we give `--enable-selinux` option in configure scripts.

The purpose of this architecture is minimization of impact to add a new security facility.
SE-PostgreSQL is one of the options of enhanced security mechanisms, however, we can consider similar facilities based on different security design and philosophy. 

The PGACE security framework is designed references from LSM (Linux Security Module). It enables to hide complexity of mixed enhanced security features to core implementation. We call implementations of enhanced security feature as the guest. The gust can put codes to invoke itself on PGACE hooks, enclosed by `#if ... #endif` block.

Here is an example of PGACE hooks, which is invoked just before a new tuple is inserted into relation. SE-PostgreSQL need to be invoked to assign proper security context and to check the privileges of the client, so we put the following code on the `pgaceHeapTupleInsert()` hook.
{{{
     +---- ExecInsert() ----------------------------+
     |              :                               |
 +---|--O  if (!pgaceHeapTupleInsert(....))         |
 |   |             return;    /* skip insertion */  |
 |   |              :                               |
 |   +----------------------------------------------+
 |
 |      at src/include/security/pgace.h
 |    +---- pgaceHeapTupleInsert() -----------------------------------+
 +--->|  #if defined(HAVE_SELINUX)                                    |
      |  if (selinux_enabled) {                                       |
      |      - attach default security attribute                      |
      |      - check whether the client can insert the tuple, or not. |
      |  }                                                            |
      |  #endif                                                       |
      |  return true;  /* default behavir of this hook */             |
      +---------------------------------------------------------------+
}}}

This hook requires the guest returns `true` or `false` to decide whether the given tuple should be inserted, or not. When the SE-PostgreSQL feature is enables on build-time and run-time, this hook invokes SE-PostgreSQL subsystem to attach proper security attribute and to check client's privileges. If the security policy does not allow to insert, SE-PostgreSQL returns `false` to prevent the action.

The default behavior does not change existing bahavior of core PostgreSQL implementation.
If a new guest does not want to use all the hooks, it can remain these hooks unchanged. It remains existing behavior.

== Security context management ==

=== What is security context ? ===


{{{
<selinux user>:<role>:<type/domain>:<range>

}}}


=== security_context system column ===


=== interaction with pg_security system catalog ===


























----------------------------------------

= Specifications =

This chapter introduces the details of access controls in SE-PostgreSQL.


== Access controls for columns ==
== Access controls for tables ==
== Access controls for tuple ==


== Access controls for procedures ==
== Access controls for large objects ==

 - import/export

== Access controls for databases ==


== Special cases ==

=== Trusted procedure ===
=== Trigger functions ===
=== Unique constraint ===
=== Foreign Key constraint ===
=== Loading shared library modules ===


----------------------------------------

= SELinux overview =
== Rerefence monitor model ==
== Type Enforcement ==
== Role Based Access Control ==
== MLS and MCS ==
== booleans ==
== The default security policy ==


----------------------------------------

= Administration =

== Installation and setup ==

== Labeled networking ==

== Backup and restore ==

----------------------------------------

= References =

== Object classes and permission ==

== Pre-defined object types ==

== Enhanced SQL statement ==

== Enhanced SQL functions ==

