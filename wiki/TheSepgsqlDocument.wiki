#labels Phase-Design
= The SE-PostgreSQL Documents =

http://sepgsql.googlecode.com/files/sepgsql_logo.png

The Security-Enhanced PostgreSQL (SE-PostgreSQL) is a built-in enhancement of PostgreSQL to provide additional access controls based on SELinux's security policy. The series of documents provides comprehensive explanations for SE-PostgreSQL.

= Indexes =

 * [TheSepgsqlDocument#Introduction Introduction]
 * [TheSepgsqlDocument#Architecture Architecture]
 * [TheSepgsqlDocument#Specification Speficication]
 * [TheSepgsqlDocument#SELinux_overview SELinux overview]
 * [TheSepgsqlDocument#Administration Administration]
 * [TheSepgsqlDocument#References References]

= Introduction =

This chapter shows the overview and the target of SE-PostgreSQL.

== What is SE-PostgreSQL ==

As widely understood, nowaday databases are significant facilities to manage our information assets.
It enables to search, fetch and store them in more elegant way than what we did on filesystem.
However, some of requirements have complaint for its access control mechanism from the viewpoint of consistency whole of the system including operating system and database management system.

Some of modern operating system has enhanced access controls features like SELinux.
Most of them are designed based on the reference monitor model come from '80s researches, and it enables to manage all the accesses to the system by the centralized security policy.
The reference monitor model assumes that object managers (like operating system) can trap all the accesses and makes its decision whether it should be allowed, or not.
It is correct, but it's not always true that object manager is operating system.
RDBMS is an object manager for any database objects as like as operating system doing on filesystem objects, and it has to make its decision on access controls, but prior RDBMS has worked independently from the centralized security policy. Thus, we had to take meticulous care to keep its consistency.

The Security-Enhanced PostgreSQL (SE-PostgreSQL) is a built-in enhancement of PostgreSQL to apply fine-grained mandatory access controls on database objects, collaborating with SELinux.
It makes access control decision based on SELinux's security policy, as if user accesses to filesystem objects managed by operating system.
It has the following three significant features.

*Mandatory access controls*:

 PostgreSQL has a concept of database superuser, who can bypass all the access controls of native PostgreSQL. On the contrary, SE-PostgreSQL enforces its access controls on any client without any exception, even if the client is a database superuser.
 Only when the accesses are allowed by both the native PostgreSQL and SE-PostgreSQL, the client can access to required database objects. The relationship is similar to one between discretionary access controls (DAC) and mandatory access controls (MAC) on operating system.

*Fine-grained access controls*:

 Granularity of access controls depend on the kind of RDBMS. Only a few commercial RDBMS support column and row level access controls option, but SE-PostgreSQL also enables us to set up its access controls in column and row level.
 These are the smallest unit of database objects, so it allows database administrator to apply the most flexible access controls on them.

*Consistency in access controls*:

 SELinux requires each processes and objects have its security context to represent its privileges and attributes. SE-PostgreSQL assigns a security context for each database tuples, and makes its access control decision based on the attribute as SELinux doing in the kernel. 
 The `libselinux` provides an interesting API named as `getpeercon()`, which enables to get the security context of peer process connects to the server process. SE-PostgreSQL applies the peer security context to make its decision. It is a significant feature for consistency in access controls that privileges of client and attributes of objects are represented in same forms.

== Why we need consistency in access controls ==

We can consider RDBMS, including PostgreSQL, is one of the inter-process communication channels like filesystems, networks, IPC and so on.

It is the most significant purpose for security mechanisms to protect leaking classified information, but it is obvious that malicious attacker can choose the most vulnerable inter-process communication channel, not well protected ones. The matter come from subsystems have individual criteria of access controls, not a centralized one.

SELinux is an operating system feature to apply a single unified security policy whole of the operating system with trapping system calls. It is a correct approach to enforce the policy with minimum cost, however, we have to keep in mind that several userspace object manager (like X-window, RDBMS, ...) can be used as a inter-process communication channel. The resources managed in userspace are invisible from the kernel, so we have two options. The one is traditional all-or-nothing policy which does not allow to share userspace objects, but unrealistic. The other is enhancement of userspace object manager which makes its access control decision based on a signle unified security policy of SELinux.

http://sepgsql.googlecode.com/files/sepgsql_dfc.png

The above figure shows the example of this kind of consistency called as data flow controls. It requires classified information does not leak to unclassified domain via inter-process communication channels, independent from the sort of them.

When a user with clearance logged in this system, his user process is labeled as `SystemHigh` which is allowed to refer secret information asset labeled as `Secret`.
In contrast, when a user without clearance logged in, his user process is labeled as `SystemLow` which does not allowed to refer secret ones.
In addition, it does not allow `SystemHigh` process to send messages to `SystemLow` process independent from the sort of inter-process communication channels.

If user processes without clearance tries to read secret information stored within objects managed by kernel, or user processes with clearance tries to write secret ones into unclassified object, in-kernel SELinux directly prevents these operation according to the security policy.

When the same actions are invoked on RDBMS, SE-PostgreSQL asks in-kernel SELinux whether the required operation is violated, or not. Then it applies the decision made by SELinux, so it means SELinux indirectly controls accesses in userspace.
















= Architecture =

This chapter introduces the architecture of SE-PostgreSQL.

== Security context management ==

=== What is security context ? ===


=== security_context system column ===


=== interaction with pg_security system catalog ===


== Interactions between subsystems ==



== PGACE security framework ==





















= Specifications =

This chapter introduces the details of access controls in SE-PostgreSQL.


== Access controls for columns ==
== Access controls for tables ==
== Access controls for tuple ==


== Access controls for procedures ==
== Access controls for large objects ==

 - import/export

== Access controls for databases ==


== Special cases ==

=== Trusted procedure ===
=== Trigger functions ===
=== Unique constraint ===
=== Foreign Key constraint ===
=== Loading shared library modules ===




= SELinux overview =
== Rerefence monitor model ==
== Type Enforcement ==
== Role Based Access Control ==
== MLS and MCS ==
== booleans ==




= Administration =

== Installation and setup ==

== Labeled networking ==

== Backup and restore ==


= References =

== Object classes and permission ==

== Default security policy ==

== Enhanced SQL statement ==

== Enhanced SQL functions ==

