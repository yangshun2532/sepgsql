<chapter id="enhanced-security-and-sepostgresql">
  <title>Enhanced Security and SE-PostgreSQL</title>
  <para>
    This chapter introduces enhanced security features which enable
    <productname>PostgreSQL</productname> to provide mandatory
    access controls, fine-grained access controls, and integration
    of security policy between the operating system and
    <productname>PostgreSQL</productname>.
  </para>
  <para>
    <ulink url="http://wiki.postgresql.org/wiki/SEPostgreSQL">
      The SE-PostgreSQL documentation
    </ulink>
    also provides a comprehensive documentation.
    Please also see the wikipage for more details.
  </para>
  <para>
    The current version of <productname>PostgreSQL</productname>
    has an enhanced security facility named as SE-PostgreSQL
    (Security Enhanced PostgreSQL).

    SE-PostgreSQL provides additional fine-grained mandatory access
    controls on accesses to database objects using SQL. It makes a
    decision whether the given requests from client should be allowed,
    or not, communicating with in-kernel SELinux.

    SELinux has its security policy which is a set of white listed
    rules, and provides its access control decisions to the kernel
    and userspace object manager.

    The key concept of SE-PostgreSQL is integration of access controls
    between operating system and database management systems.
    It makes and applies its access control decision based on a single
    unified security policy of operating system.

    It applies the security context of the peer process as privileges
    of the client, independent from database authentication.
    It also manages security context of the database objects, and
    asks SELinux whether it allows a certain actions between a pair
    of security contexts.

    The access controls implemented by SE-PostgrSQL shall not be bypassed
    even if the given queries are come from database superuser, from the
    definition of mandatory access controls (MAC).

    The exising database ACLs are also checked.
    This double checks enable to prevent information leaks and manipulations
    from malicious attackers, and reduce risks for SQL injections or other
    application level bugs.
  </para>

  <para>
    To enable SE-PostgreSQL, specify <option>--enable-selinux</option> option
    at <command>configure</command> stage,
    and use the <option>--enable-selinux</option> option to
    <command>initdb</command>.
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make install</userinput>
<prompt>$ </prompt><userinput>initdb --enable-selinux</userinput>
</screen>
  </para>

  <sect1 id="sepostgresql-features">
    <title>SE-PostgreSQL Features</title>

    <sect2 id="sepostgresql-single-unified-security-policy">
      <title>Single unified security policy</title>

      <para>
	We can show an analogy between filesystem and database management
	system, both of them have a similar capabilities to store information
	asserts and similar access controls to control accesses to keep
	confidentiality and integrity.

	We uses system calls to access information assets stored within
	a filesystem, such as <command>write(2)</command> system call.
	On the other hand, we uses SQL queries to access information assets
	stored within a database.
      </para>
      <para>
	Both of the methods to access information assets are checked by
	access control features, such as UNIX permission mechanism and
	database ACLs, called discretionary access controls (DAC).

	In addition, the recent Linux system also applies additional
	access controls from the different viewpoint, called mandatory
	access controls (MAC).

	However, it was not available on accesses to database objects
	as far as we don't have specific support for MAC.
	It also means the databases was an uncontrollable communication
	chanel from the viewpoint of the MAC system.
      </para>
      <para>
	SE-PostgreSQL is an implementation of MAC feature on database
	management system, collaborating with host operating system
	(SELinux).

	It acquires the given SQL, as if SELinux hooks system calls,
	and applies its access controls based on the unified security
	policy.

	Because they shares a security policy and common forms to
	represent client's privileges and attributes of the database
	objects, it always makes consistent result in access controls.
      </para>
      <para>
	For example, both of SELinux and SE-PostgreSQL never allows
	users to access filesystem or database objects labeled as
	<literal>Classified</literal>, as far as they don't have
	enough privileges set, independent from the way to store
	the information.

	The DAC mechanisms perform independently based on its own
	privileges set and access control rules, so it is a hard
	work to keep consistency between operating system and
	database management systems.
      </para>

      <sect3 id="sepostgresql-security-context">
	<title>Security Context</title>
	<para>
	  The security policy is a set of massive rules for access
	  controls. A rule is defined as a relationship between
	  a subject entity and an object entiry on a certain action.

	  All the entity is identified with a common attribute
	  called a security context. Any other attributes don't
	  give any effects in access controls, such as ownership,
	  pathname and so on.
	</para>
	<para>
	  The security context is a formatted text independent from
	  sort of the objects being labeled, such as:
	  <synopsis>system_u:object_r:postgresql_db_t:SystemHigh</synopsis>.

	  The security context is assigned to variable objects managed
	  by operating system and some of userspace object manager
	  including SE-PostgreSQL.

	  The kernel manages security context of the files, sockets,
	  processes and so on. In the same manner, SE-PostgreSQL also
	  manages security context of the database objects, such as
	  tables, columns and so on.
	</para>
	<para>
	  For example, when a process labeled as
	  <literal>system_u:system_r:postgresql_t:s0</literal> tries to
	  write a log message to <filename>/var/log/postgresql.log</filename>
	  labeled as <literal>system_u:object_r:postgresql_log_t:s0</literal>,
	  it issues a <literal>write(2)</literal> system call;
	  SELinux checks its security policy to find up a rule to describe
	  allowed actions for given pair of the security contexts.

	  If it can find the entry which allows the operatin, SELinux
	  does not prevent anything. Otherwise, SELinux blocks the
	  <literal>write(2)</literal> system call.
	</para>
	<para>
	  Any object managers which want a decision come from SELinux
	  (including kernel) should have the capability to manage the security
	  contexts of their objects.

	  For example, most of major filesystems support xattr (Extended
	  Attributes) facilities which allows to store individual security
	  context of files.

	  SE-PostgreSQL also provides a facility to manage security context
	  of a few kind of database objects (databases, tables, columns and
	  procedures). We can set up them via enhanced DDL statement.
	</para>
      </sect3>

      <sect3 id="sepostgresql-client-privileges">
	<title>Client Privileges</title>
	<para>
	  SE-PostgreSQL needs to obtain the security context of the peer
	  process which connected to. SELinux provides an interface for
	  the purpose: <literal>getpeercon(3)</literal>. It returns the
	  security context of the peer process of the given socket.

	  Note that the security context of peer process is unrelated to
	  the database role and authentication.
	</para>

	<para>
	  From the SQL, the security context of the clietn can be confirmed
	  using the <literal>sepgsql_getcon()</literal> function, like this:
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t:Classified
<prompt>$ </prompt><userinput>psql -q</userinput>
<prompt>postgres=# </prompt><userinput>SELECT sepgsql_getcon();</userinput>
                  sepgsql_getcon
---------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:Classified
(1 row)
</screen>
	</para>

	<para>
	  When connecting to SE-PostgreSQL via a TCP/IP socket, labeled
	  networking must be set up to ensure that
	  <literal>getpeercon(3)</literal> returns the correct security
	  context.

	  See the
	  <ulink url="http://wiki.postgresql.org/wiki/SEPostgreSQL_Administration#Labeled_networks">
	    SE-PostgreSQL Administration->Labeled networks
	  </ulink> in the SE-PostgreSQL documentation for more details.
	</para>
      </sect3>
    </sect2>

    <sect2 id="sepostgresql-functionality">
      <title>The functionality of SE-PostgreSQL</title>

      <sect3>
	<title>Access controls on Tables and Columns</title>
	<para>
	  SE-PostgreSQL applies its access control policies on the tables
	  and columns picked up by the parser and analyzer, just after the
	  checks on the standard database ACLs.

	  If the security policy does not allow to access one of the tables
	  or columns required at least, it raises an error and abort execution
	  of the query.
	</para>
	<para>
	  In the following example, the <literal>customer</literal> table
	  is declared with three columns, and the <literal>ccredit</literal>
	  column is labeled as <literal>sepgsql_secret_table_t</literal>
	  especially. It means the contents of the column is hidden from
	  unclassified clients.

	  Please note that the default security context is assigned on
	  other columns and the <literal>customer</literal> table, it
	  allows unprivileged users to access.
	</para>
<screen>
CREATE TABLE customer (
    cid     integer primary key,
    cname   varchar(32),
    credit  varchar(32)
        SECURITY_LABEL = 'system_u:object_r:sepgsql_secret_table_t'
);
GRANT ALL ON customer TO PUBLIC;

INSERT INTO customer (cid, cname, credit)
    VALUES ( 10, 'jack', '1111-2222-3333-4444'),
           ( 13, 'adam', '5555-6666-7777-8888'),
           ( 14, 'liza', '9876-5432-1098-7654');
</screen>

<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql -q postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname FROM customer;
 cid | cname
-----+-------
  10 | jack
  13 | adam
  14 | liza
(3 rows)
</screen>
       <para>
	 At the first query, the user tried to access all the columns
	 including <literal>ccredit</literal>.
	 SE-PostgreSQL prevents query execution due to the lack of
	 privileges on the <literal>ccredit</literal> column labeled
	 as <literal>sepgsql_secret_table_t</literal>.

	 Then, the user tried to refer the two columns expect for
	 the <literal>ccredit</literal> column, so SE-PostgreSQL
	 didn't prevent anything.
       </para>
       <para>
	 In this statement, the <literal>customer</literal> table is
	 read only accessed, so <literal>db_table:{select}</literal>
	 and <literal>db_column:{select}</literal> permissions are
	 checked.

	 Please note that several permissions are defined on the
	 <literal>db_table</literal> and <literal>db_column</literal>
	 object classe. For example, <literal>db_table:{update}</literal>
	 shall be checked on the target table of <literal>UPDATE</literal>
	 statement.

	 See 
	 <ulink url="http://wiki.postgresql.org/wiki/SEPostgreSQL_References#Object_classes_and_access_vector">
	   The SE-PostgreSQL References->Object classes and access vectors
	 </ulink>
	 for more details.
       </para>
     </sect3>
     <sect3>
       <title>Access Controls on Functions</title>
       <para>
	 SE-PostgreSQL also checks permissions on invocations of functions.
	 Internally, PostgreSQL implements operators as functions.
	 So, it also checks invocations of functions which are the backends
	 of operators, such as comparison of integer values.
       </para>
       <para>
	 In the default security policy, a function declared by administrative
	 users (like <literal>unconfined_t</literal> domain) is labeled as
	 <literal>sepgsql_proc_exec_t</literal> which allows anyone to invoke
	 the functions.

	 On the other hand, ones declared by unprivileged users
	 (like <literal>user_t</literal>) are labeled as
	 <literal>user_sepgsql_proc_exec_t</literal> which allows only
	 <literal>user_t</literal> domain, so the administrative domains
	 cannot invoke user defined functions without relabeling.

	 It is a preventive measure to avoid an administrative user's
	 invocations of user defined malicious functions by mistake.
	 They need to confirm its declaration and relabel its security
	 context to the <literal>sepgsql_proc_exec_t</literal>.
       </para>
       <para>
	 SE-PostgreSQL provides an interesting feature which allows to switch
	 privileges of the client during execution of certain functions called
	 trusted procedures.
	 It is similar idea with security definer functions, but it affects to
	 the security context rather than database roles.

	 In the default security policy, trusted procedures are labeled as
	 <literal>sepgsql_trusted_proc_exec_t</literal>, and gives a chance
	 unprivileged users to access confidential informations using
	 a trusted method.
       </para>
       <para>
	 The following example declares a trusted procedure
	 <literal>show_credit</literal> to expose some, but not all,
	 of the credit card number stored in <literal>credit</literal>.
       </para>
<screen>
# CREATE OR REPLACE FUNCTION show_credit (integer) RETURNS text
    LANGUAGE 'sql'
    SECURITY_LABEL = 'system_u:object_r:sepgsql_trusted_proc_exec_t'
    AS 'SELECT substring(credit from ''^[0-9]+-'') || ''xxxx-xxxx-xxxx''
            FROM customer WHERE CID = $1';
CREATE FUNCTION
# \q
</screen>
<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: security policy violation
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname |     show_credit
-----+-------+---------------------
  10 | jack  | 1111-xxxx-xxxx-xxxx
  13 | adam  | 5555-xxxx-xxxx-xxxx
  14 | liza  | 9876-xxxx-xxxx-xxxx
(3 rows)

postgres=#
</screen>
     </sect3>
    </sect2>

    <sect2>
      <title>Limitations</title>
      <para>
	SE-PostgreSQL does not prevent information leaks via covert channels.
	It means unprivileged user can infer an information from the
	circumstances in some cases.

	If your requirement includes elimination of the covert channels,
	SE-PostgreSQL is not an adequate solution.
	In the common criteria (CC), known as ISO/IEC15408, a few
	functional components requires elimination of the covert
	chennels, but it is less commonly for enterprise class systems.
      </para>
      <para>
	A typical covert channel is a case when we delete a primay key
	tuple refered by one or more invisible foreign keys.
	SE-PostgreSQL shall prevent the deletion to preserve referencial
	integrity, however, the error status infors users the existence
	of the invisible tuples anywhere.

	As a practical matter, it is avoidable using non-natural primary
	and foreign keys, such as UUIDs. It makes impossible to infer
	any meaningful information.
      </para>
    </sect2>
  </sect1>

  <sect1 id="sepostgresql-administration">
    <title>SE-PostgreSQL Administration</title>

    <sect2>
      <title>Build and Installation</title>
      <sect3>
	<title>Requirement</title>
	<para>
	  We need the following packages to build and install
	  SE-PostgreSQL correctly. Please check it at first.
	</para>

	<variablelist>
	  <varlistentry>
	    <term><literal>Linux kernel</literal></term>
	    <listitem>
	      <para>
		Linux kernel has to support SELinux feature, at least.
		In addition, it is necessary to provide an interface to
		obtain a list of supported object classes and permissions
		via <filename>/selinux/class</filename>, which is available
		on the Linux kernel 2.6.24 or later.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>Security policy</literal></term>
	    <listitem>
	      <para>
		The security policy of SELinux is neccesary to contain access
		control rules related to database objects.
		The upstreamed security policy (<literal>20080702</literal>
		or later) already has a set of rules for SE-PostgreSQL,
		as a part of PostgreSQL policy.
	      </para>
	      <para>
		In <literal>Red Hat EL</literal> or <literal>Fedora</literal>,
		check the version number of <literal>selinux-policy</literal>
		rpm package is <literal>3.4.2</literal>, or later.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>libselinux</literal></term>
	    <listitem>
	      <para>
		<literal>libselinux</literal> is a set of interfaces to
		communicate between applications and SELinux in the kernel.
		The <literal>libselinux-2.0.80</literal> or later is
		necessary to build and run the SE-PostgreSQL.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>checkmodule</command></term>
	    <listitem>
	      <para>
		The <command>checkmodule</command> is a policy compiler
		for a modular policy package, such as
		<literal>sepostgresql-devel.pp</literal> we provided.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>semodule</command></term>
	    <listitem>
	      <para>
		The <command>semodule</command> is a command to manage
		modular policy packages. It enables to link/unlink,
		upgrade or load/unload modular policy packages, such as
		<literal>sepostgresql-devel.pp</literal> we provided.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>restorecon</command></term>
	    <listitem>
	      <para>
		The <command>restorecon</command> enables to assign
		correct security context for files, directories and
		any other objects on filesystem, based on the security
		policy configuration.
		It helps to assign correct security context on
		installed files by hand.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Build</title>
	<para>
	  SE-PostgreSQL feature is disabled in the default build.
	  So, we have to add <option>--enable-selinux</option> option
	  to configure script. It enables to build your PostgreSQL
	  with a feature to suppor SELinux.
	</para>
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make</userinput>
<prompt>$ </prompt><userinput>make -C src/backend/security/sepgsql/policy</userinput>
</screen>
        <para>
	  Please note that the recent upstreamed security policy of SELinux
	  contains a set of rules for SE-PostgreSQL, so we are not always 
	  necessary to build security policy module.
	</para>
	<para>
	  However, SE-PostgreSQL also provides an optinal policy module
	  for development purpose. It allows users a few sets of operations,
	  such as regression test and toggle audit logs.
	</para>
	<para>
	  It is stored in
	  <filename>src/backend/security/sepgsql/policy</filename>,
	  and can be also build and installed as a binary security policy
	  module.
	</para>
      </sect3>

      <sect3>
	<title>Installation</title>
	<para>
	  Please note that SELinux requires installed files, directories and
	  others should be labeled properly. RPM installation do it implicitly.

	  But, when you install PostgreSQL from a tarball, you should assign
	  proper security context for them. The development policy module
	  has a list that shows what security context should be assigned to
	  what files, and will help you to manage them, so we recommend to
	  install the <filename>sepostgresql-devel.pp</filename> also.
	</para>
<screen>
<prompt># </prompt><userinput>make install</userinput>
<prompt># </prompt><userinput>/usr/sbin/semodule -i src/backend/security/sepgsql/policy/sepostgresql-devel.pp</userinput>
<prompt># </prompt><userinput>/sbin/restorecon -R /usr/local/pgsql</userinput>
</screen>
        <para>
	  <command>semodule</command> is a command to install and uninstall
	  a security policy module. <command>restorecon</command> is a command
	  to assign given directories its default security context recursively.
	</para>

	<para>
	  As we note later, all the files and directories to store database
	  cluster should be labeled as <literal>postgresql_db_t</literal>.
	  The default security policy assumes it is constructed at
	  <filename>/var/lib/pgsql/data</filename> as RPM doing.

	  If you want to set up it on another directory, you need to label
	  it by hand.
	</para>
<screen>
<prompt># </prompt><userinput>mkdir -p $PGDATA</userinput>
<prompt># </prompt><userinput>chcon -t postgresql_db_t -R $PGDATA</userinput>
</screen>
        <para>
	  Then, we need to run <command>initdb</command> to initialize
	  the database cluster. It is necessary to specify an option of
	  <option>--enable-selinux</option> which enables to initialize
	  database cluster with proper security context.

	  Please note that SE-PostgreSQL is not activated in the defaul,
	  without this option.
	</para>
<screen>
<prompt>$ </prompt><userinput>initdb --enable-selinux</userinput>
<prompt>$ </prompt><userinput>pg_ctl start</userinput>
</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Backup and Restore</title>
      <para>
	When we restore a database from backups, we have to restore
	its security context correctly as GRANT statement doing on
	the restored table.
      </para>

      <para>
	The <command>pg_dump</command> and <command>pg_dumpall</command>
	have <option>--security-label</option> option to dump databases
	with its security context.

	The dumped image can be restored with proper security context.
      </para>

      <para>
	Needless to say, a process which invokes <command>pg_dump</command>
	must be allowed to refer whole of the database,
	because SE-PostgreSQL filters all inaccessible tuples from the result
	set, or aborts query execution if it references inaccessible
	columns, tables, or functions.

	These requirements are same when we restore the image.
	A process which invokes <command>pg_restore</command> has to have
	enough permission to create/insert these objects with the specified
	security context.
      </para>
<screen>
<prompt>$ </prompt><userinput>pg_dump --security-label postgres</userinput>
	:
      (snip)
	:
--
-- Name: drink; Type: TABLE; Schema: public; Owner: kaigai; Tablespace:
--

CREATE TABLE drink (
    id integer NOT NULL,
    name character varying(48),
    price integer
) SECURITY_LABEL = 'system_u:object_r:sepgsql_table_t';
	:
</screen>
      <para>
	This example shows a backup image with explicitly specified security
	context on tables and tuples.

	If a column has different security context from that of the table, it
	must be specified explicitly in the <command>CREATE TABLE</command>
	statement.
      </para>
    </sect2>
  </sect1>

  <sect1 id="sepostgresql-policy">
    <title>Making a Security Policy Module</title>
    <para>
      This section introduces the way to make your own security policy
      modules, and steps to install them, using a simple example.
    </para>
    <para>
      At first, check whether the toolchain for SELinux security policy.
      We need <command>checkmodule</command> and <command>semodule</command>
      command installed correctly, and pre-defined policy templates which
      is installed at <filename>/usr/share/selinux/devel</filename> in
      generally.

      In Fedora/RedHat, these are provided by
      <literal>policycoreutils</literal>, <literal>checkpolicy</literal>
      and <literal>selinux-policy</literal> package.
    </para>
    <para>
      Then, we begin to write a security policy.
      The source file of security policy is named as
      <filename>(policy module name).te</filename> conventionally.
      Here we defines two types of tables and functions for administrative
      domain's private use. See the following example:
<programlisting>
policy_module(testpolicy,1.0.1)

gen_require(`
    class db_table all_db_table_perms;
    class db_procedure all_db_procedure_perms;
    class db_column all_db_column_perms;
    class db_tuple all_db_tuple_perms;

    # externally defined administrative domain
    attribute sepgsql_unconfined_type;
')

# We defines two types for tables/functions
type admin_sepgsql_table_t;
postgresql_table_object(admin_sepgsql_table_t)

type admin_sepgsql_proc_t;
postgresql_procedure_object(admin_sepgsql_proc_t)

# It allows only administrative domains
allow sepgsql_unconfined_type admin_sepgsql_table_t : db_table *;
allow sepgsql_unconfined_type admin_sepgsql_table_t : db_column *;
allow sepgsql_unconfined_type admin_sepgsql_table_t : db_tuple *;

allow sepgsql_unconfined_type admin_sepgsql_proc_t :
   db_procedure { relabelfrom relabelto create drop getattr setattr execute };
</programlisting>      
    </para>
    <para>
      The <literal>policy_module</literal> at the head is a macro to
      declare the name of security policy module and its version.
      Its name is also used as a basename of sourcefile conventionally.
      In this case, <filename>testpolicy.te</filename> is a proper name.
    </para>
    <para>
      Then, we put <literal>gen_require</literal> block.
      It is necessary to declare all the external dependency.
      This example requires related object classes/permissions and
      externally defined administrative domain types.

      In the standard policy, the attribute of
      <literal>sepgsql_unconfined_type</literal> has same meaning with
      administrative domains on SE-PostgreSQL.
      Most distributions assigns <literal>unconfined_t</literal> domain
      for the default login shell, it is also contained as administrative
      domain.
    </para>
    <para>
      Next, we declare two types.
      The one is <literal>admin_sepgsql_table_t</literal> for administrative
      domain's private tables,
      the other is <literal>admin_sepgsql_proc_t</literal> for procedures in
      similar purpose.

      The suffix of <literal>_t</literal> is attached to identifiers of
      types/domains conventionally, but not a grammatical requirement.

      The <literal>postgresql_table_object</literal> and
      <literal>postgresql_procedure_object</literal> are pre-defined
      macros to characterize given types as tables/procedures.
    </para>
    <para>
      At the last, we allows administrative domains some of privileges.
      SELinux adopts white-list-rules, so any actions except for
      rules explicitly allowed ones.

      Please note that we allows administrative domains anything on
      newly defined types, but we don't describe rules for any others.
    </para>
    <para>
      The toolchain provides a makefile to build and pack user defined
      security policy. In generally, it is installed at
      <filename>/usr/share/selinux/devel/Makefile</filename>,
      so we can apply it as follows:
<screen>
<prompt>$ </prompt><userinput>make -f /usr/share/selinux/devel/Makefile</userinput>
Compiling targeted testpolicy module
/usr/bin/checkmodule:  loading policy configuration from tmp/testpolicy.tmp
/usr/bin/checkmodule:  policy configuration loaded
/usr/bin/checkmodule:  writing binary representation (version 8) to tmp/testpolicy.mod
Creating targeted testpolicy.pp policy package
rm tmp/testpolicy.mod.fc tmp/testpolicy.mod
<prompt>$ </prompt><userinput>ls</userinput>
testpolicy.fc  testpolicy.if  testpolicy.pp  testpolicy.te  tmp
</screen>
      Please note that we assume the policy source is named as
      <filename>testpolicy.te</filename> here.
    </para>
    <para>
      The toolchain generates a loadable policy module named as
      <filename>testpolicy.pp</filename>.
      In addition, it implicitly generates <filename>testpolicy.if</filename>
      and <filename>testpolicy.fc</filename>. But its purposes are to define
      pre-defined macros exposed to other policy modules and relationship
      between filesystem object and its default security context, so
      we don't need touch them here.
    </para>
    <para>
      Next, the <filename>testpolicy.pp</filename> should be installed to the
      kernel using <command>semodule</command>.
<screen>
<prompt>$ </prompt><userinput>su</userinput>
Password:
<prompt># </prompt><userinput>semodule -i <filename>testpolicy.pp</filename></userinput>
</screen>
    </para>
    <para>
      You can confirm the security policy module is installed correctly using
      <command>semodule -l</command>.
<screen>
<prompt># </prompt><userinput>semodule -l</userinput>
      :
telnet  1.7.0
testpolicy      1.0.1
tftp    1.9.0
      :
</screen>
    </para>
    <para>
      Then, these new policies got available. <literal>unconfined_t</literal>
      is an administrative domain pre defined, and grouped by
      <literal>sepgsql_unconfined_type</literal>.
      In the following example, <literal>t.b</literal> is labeled as
      <literal>system_u:object_r:admin_sepgsql_table_t:s0</literal> and
      <literal>f(int)</literal> is labeled as
      <literal>system_u:object_r:admin_sepgsql_proc_t</literal>.
      The installed policy module does not allow non-administrative domain's
      to access these objects.
<screen>
postgres=# SELECT sepgsql_getcon();
              sepgsql_getcon
-------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0
(1 row)

postgres=# CREATE TABLE t (a int, b text SECURITY_LABEL = 'system_u:object_r:admin_sepgsql_table_t:s0');
CREATE TABLE
postgres=# SELECT sepgsql_column_getcon('t','b');
          sepgsql_column_getcon
-----------------------------------------
 system_u:object_r:admin_sepgsql_table_t
(1 row)

postgres=# INSERT INTO t VALUES (1, 'aaa'), (2, 'bbb');
INSERT 0 2
postgres=# CREATE FUNCTION f (int) RETURNS int LANGUAGE 'sql'
              SECURITY_LABEL = 'system_u:object_r:admin_sepgsql_proc_t'
              AS 'SELECT $1 + $1';
CREATE FUNCTION
postgres=# SELECT f(5);
 f
----
 10
(1 row)
</screen>
    </para>
    <para>
      The <literal>sepgsql_test_t</literal> is a domain for test purpose.
      It provides a same privileges compared to web servers, included in
      <literal>sepostgresql-devel.pp</literal> module.

      You can run <command>psql</command> under different domain using
      <command>runcon</command>.
<screen>
postgres=# SELECT sepgsql_getcon();
               sepgsql_getcon
---------------------------------------------
 unconfined_u:unconfined_r:sepgsql_test_t:s0
(1 row)

postgres=# SELECT * FROM t;
ERROR:  SELinux: denied { select } scontext=unconfined_u:unconfined_r:sepgsql_test_t tcontext=system_u:object_r:admin_sepgsql_table_t tclass=db_column name=t.b
postgres=# SELECT a FROM t;
 a
---
 1
 2
(2 rows)
postgres=# SELECT f(10) FROM t;
NOTICE:  SELinux: denied { execute } scontext=unconfined_u:unconfined_r:sepgsql_test_t tcontext=system_u:object_r:admin_sepgsql_proc_t tclass=db_procedure name=f
ERROR:  permission denied for function f
postgres=#
</screen>
    </para>
    <para>
      It shows non-administrative domain is not allowed to access a column
      labeled as <literal>system_u:object_r:admin_sepgsql_table_t</literal>
      and to execute a function labeled as
      <literal>system_u:object_r:admin_sepgsql_proc_t</literal>.
    </para>
    <para>
      If you cannot connect server, please check the following items:
      <itemizedlist>
	<listitem>
	  <para>
	    <literal>sepostgresql-devel.pp</literal> has to be installed.
	  </para>
	</listitem>
	<listitem>
          <para>
	    A <literal>allow_user_postgresql_connect</literal> boolean is
	    enabled.
	  </para>
	</listitem>
        <listitem>
	  <para>
	    A <literal>sepgsql_regression_test_mode</literal> boolean is
	    enabled.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The postgresql server process works within
	    <literal>postgresql_t</literal> domain.
	    If not so, do <command>/sbin/restorecon -R</command> on
	    instllation path and restart it.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect1>
</chapter>
