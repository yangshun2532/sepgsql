<appendix id="security">
 <title>Enhanced Security Features</title>

 <abstract>
   <para>
     This chapter introduces enhanced security features built in core
     PostgreSQL and its framework. These feature can provide mandatory
     access controls, fine-grained access controls, integration of security
     policy between operating system and database management system,
     and so on.
   </para>

   <para>
     The current version of PostgreSQL have two of enhanced security
     features. The one is SE-PostgreSQL (Security Enhanced PostgreSQL),
     and the other is Row-level Database ACLs.
     Both of them are implemented on the common security framework named
     as PGACE (PostgreSQL Access Control Extensions). It provides basic
     facilities to manage security attribute of database objects and
     hooks to acquire controls on some of strategic points. It enables
     to implement enhanced security features with minimum impact for
     the core PostgreSQL.
   </para>

   <para>
     SE-PostgreSQL provides additional fine-grained mandatory access
     controls on accesses to database objects via SQL. It makes a
     decision whether the given request come from clients should be
     allowed, or not, in communicating with in-kernel SELinux.

     SELinux holds its security policy which is a set of white listed
     rules, and provides its access control decisions to the kernel
     and userspace object manager.

     The key concept of SE-PostgreSQL is integration of access controls
     between operating system and database management systems.
     It makes and applies its access control decision based on a single
     unified security policy of operating system. It applies the security
     context of peer process as privileges of client, independent from
     database authentication.

     Its providing access controls are not bypassable for any clients
     even if they are privileged database user, so it is called as a
     MAC (Mandatory Access Controls) feature.

     It enables to prevent information leaks and manipulation from
     malicious insider, reduce damages from SQL injection and application
     bugs.
   </para>

   <para>
     The Row-level Database ACLs enables to apply existing DAC
     (Discretionary Access Control) policy in row-level granuality.

     It enables to set permissions for <command>SELECT</command>,
     <command>UPDATE</command> and <command>DELETE</command>.
     This facility filteres violated tuples from the result set,
     and user shows as if these are not exist here.
   </para>

   <para>
     The PGACE security framework allows to host two security
     features simultaneously. The DAC feature is hardcoded
     as Row-level Database ACLs, but MAC feature is selectable
     by users.

     SE-PostgreSQL is a candidate of MAC features, and we need
     to enable it explicitly.
     It need to specify <option>--enable-selinux</option> option
     at <command>configure</command> script,
     and <option>--pgace-feature=selinux</option> at
     <command>initdb</command>.
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make install</userinput>
<prompt>$ </prompt><userinput>initdb --pgace-feature=selinux</userinput>
</screen>

     The Row-level Database ACLs feature is always enabled in
     default build.
   </para>
 </abstract>

 <sect1 id="security-sepgsql-features">
   <title>SE-PostgreSQL Features</title>

   <sect2 id="security-sepgsql-single-unified-security-policy">
     <title>Single unified security policy</title>

     <para>
       We can find out that filesystem and database have similar
       capabilities which enables to store our information assets,
       and have to apply its access controls to keep confidentiality
       and integrity, when it got a request from users.
     </para>
     <para>
       In case of filesystem, user invokes a proper system call
       to access filesystem objects, like <command>write(2)</command>
       invocation for <filename>~/.bashrc</filename>.

       Meanwhile, he can also make a request to database objects
       via SQL queries.
     </para>
     <para>
       Both of filesystem and database have its access control
       feature. The UNIX permission is well known semantics
       with long history, and the database ACLs are also well
       knows based on SQL standards.

       However, unfortunately, they works independently each other,
       so we have a possibility either of subsystem makes inconsistent
       decison, even if they can store same information asset.

       Please note that the differences between filesystem and database
       is the way to store or access our information asset, not a
       differences in confidentiality, values and so on.
     </para>
     <para>
       Now we have SELinux on some of Linux distributions, which can
       be a reliable foundation for comprehensive and integrated
       security.

       SE-PostgreSQL makes its access control decision based on the
       security policy of SELinux, so we can get always consistent
       results in access controls.

       For example, when we store an information labeled as
       <literal>Classified</literal>, it does not allow users without
       proper privileges to refer it independent from whether it is
       stored in filesystem, or database.
     </para>
     <para>
       This characterisct gives us another benefit. The step to make
       decision works independently from the existing access controls
       in databases, so it enables to apply mandatory access control
       policy, even if user is a database superuser.

       It is similar that SELinux restricts privileges of
       <literal>root</literal> user on operating system.
     </para>

     <sect3 id="security-sepgsql-security-context">
       <title>Security Context</title>
       <para>
	 The security policy of SELinux is a set of access controls
	 rules which show who is allowed to do what kind of accesses
	 on what objects.

	 Any rules are described as a relationship of two entities
	 identified by common format called as security context.
       </para>
       <para>
	 The security context is a formatted string independent from
	 sort of objects, like:
	 <synopsis>system_u:object_r:postgresql_db_t:SystemHigh</synopsis>.

	 It is generally assigned to files of database cluster managed
	 by PostgreSQL, however, please note that it does not use any
	 filesystem specific attribute, like path-name.

	 In SELinux, it assigns a security context for any processes,
	 files, sockets and other resources, and makes its decision 
	 based on these security contexts.

	 It typically checks whether the policy has an allowed relationship
	 between a security context of process and the one of resource,
	 or not.
       </para>
       <para>
	 For example, when a process labeled as
	 <literal>system_u:system_r:postgresql_t:s0</literal> tries to
	 write a log message to <filename>/var/log/postgresql.log</filename>
	 labeled as <literal>system_u:object_r:postgresql_log_t:s0</literal>,
	 <literal>write(2)</literal> ystem call is hooked in the kernel and
	 SELinux search its security policy to find out an entry of
	 relationship of the two security contexts.

	 If founded entry allows the process to write it, SELinux does
	 nothing any more. Otherwise, SELinux prevent it.
       </para>

       <para>
	 Any object managers which want a decision come from SELinux
	 (including kernel) should have a capability to manage security
	 context of its objects.

	 For example, most of major filesystems support xattr (Extended
	 Attributes) facilities which allows to store individual security
	 context of files.

	 SE-PostgreSQL also provides a facility to manage security context
	 of database objects. We can import/export them via
	 <literal>security_label</literal> system column.
       </para>
     </sect3>

     <sect3 id="security-sepgsql-client-privileges">
       <title>Client Privileges</title>
       <para>
	 The privileges of client is a significant factor also.

	 Operating system assigns a process its user/group identifiers
	 and security context. These attributes are used in access
	 controls either of DAC and MAC.

	 Database management system also manages privileges of client.
	 It assigns authenticated database roles and applies its
	 access controls based on database ACLs.

	 Please note that here is no relationships between the attributes
	 of processes on operating system and client of databases.
       </para>
       <para>
	 One of the purpose in SE-PostgreSQL is to apply its access controls
	 on database objects, as if client accesses to filesystem objects.

	 It requires we have to apply the security context of client process
	 to make a decision in access controls. It is independently given
	 from the authenticated database roles.

	 Thus, SE-PostgreSQL need to know the security context of the
	 connected client process.
       </para>

       <para>
	 SELinux provides an interesting API named as
	 <literal>getpeercon()</literal>. It enables to obtain a security
	 context of the peer process connected via given socket descriptor.

	 We can see what security context is applied as the security
	 context of client, using <literal>sepgsql_getcon()</literal>
	 on SE-PostgreSQL as follows:
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t:Classified
<prompt>$ </prompt><userinput>psql -q</userinput>
<prompt>postgres=# </prompt><userinput>SELECT sepgsql_getcon();</userinput>
                  sepgsql_getcon
---------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:Classified
(1 row)
</screen>
       </para>

       <para>
	 We don't need any special configuration when we connect to
	 SE-PostgreSQL via UNIX domain socket (local connection).

	 However, when we connect to SE-PostgreSQL via TCP/IP socket
	 (remote connection), it is necessary to set up labeled networking.
	 See <xref linkend="security-sepgsql-labeled-networks"> for more
	   defails.
       </para>
     </sect3>

     <sect3 id="security-sepgsql-mac">
       <title>Mandatory Access Controls</title>
       <para>
	 MAC (Mandatory Access Controls) is a kind of security designs,
	 and has a few significant characteristics compared to DAC
	 (Discreational Access Controls) design, like filesystem
	 permissions, database ACLs and so on.
       </para>
       <para>
	 At first, MAC design requires to apply its access control
	 policy on all the accesses for managed objects without any
	 exception, including <literal>root</literal> and similar
	 concepts.

	 Next, any subject and object have to be identified by security
	 labels, and MAC policy is described as a set of relationship
	 between two labels. The security context of SELinux is a
	 sort of label, but is includes a bit more identifiers than
	 traditional trusted-operating system.

	 Finally, it should not allow resource owners to change its
	 access control rights arbitrarily. DAC design allows us
	 to change them using <command>chmod</command> or
	 <command>GRANT</command>. But security policy restricts
	 them in MAC design.
       </para>
       <para>
	 SELinux is a MAC feature in operating system, so it applies
	 MAC policy for accesses to resources managed by operating
	 system like files, sockets and so on.
       </para>
       <para>
	 SE-PostgreSQL is a symmetric feature in database management
	 system. It also applies MAC policy for accesses to any
	 database objects, managed by database management system
	 as a literal.
       </para>
     </sect3>
   </sect2>

   <sect2 id="security-sepgsql-functionality">
     <title>The functionality of SE-PostgreSQL</title>

     <sect3 id="security-sepgsql-security-label">
       <title>security_label system column</title>
       <para>
	 SE-PostgreSQL enables to import/export security context of
	 tuples via <literal>security_label</literal> system column
	 which is available v8.4, or later.
       </para>
       <para>
	 The following example shows a case when we export security
	 context of tuples and its data via <command>SELECT</command>.
       </para>
<screen>
<prompt>postgres=# </prompt><userinput>SELECT security_label, * FROM drink;</userinput>
                security_label                | id | name  | price
----------------------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t            |  1 | water |   100
 system_u:object_r:sepgsql_table_t            |  2 | coke  |   120
 system_u:object_r:sepgsql_table_t            |  3 | juice |   130
 system_u:object_r:sepgsql_table_t            |  4 | cofee |   180
 system_u:object_r:sepgsql_table_t:Classified |  5 | beer  |   240
 system_u:object_r:sepgsql_table_t:Classified |  6 | sake  |   320
(6 rows)
</screen>
       <para>
	 The security policy has rules to determine what security context
	 should be applied on newly inserted tuples.
	 SE-PostgreSQL assigns a proper security context for them according
	 to the rules in default.
       </para>
       <para>
	 However, we can explicitly specify a security context of a new
	 tuple with <literal>INSERT</literal> statement including
	 <literal>security_label</literal> system column as a target.
       </para>
<screen>
<prompt># </prompt><userinput>INSERT INTO drink (security_label, id, name, price)
     VALUES('system_u:object_r:sepgsql_ro_table_t', 7, 'tea', 130);</userinput>	 
</screen>
       <para>
	 We can also change security context of tuples using
	 <literal>UPDATE</literal> statement, as <literal>INSERT</literal>
	 doing.
       </para>
<screen>
<prompt># </prompt><userinput>UPDATE drink SET security_label = 'system_u:object_r:sepgsql_ro_table_t' WHERE id < 4;</userinput>
</screen>
       <para>
	 No need to say, client has to have privileges to insert or update
	 security context of tuples. If not so, SE-PostgreSQL prevents to
	 change them.
       </para>
       <para>
	 Please note that PostgreSQL uses system catalogs to represent
	 metadata of tables, columns and so on.
	 SE-PostgreSQL considers tuples within these system catalogs
	 show the security context of them.
	 For example, security context of tuples within
	 <literal>pg_class</literal> is considered as the one of table.
       </para>
     </sect3>

     <sect3>
       <title>Access controls in Row-level</title>
       <para>
	 SE-PostgreSQL applies its access controls for each tuple.

	 If client tries to select, update or delete violated tuples,
	 these tuples are filtered from the result set or ignored from
	 the target of updates/deletions, as if they are not exist
	 on the table.
       </para>
       <para>
	 The following example shows the case when two users with different
	 security context tries to <command>SELECT</command> same table
	 with same SQL.
	 A <literal>Classified</literal> user can whole of the table.
	 But <literal>Classified</literal> tuples are invisible from
	 other users.
       </para>
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t:Classified
<prompt>$ </prompt><userinput>psql -q postgres</userinput>
<prompt>postgres=# </prompt><userinput>SELECT security_label, * FROM drink;</userinput>
                security_label                | id | name  | price
----------------------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t            |  1 | water |   100
 system_u:object_r:sepgsql_table_t            |  2 | coke  |   120
 system_u:object_r:sepgsql_table_t            |  3 | juice |   130
 system_u:object_r:sepgsql_table_t            |  4 | cofee |   180
 system_u:object_r:sepgsql_table_t:Classified |  5 | beer  |   240
 system_u:object_r:sepgsql_table_t:Classified |  6 | sake  |   320
(6 rows)
</screen>
       <para>
	 It shows the <literal>Classified</literal> user got 6 tuples
	 with unconditional <command>SELECT</command> on drink table.

	 However, the unclassified (not labeled) user got 4 tuples
	 with same SQL, because of filtering violated tuples.
       </para>
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t
<prompt>$ </prompt><userinput>psql -q postgres</userinput>
<prompt>postgres=# </prompt><userinput>SELECT security_label, * FROM drink;</userinput>
postgres=# SELECT security_label, * FROM drink;
          security_label           | id | name  | price
-----------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t |  1 | water |   100
 system_u:object_r:sepgsql_table_t |  2 | coke  |   120
 system_u:object_r:sepgsql_table_t |  3 | juice |   130
 system_u:object_r:sepgsql_table_t |  4 | cofee |   180
(4 rows)
</screen>
     </sect3>

     <sect3>
       <title>Access controls for other stuffs</title>
       <para>
	 SE-PostgreSQL also enables to set up access permissions on
	 per-column granularity. It walks on the given query trees
	 to pick up all appeared column.
	 If it contains one or more violated columns, SE-PostgreSQL
	 abort query execution and returns an error to users.
	 This behavior is different from tuple-level access controls.
       </para>
       <para>
	 The following example shows a case when we declared
	 <literal>ccredit</literal> column to store credit card numbers
	 as a secret column from unclassified users.
	 The following SQL is declaration of table and initial records.
       </para>
<screen>
CREATE TABLE customer (
    cid     integer primary key,
    cname   varchar(32),
    credit  varchar(32)
        SECURITY_LABEL = 'system_u:object_r:sepgsql_secret_table_t'
);
GRANT ALL ON customer TO PUBLIC;

INSERT INTO customer (cid, cname, credit)
    VALUES ( 10, 'jack', '1111-2222-3333-4444'),
           ( 13, 'adam', '5555-6666-7777-8888'),
           ( 14, 'liza', '9876-5432-1098-7654');
</screen>
       <para>
	 In the first query, he tries to select all columns but SE-PostgreSQL
	 detect accesses on <literal>ccredit</literal> column, then it is aborted
	 with an audit records.
	 In the second query, he tries to select rest of column except
	 for <literal>ccredit</literal> column, then the query is executed
	 correctly, because violated column is not appeared in this query.
       </para>
<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql -q postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: denied { select } \
	scontext=staff_u:staff_r:staff_t \
	tcontext=system_u:object_r:sepgsql_secret_table_t \
	tclass=db_column name=customer.credit
postgres=# SELECT cid, cname FROM customer;
 cid | cname
-----+-------
  10 | jack
  13 | adam
  14 | liza
(3 rows)
</screen>
       <para>
	 SE-PostgreSQL also checks clients' permission to access tables,
	 to invoke funcion and to read/write large objects in same way.

	 If clients does not have enough permissions on these objects,
	 SE-PostgreSQL aborts query execution and raises an error.
       </para>
     </sect3>
   </sect2>

   <sect2>
     <title>The limitation</title>
     <para>
       SE-PostgreSQL dose not care about information leaks via covert channels.
       It is a technical term used in security evaluation, and means a possibility
       of inference to invisible data via illicit flows.
     </para>
     <para>
       It had been originally required at upper B2 class of TCSEC, and evaluated
       products had to declare explicit maximum bandwidth of covert channels.
       It is now inherited to ISO/IEC15408 knows as CC (Common Criteria).
     </para>
     <para>
       If your requirements contains elimination of covert channels, we don't
       recommend to apply SE-PostgreSQL. However, it is generally considered
       as a requirement of extreame condidential military region.
     </para>
     <para>
       An example of covert channels are here.

       When a man tries to update or delete a tuple with primary key refered by
       one or more invisible foreign keys, SE-PostgreSQL prevent the action to
       keep its reference integrity, even if he cannot see the key.

       This error gives him a side-channel information which is an existance
       of invisible foreign key. Such a behavior is called as covert channel.
     </para>
     <para>
       An actual avoidance for the matter is to apply non-natural primary and
       foreign keys. It enables to be impossible he infer any meaningful data.
     </para>
   </sect2>
</sect1>

<sect1 id="security-sepgsql-admin">
   <title>Administration of SE-PostgreSQL</title>

   <sect2>
     <title>Requirements</title>
     <para>
       We need the following packages to build and work SE-PostgreSQL
       correctly. Please confirm them at first.
     </para>

     <itemizedlist>
       <listitem>
	 <para>
	   Linux kernel (2.6.23, or later)
	 </para>
       </listitem>
       <listitem>
	 <para>
	   libselinux and libselinux-devel (2.0.43, or later)
	 </para>
       </listitem>
       <listitem>
	 <para>
	   selinux-policy (3.4.2, or later)
	 </para>
       </listitem>
       <listitem>
	 <para>
	   policycoreutils (2.0.16, or later)
	 </para>
       </listitem>
     </itemizedlist>
   </sect2>

   <sect2>
     <title>Build and Installation</title>
     <para>
       In the default, SE-PostgreSQL feature is disabled on build.
       We have to specify <option>--enable-selinux</option> option
       for configure script. It enables to build your PostgreSQL
       with features to support SELinux.
     </para>

     <para>
<screen>
  <prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
</screen>
     </para>

     <para>
       SE-PostgreSQL requires in-kernel SELinux to provide its security
       policy to make its decision.
       The <literal>selinux-policy-3.4.2</literal> or later contains most
       of rule set for SE-PostgreSQL, so it is not necessary to install
       special policy module any more for generic purpose.
     </para>

     <para>
       SE-PostgreSQL also provides an optional policy set for development
       purpose. It allows several operations like regression test and
       toggling audit logs, and contains default file security context.

       It is stored at <filename>src/backend/security/sepgsql/policy</filename>,
       and can be build and installed as a binary security policy module.
     </para>

     <para>
       We shows the steps to build SE-PostgreSQL and the optional policy
       set for development purpose, as follows:
     </para>
<screen>
  <prompt>$ </prompt><userinput>make</userinput>
  <prompt>$ </prompt><userinput>make -C src/backend/security/sepgsql/policy</userinput>
  <prompt>$ </prompt><userinput>su</userinput>
  <prompt># </prompt><userinput>make install</userinput>
  <prompt># </prompt><userinput>/usr/sbin/semodule -i src/backend/security/sepgsql/policy/sepostgresql-devel.pp</userinput>
</screen>
     <para>
       The second <command>make</command> builds
       the <filename>sepostgresql-devel.pp</filename> policy module.
       It is installed by <command>/usr/sbin/semodule</command>.
     </para>

     <para>
       The in-kernel SELinux requires a security context is assigned
       for each files correctly.

       The security policy also has its proper default file context
       described as a relationship between a security context and
       files identified by pathname of regular expression.

       The <filename>sepostgresql-devel.pp</filename> also contains
       the relationship based on <option>--prefix</option> option at
       <command>configure</command> script.

       Thus, all we should do is to restore a proper security context
       of newly installed files.
     </para>
     <para>
       If you installed your system at <filename>/usr/local/pgsql</filename>,
       the following command enables to restore proper security context
       under the directory.
     </para>
<screen>
  <prompt># </prompt><userinput>/sbin/restorecon -R /usr/local/pgsql</userinput>
</screen>
     <para>
       The <command>/sbin/restorecon</command> is a command to label proper security
       context of given files, and <option>-R</option> specified recursive mode.
     </para>
   </sect2>

   <sect2>
     <title>initdb and startup</title>
     <para>
       The directories to store database cluster should be labeled as
       <literal>postgresql_db_t</literal> type, to pass in-kernel SELinux's
       checks on file accesses.

       The default security policy within distribution assumes it is constructed
       at <literal>/var/lib/pgsql/data</literal> as the RPM default.
     </para>

     <para>
       If you set up it on other directory, the directory should be labeled as
       <literal>postgresql_db_t</literal> to show it and subtrees are used
       as a database cluster.
     </para>
<screen>
  <prompt># </prompt><userinput>chcon -t postgresql_db_t -R $PGDATA</userinput>
</screen>
     <para>
       <literal>chcon</literal> is a command to change security context
       of files directly. If you want to keep the relationship between
       pathname of $PGDATA and the type, using <literal>semanage</literal>
       and <literal>restorecon</literal> is a better solution.
     </para>
<screen>
  <prompt># </prompt><userinput>/usr/sbin/semanage fcontext -a -t postgresql_db_t "$PGDATA(/.*)?"</userinput>
  <prompt># </prompt><userinput>/sbin/restorecon -R $PGDATA</userinput>
</screen>
     <para>
       After <literal>$PGDATA</literal> is labeled correctly,
       <literal>initdb</literal> and <literal>pg_ctl</literal>should be invoked.
<screen>
  <prompt>$ </prompt><userinput>initdb</userinput>
  <prompt>$ </prompt><userinput>pg_ctl start</userinput>
</screen>
     </para>
   </sect2>

   <sect2>
     <title>GUC Parameters</title>

     <sect3>
       <title>sepostgresql</title>
       <para>
	 The <varname>sepostgresql</varname> parameter enables to specify
	 SE-PostgreSQL working mode.
	 It can be specified on <filename>$PGDATA/postgresql.conf</filename>
	 and we need to restart postmaster process to reflect its changing.
       </para>

       <synopsis>
 sepostgresql = [ default | enforcing | permissive | disabled ]
       </synopsis>

       <variablelist>
         <varlistentry>
           <term><literal>default</literal></term>
           <listitem>
             <para>
	       This is the default behavior, when we omit this configuration.
               It always follows the configuration of operating system.
             </para>
           </listitem>
         </varlistentry>

         <varlistentry>
           <term><literal>enforcing</literal></term>
           <listitem>
             <para>
               It always works SE-PostgreSQL in enforcing mode
               which enables to apply mandatory access controls
               on any user's action.

               This mode requires in-kernel SELinux is activated
               in either enforcing or permissive mode.
             </para>
           </listitem>
         </varlistentry>

         <varlistentry>
           <term><literal>permissive</literal></term>
           <listitem>
             <para>
               It always works SE-PostgreSQL in permissive mode
               which enables to evaluate user's action and generate
               audit records, but does not prevent them.

               This mode requires in-kernel SELinux is activated
               in either enforcing or permissive mode.
             </para>
           </listitem>
         </varlistentry>

         <varlistentry>
           <term><literal>disabled</literal></term>
           <listitem>
             <para>
	       It always disables SE-PostgreSQL features.
             </para>
           </listitem>
         </varlistentry>
       </variablelist>
     </sect3>
   </sect2>

   <sect2>
     <title>Backup and Restore</title>
     <para>
       When we restore a database from backups, we have to restore
       its security context correctly as GRANT statement doing on
       the restored table.
     </para>

     <para>
       The <command>pg_dump</command> and <command>pg_dumpall</command>
       have <option>--security-context</option> option to dump databases
       with its security context.

       The dumped image can be restored with proper security context.
     </para>

     <para>
       No need to say, a process which invokes <command>pg_dump</command>
       has to be allowed to refer whole of the database,
       because SE-PostgreSQL filters all violated tuples from the result
       set, or aborts query execution if it contains references violated
       columns and so on.

       These requirements are same when we restore the image.
       A process which invokes <command>pg_restore</command> has to have
       enough permission to create/insert these objects with specified
       security context.
     </para>

<screen>
<prompt>$ </prompt><userinput>pg_dump --security-context postgres</userinput>
	:
      (snip)
	:
--
-- Name: drink; Type: TABLE; Schema: public; Owner: kaigai; Tablespace:
--

CREATE TABLE drink (
    id integer NOT NULL,
    name character varying(48),
    price integer
) SECURITY_CONTEXT = 'unconfined_u:object_r:sepgsql_table_t';
	:
      (snip)
	:
--
-- Data for Name: drink; Type: TABLE DATA; Schema: public; Owner: kaigai
--

COPY drink (security_context, id, name, price) FROM stdin;
unconfined_u:object_r:sepgsql_table_t	1	water	100
unconfined_u:object_r:sepgsql_table_t	2	coke	120
unconfined_u:object_r:sepgsql_table_t	3	juice	130
unconfined_u:object_r:sepgsql_table_t	4	cofee	180
unconfined_u:object_r:sepgsql_table_t:Classified	5	beer	240
unconfined_u:object_r:sepgsql_table_t:Classified	6	sake	320
\.
	:
      (snip)
	:
</screen>
     <para>
       This example shows a backup image with explicitly specified security
       context on tables and tuples.

       If a column has different security context from tables' one, it also
       specified explicitly in the <command>CREATE TABLE</command> statement.
     </para>
   </sect2>

   <sect2 id="security-sepgsql-labeled-networks">
     <title>Labeled Networks</title>
     <para>
       Labeled Networks is an excellent technology.
       It enables to obtain the security context of peer process communicating
       via TCP/IP connection.
     </para>

     <para>
       This technology contains two facilities.
       One is <literal>Labeled IPsec</literal>,
       and the other is <literal>Static Fallbacked Context</literal>.

       This section shows the way to set up both labeled networks
       technology.
     </para>

     <sect3>
       <title>Labeled IPsec</title>
       <para>
	 When we begin to communicate using an encrypted channel
	 with IPsec, <command>racoon</command> which is a key-exchange
	 daemon exchanges encryption keys of both peers.

	 It does not exchange only encryption keys in actually,
	 but the security context of process connecting to is also
	 delivered to the peer side.

	 The delivered security context is cached on the kernel, and
	 it is exported into applications, if it required via
	 <command>getpeercon()</command> API.
       </para>

       <para>
	 This section introduces the steps to set up labeled ipsec.

	 For more detailed information, visit <ulink url="http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/en-US/Security_Guide/s1-vpn-ipsec.html">Red Hat Enterprise Linux 4 - Security Guide</ulink>
       </para>

       <sect4>
	 <title>Example Environment</title>
	 <para>
	   In this introduction, we assume the server host where SE-PostgreSQL
	   works has an IP address of <literal>192.168.1.10</literal> and
	   the client host has IP address of <literal>192.168.1.200</literal>.

	   They are wired to same network, and can communicate each other
	   directly, without any router.
	 </para>

	 <para>
	   The purpose of the following configuration is to obtain
	   the security context of the process working on the client host
	   (<literal>192.168.1.200</literal>) from SE-PostgreSQL daemon
	   working on the server host (<literal>192.168.1.10</literal>), 
	   when a connection is established.
	 </para>
       </sect4>

       <sect4>
	 <title>Adding a SPD entry</title>
	 <para>
	   It is needed to add an SPD (Security Policy Database) entry
	   to indicate applying IPsec on channels between two host.

	   Note that SPD is not a term of SELinux, it is a configuration
	   parameter of IPsec, although it's a bit confusable.
	 </para>

	 <para>
	   This example shows esp/transport mode should be applied on
	   outbounding packets from <literal>192.168.1.10</literal>
	   to <literal>192.168.1.200</literal>, and inbounding packets
	   from <literal>192.168.1.200</literal> to
	   <literal>192.168.1.10</literal>.

<programlisting>
spdadd 192.168.1.10 192.168.1.200 any
-ctx 1 1 "system_u:object_r:ipsec_spd_t:s0"
-P out ipsec
esp/transport//require;

spdadd 192.168.1.200 192.168.1.10 any
-ctx 1 1 "system_u:object_r:ipsec_spd_t:s0"
-P in ipsec
esp/transport//require;
</programlisting>

	   In addition, the second line of each entries enables to
	   turn on security context delivery during key exchanging.
	 </para>

	 <para>
	   You can load the above configuration using
	   <command>setkey</command> command.

	   Save your configuration into a temporary file,
	   and invoke <command>setkey</command> with the file
	   as an argument.
<screen>
<prompt># </prompt><userinput>/sbin/setkey -f &lt;your configuration file&gt;</userinput>
</screen>
	 </para>

	 <para>
	   It is necessary to apply on both server side and client side.

	   Note that you have to invert IP addreses on the client side.
	 </para>
       </sect4>

       <sect4>
	 <title>Racoon configuration</title>
	 <para>
	   In the next, we have to edit a configuration file of
	   <command>racoon</command> to specify encryption algorithm,
	   authentication method and so on.

	   This example uses pre shared key to authenticate the peer
	   host (<literal>192.168.1.200</literal>) for simplification.

	   Note that you have to invert IP addresses on the client side.
	 </para>

	 <para>
	   An additional entry to <filename>/etc/racoon/racoon.conf</filename>.
<programlisting>
remote 192.168.1.200
{
	exchange_mode aggressive, main;
	my_identifier address;
	proposal {
		encryption_algorithm 3des;
		hash_algorithm sha1;
		authentication_method pre_shared_key;
		dh_group 2 ;
	}
}
</programlisting>
	 </para>

	 <para>
	   We have to put a set of key string and IP address of destination
	   in <filename>/etc/racoon/psk.txt</filename>.

	   The key string has also to be same in the client side.
<programlisting>
# file for pre-shared keys used for IKE authentication
# format is: 'identifier' 'key'
# For example:
#
# 10.1.1.1 flibbertigibbet
# www.example.com 12345
# foo@www.example.com micropachycephalosaurus
192.168.1.200	somethingsecrettext
</programlisting>
         </para>
       </sect4>

       <sect4>
	 <title>Restart Racoon</title>
	 <para>
	   Restart racoon daemon in both peers.
	 </para>
<screen>
<prompt># </prompt><userinput>service racoon restart</userinput>
</screen>
       </sect4>
     </sect3>

     <sect3>
       <title>Static Fallbacked Context</title>
       <para>
	 We cannot apply labeled IPsec for any situation.

	 It requires both server and cliets being SElinux'ed and IPsec is
	 available on their communication channel.
       </para>

       <para>
	 SELinux provides an alternative method to identify a security
	 context of peer process inside the <literal>getpeercon()</literal>
	 API, when a connection come from unlabeled networks.

	 This facility is called as static fallbacked context.
	 It enables to return a security context associated with IP address
	 or network interfaces, as if a new connection come from labeled
	 networks.
       </para>

       <para>
	 <command>netlabelctl</command> within <literal>netlabel_tools</literal>
	 package can be used to set up static fallbacked context.
       </para>

       <para>
	 The following example shows a case when we associate a security
	 context with connections come from <literal>192.168.1.0/24</literal>
	 via all network interfaces.
<screen>
<prompt># </prompt><userinput>/sbin/netlabelctl unlbl add default address:192.168.1.0/24 label:user_u:user_r:user_t:s0</userinput>
</screen>
	 The following example shows a case when we associate a security
	 context with connections come from <literal>192.168.2.0/24</literal>
	 via <literal>eth0</literal>.
<screen>
<prompt># </prompt><userinput>/sbin/netlabelctl unlbl add dev:eth0 address:192.168.2.0/24 label:staff_u:staff_r:staff_t:s0:c0</userinput>
</screen>
       </para>
     </sect3>
   </sect2>
 </sect1>

 <sect1 id="security-row-level-acl">
   <title>Row-level Database ACL</title>
   <para>
     This chapter introduces design and implementation of row-level database acl in
     PostgreSQL. It enables us to assign individual acls for each tuples, and works
     as a supplemental facility of existing database acls applied to table, column
     and so on.
   </para>

   <sect2>
     <title>Design</title>
     <para>
       The design of row-level database acl feature is inherited from the existing
       access control mechanism. For example, it is a sort of discretionary access
       control mechanism, so it allows the resource owners to change its access
       control rights, and it does not prevent any actions invoked from database
       superusers.
     </para>
     <para>
       This feature is implemented as a guest of the PGACE Security Framework,
       so we can activate it exclusively for any other enhanced security features
       like SE-PostgreSQL.
     </para>
     <para>
       It works as if there is a filter to drop violated tuples between tables
       and database clients. Per-tuple acl is checked when the executor scans
       target relations, and the feature makes decision whether the fetched
       tuple should be returned, or not.

       We provides four permission for tuples. These are <literal>SELECT</literal>,
       <literal>UPDATE</literal>, <literal>DELETE</literal> and
       <literal>REFERENCES</literal>. Please note that <literal>INSERT</literal>
       permission is not provided, because the target does not exist when it should
       be checked. You have to control insertion of tuples by the table level
       database acls.
     </para>
     <para>
       PostgreSQL implements foreign key constraint as built-in trigger functions,
       and it invokes another query to keep referential integrities.
       It is an exception case of the filtering behavior. If the query tries to
       fetch a violated tuple, it raises an error to abort the current transaction,
       not a simple filter for them.

       It helps referential integrities, but, please note that there is a possibility
       unprivileged client infer existance of one or more invisible tuples.
     </para>
     <para>
       We can confirm or setup the per-tuple acl via <literal>tuple_acl</literal>
       system attribute newly added. We can modify it via <literal>UPDATE</literal>
       statement, and insert a tuple with specified per-tuple acl via
       <literal>INSERT</literal> statement.
     </para>
     <para>
       It assigns a default acl newly inserted tuples. If no special configuration
       here, it allows world to do anything for compatible behavior. However, we
       can specify the default acl using enhanced <command>CREATE TABLE</command>
       or <command>ALTER TABLE</command> statement with <literal>DEFAULT_ACL</literal>
       option.
     </para>
   </sect2>

   <sect2>
     <title>Installation</title>
     <para>
       You have to give a <literal>--enable-row-acl</literal> option to configure
       script, but rest of installation processes are unchanged.
<screen>
<prompt>$ </prompt><userinput>./configure --enable-row-acl</userinput>
<prompt>$ </prompt><userinput>make</userinput>
<prompt>$ </prompt><userinput>su</userinput>
<prompt># </prompt><userinput>make install</userinput>
</screen>
     </para>
     <para>
       Make a new directory to store the database cluster, and change its ownership
       to the server process which you intend it to work.
       Then, kick the <command>initdb</command> and <command>pg_ctl start</command>.
     </para>

     <para>
       It adds a guc parameter to turn on/off the feature.
       The <literal>row_acl_is_enabled</literal> can have a boolean value, and
       it disables the row-level database acl feature when the server process
       is started up with <literal>false</literal> in this guc.

       It does not allow to change the variable in runtime, so you have to
       put an entry on <literal>$PGDATA/postgresql.conf</literal>.
       When omitted, this feature is enabled.
     </para>
   </sect2>

   <sect2>
     <title>Administration</title>
     <sect3>
       <title>Set up per-tuple acls</title>
       <para>
	 The per-tuples acls are configured vid <literal>tuple_acl</literal> system
	 attribute which is writable.
	 We can use the column as an entity of the target list of <literal>UPDATE</literal>,
	 <literal>INSERT</literal> or <literal>COPY FROM</literal> statement.
	 It also provides helpful functions to edit acl strings, like
	 <literal>rowacl_grant()</literal> and so on.
<screen>
<prompt>postgres=# </prompt><userinput>UPDATE drink SET tuple_acl = '{=r/kaigai}' WHERE id in (3,4,5);</userinput>
UPDATE 3
<prompt>postgres=# </prompt><userinput>SELECT tuple_acl, * FROM drink order by id;</userinput>
           tuple_acl            | id | name  | price
--------------------------------+----+-------+-------
 {kaigai=rwd/kaigai}            |  1 | water |   100
 {kaigai=rwd/kaigai}            |  2 | coke  |   120
 {=r/kaigai}                    |  3 | juice |   130
 {=r/kaigai}                    |  4 | cofee |   180
 {=r/kaigai}                    |  5 | beer  |   240
 {kaigai=r/kaigai,ymj=r/kaigai} |  6 | sake  |   320
(6 rows)
</screen>
       </para>

       <para>
	 The client must have ownership of the relation or privileges of database
	 superuser, whenever he tries to update the <literal>tuple_acl</literal>.
	 Please note that the feature considers the owner of table is the owner
	 of tuples stored in, not a person who inserted the tuple.
       </para>

       <para>
	 The <command>CREATE TABLE</command> or <command>ALTER TABLE</command> with
	 <literal>DEFAULT_ACL</literal> option enables to put individual default
	 acl for the table. The default acl is assigned to newly inserted tuples
	 without explicit acls. If no default acl is configured to the table,
	 it assigns a acl which allows anything to world.
       </para>
     </sect3>

     <sect3>
       <title>backup and restore</title>
       <para>
	 The <command>pg_dump</command> and <command>pg_dumpall</command> got a new
	 option of <literal>--row-level-acl</literal>. This option enables to backup
	 the contents of tables with its individual acls.
	 The dumped data can be restored via <command>pg_restore</command>.
       </para>

       <para>
	 Example:
<screen>
<prompt>$ </prompt><userinput>pg_dump --row-level-acl postgres</userinput>
          :
--
-- Name: drink; Type: TABLE; Schema: public; Owner: kaigai; Tablespace:
--

CREATE TABLE drink (
    id integer NOT NULL,
    name character varying(48),
    price integer
) DEFAULT_ACL = 'default={kaigai=rwd/kaigai}';
          :
--
-- Data for Name: t1; Type: TABLE DATA; Schema: public; Owner: kaigai
--

COPY t1 (tuple_acl, id, name, price) FROM stdin;
{kaigai=rwd/kaigai}     1       water   100
{kaigai=rwd/kaigai}     2       coke    120
{kaigai=rwd/kaigai,ymj=r/kaigai}        3       juice   130
{kaigai=rwd/kaigai,ymj=r/kaigai}        4       cofee   180
{kaigai=r/kaigai,ymj=r/kaigai}  5       beer    240
{kaigai=r/kaigai,ymj=r/kaigai}  6       sake    320
{kaigai=r/kaigai}       7       wine    380
{kaigai=r/kaigai}       8       tea     140
\.
          :
</screen>
       </para>
     </sect3>

     <sect3>
       <title>related functions</title>

       <variablelist>
	 <varlistentry>
	   <term><literal>Text rowacl_grant(Oid tableoid, Text tuple_acl, Text users, Text permissions)</literal></term>
	   <listitem>
	     <para>
	       This function compute a new acl string which is a combination of
	       the given acl string and newly granted permissions.
	       We can use the result of the function as a new value of
	       <literal>tuple_acl</literal> to be given.
	     </para>
	     <para>
	       We can enumerate user names and permissions separated by comma.
	       The permissions have to be some of <literal>select</literal>,
	       <literal>update</literal>, <literal>delete</literal>,
	       <literal>references</literal> and <literal>all</literal>.
	       The <literal>all</literal> is extracted to the other four
	       permissions.
	     </para>
	     <para>
<screen>
<prompt>postgres=# </prompt><userinput>SELECT rowacl_grant(tableoid, tuple_acl, 'tak', 'select'), * FROM tbl;</userinput>
               rowacl_grant                | x |  y
-------------------------------------------+---+-----
 {=rwdx/kaigai,ymj=d/kaigai,tak=r/kaigai}  | 1 | aaa
 {=rwdx/kaigai,tak=rw/kaigai,ymj=d/kaigai} | 2 | bbb
 {=rwdx/kaigai,tak=rw/kaigai}              | 3 | ccc
 {=rwdx/kaigai,tak=r/kaigai}               | 4 | ddd
(4 rows)

<prompt>postgres=# </prompt><userinput>UPDATE tbl SET tuple_acl = rowacl_grant(tableoid, tuple_acl, 'tak', 'select') WHERE x in (2,4);</userinput>
UPDATE 2

<prompt>postgres=# </prompt><userinput>SELECT tuple_acl, * FROM tbl;</userinput>
                 tuple_acl                 | x |  y
-------------------------------------------+---+-----
 {=rwdx/kaigai,ymj=d/kaigai}               | 1 | aaa
 {=rwdx/kaigai,tak=rw/kaigai,ymj=d/kaigai} | 2 | bbb
 {=rwdx/kaigai,tak=w/kaigai}               | 3 | ccc
 {=rwdx/kaigai,tak=r/kaigai}               | 4 | ddd
(4 rows)
</screen>
	     </para>
	   </listitem>
	 </varlistentry>

	 <varlistentry>
	   <term><literal>Text rowacl_revoke(Oid tableoid, Text tuple_acl, Text users, Text permissions)</literal></term>
	   <listitem>
	     <para>
	       This function also compute a new acl as a residual of the given acl
	       on subtraction with newly revoked permissions.
	       We can use the result of the function as a new value of
	       <literal>tuple_acl</literal>.
	     </para>
	   </listitem>
	 </varlistentry>

	 <varlistentry>
	   <term><literal>Text rowacl_revoke_cascade(Oid tableoid, Text tuple_acl, Text users, Text permissions)</literal></term>
	   <listitem>
	     <para>
	       This function also compute a new acl as a residual of the given acl
	       on subtraction with newly revoked permissions, as the
	       <literal>rowacl_revoke()</literal> doing.

	       The only difference is this function revokes permission in
	       cascading mode.
	     </para>
	   </listitem>
	 </varlistentry>

       </variablelist>
     </sect3>
   </sect2>

 </sect1>

 <sect1 id="security-pgace-framework">
   <title>PGACE Security Framework</title>
   <para>
     This chapter introduces the design of PGACE (PostgreSQL Access
     Control Extension) Security Framework.

     It enables to add various kind of security subsystems based on
     different access control models and platforms (we call it as
     "the guest") with minimun impact toward core PostgreSQL.
   </para>

   <para>
     PGACE provides two major facilities.
   </para>

   <para>     
     One is a set of security hooks injected into several strategic points
     within core PostgreSQL. The guest can utilize these hooks to invoke
     itself, and make a its decision on the strategic point.

     Any PGACE hooks are declared at
     <filename>src/include/security/pgace.h</filename>, as inline
     functions with short descriptions.

     The guest can extend these hooks to invoke its implementation
     when it is activated.
     Any platform dependency have to be put in the guest implementation,
     because PGACE hooks are declared completely platform independent
     hooks.
   </para>

   <para>
     The other is a facility to manage security attribute of each tuple.
     It enables the guest to make its decision based on a security
     attribute with minimum storage comsumption.

     In the most cases, security attribute has a text representation
     but massive object shares one or several attributes.

     PGACE utilize this characteristic to reduce storage comsumption
     using an alternate key called as security id.

     The security id is an integer value with <literal>sizeof(Oid)</literal>
     width, and can be used to indicate <literal>oid</literal> attribute
     of <structname>pg_security</structname> which hold a text representation.

     PGACE provides utility functions to translate between a security id
     and text representation for internal use.
   </para>

   <sect2>
     <title>Security Hooks</title>

     <para>
       The following hooks is invoked just before insertion of a new tuple.

       When the hooks returns <literal>false</literal> to the caller,
       insertion of a new tuple is skipped. Otherwise, the rest of steps
       are done normally.
<programlisting>
static inline bool
pgaceHeapTupleInsert(Relation rel, HeapTuple tuple,
                     bool is_internal, bool with_returning)
{
#if defined(HAVE_SELINUX)
    if (sepgsqlIsEnabled())
        return sepgsqlHeapTupleInsert(rel, tuple,
                                      is_internal,
                                      with_returning);
#endif
    return true;
}
</programlisting>
     </para>

     <para>
       The author of the security subsystem has to keep the default
       behavior when his module is disabled.

       In this example, SELinux related function is enclosed by
       <literal>#ifdef</literal> block, and invoked only when
       it isactivated. (<function>sepgsqlIsEnabled()</function>
       returns <literal>true</literal> only when SE-PostgreSQL
       is enabled.)
     </para>

     <para>
       If you add a new security subsystem, add a new
       <literal>#ifdef</literal> block to enclose invocation
       code to avoid conflicts.

       The following example shows a case when you add a new security
       subsystem activated witth <literal>HAVE_FOO_SECURITY</literal>.

<programlisting>
static inline bool
pgaceHeapTupleInsert(Relation rel, HeapTuple tuple,
                     bool is_internal, bool with_returning)
{
#if defined(HAVE_SELINUX)
    if (sepgsqlIsEnabled())
        return sepgsqlHeapTupleInsert(rel, tuple,
                                      is_internal,
                                      with_returning);
#elif define(HAVE_FOO_SECURITY)
    if (fooSecurityIsEnabled())
        return fooSecurityHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
#endif
    return true;
}
</programlisting>
     </para>

     <para>
       Note that two or more security subsystem cannot be activated
       in build time (also in run time, no need to say).
       These are mutually exclusive, because we don't provide
       a framework to associate several security attributes
       within a tuple and cannot be shared.
     </para>

     <para>
       Some of hooks are declared as <literal>void</literal> typed
       functions.

       If your security subsystem decide the required is not allowed
       in these hooks, it can generate an error to abort the series
       of steps.
     </para>

   </sect2>

   <sect2>
     <title>Security Attribute Management</title>

     <para>
       Security id of tuples are stored in the padding area of
       <structname>HeapTupleHeader</structname>.

       The guest can get or set the security id of given tuple using
       <function>HeapTupleGetSecurity()</function> and
       <function>HeapTupleSetSecurity()</function> macros.

       When the tuple does not have its security id, it returns
       <literal>InvalidOid</literal> and the guest have to handle it.
     </para>

     <para>
       PGACE provides an internal API to translate between
       security id and text representation.

       The <function>pgaceLookupSecurityLabel()</function> returns
       a text representation for the given security id.

       On the other hand, <function>pgaceLookupSecurityId()</function>
       returns a security id for the given text representation.
       When the given text representation was not found on
       <structname>pg_security</structname>, it insert a new entry
       automatically.

       Thus, the guest subsystem should pay attention not to invoke
       <function>pgaceLookupSecurityId()</function> in read-only
       transaction.
     </para>

     <para>
       A constant of <literal>SECURITY_SYSATTR_NAME</literal> defines
       the name of security system column. It provides a way to expose
       the security attribute of each tuple in text representation.

       The system column has a characteristic, that is writable.

       The security system column is declared as a TEXT type attribute,
       and user can specify the target of <command>UPDATE</command> or
       <command>INSERT</command>.

       PGACE internally translates the specified text representation
       into a security id, and stores it within a new tuple.

       If the guest uses the feature of security attribute,
       it has to be able to handle these translation.
     </para>
   </sect2>
 </sect1>

</appendix>
