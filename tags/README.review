Reviewer's memo for priv-reworks-01-database patch
---------------------------------------------------

This memo introduces unobvious points in this patch to help understand.

This cleanup patch reorganizes the default PG privilege checks deployed
on various kind of core routines into abstracted checker functions.
It will become a set of common entry points for the upcoming security
features in the future. PostgreSQL has various kind of object classes
and it is too large to rework within a single patch/commit. So, this
patch tries to reorganize the inlined default PG checks corresponding
to pg_database object class by the abstracted security checker functions.

For example:
<quote>
*************** CheckMyDatabase(const char *name, bool a
*** 276,292 ****
                    name)));

        /*
!        * Check privilege to connect to the database.  (The am_superuser test
!        * is redundant, but since we have the flag, might as well check it
!        * and save a few cycles.)
         */
!       if (!am_superuser &&
!           pg_database_aclcheck(MyDatabaseId, GetUserId(),
!                                ACL_CONNECT) != ACLCHECK_OK)
!           ereport(FATAL,
!                   (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
!                    errmsg("permission denied for database \"%s\"", name),
!                    errdetail("User does not have CONNECT privilege.")));

        /*
         * Check connection limit for this database.
--- 277,285 ----
                    name)));

        /*
!        * Check privilege to connect to the database.
         */
!       check_database_connect(MyDatabaseId);

        /*
         * Check connection limit for this database.
</quote>

It replaces the inlined pg_database_aclcheck() with ACL_CONNECT by the
invocation of check_database_connect().
The check_database_connect() applies same checks in the function, so this
reworks does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.

In some points, we had to modify the core routines to abstract access control
logics. The following memo introduces these unobvious modifications and so on.

* check_database_create()

When we create a new database, the default PG checks the following privileges.
 - The user has superuser privilege?
  or
 - The user has "rolcreatedb" privilege?
 - The user has membership on the new database owner?
 - If the source is not a template, the user has ownership on the source
   database?
 - If an explicit tablespace in use, the user has CREATE permission on
   the tablespace?

We have to resolve name of the source database and tablespace (if given)
earlier than invocation of the check_database_create(), so this patch moves
the code to lookup the tablespace name ahead, and puts this call after the
get_db_info().

* check_database_alter_tablespace()

This checker function needs both OIDs of database and tablespace, so we had
to put this call after the get_tablespace_oid().

* check_database_getattr()

It is called from the calculate_database_size(). It checks permission to refere
the properties of a certain database, so it was named as _getattr(), rather
than the too specific check_database_calculate_size().






Reviewer's memo for priv-reworks-02-schema patch
-------------------------------------------------

This memo introduces unobvious points in this patch to help understand.

This cleanup patch reorganizes the default PG privilege checks deployed
on various kind of core routines into abstracted checker functions.
It will become a set of common entry points for the upcoming security
features in the future. PostgreSQL has various kind of object classes
and it is too large to rework within a single patch/commit. So, this
patch tries to reorganize the inlined default PG checks corresponding
to pg_namespace object class by the abstracted security checker functions.

For example:
<quote>
*************** LookupExplicitNamespace(const char *nspn
*** 2356,2365 ****
                (errcode(ERRCODE_UNDEFINED_SCHEMA),
                 errmsg("schema \"%s\" does not exist", nspname)));

!   aclresult = pg_namespace_aclcheck(namespaceId, GetUserId(), ACL_USAGE);
!   if (aclresult != ACLCHECK_OK)
!       aclcheck_error(aclresult, ACL_KIND_NAMESPACE,
!                      nspname);

    return namespaceId;
  }
--- 2355,2362 ----
                (errcode(ERRCODE_UNDEFINED_SCHEMA),
                 errmsg("schema \"%s\" does not exist", nspname)));

!   /* Permission checks */
!   check_schema_search(namespaceId, true);

    return namespaceId;
  }
</quote>

It replaces the inlined pg_namespace_aclcheck() with ACL_USAGE by the
invocation of check_schema_search().
The check_schema_search() applies same checks in the function, so this
reworks does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.

In some points, we had to modify the core routines to abstract access control
logics. The following memo introduces these unobvious modifications and so on.

* LookupCreationNamespace()

This function is called from the following three functions:
 - AlterFunctionNamespace()
 - AlterTableNamespace()
 - AlterTypeNamespace()
This patch moves the existing permission checks to the caller, because this
function is a part of properties of table, function and type object, not a
schema object itself. So, it should be checked within the upcoming
check_relation_alter_schema() rather than check_schema_xxx() hook.

For example, it add the following checks in the AlterTableNamespace().
It eventually applies same checks, so no compatibility issue.
<quote>
*************** AlterTableNamespace(RangeVar *relation,
*** 7789,7794 ****
--- 7790,7800 ----
    /* get schema OID and check its permissions */
    nspOid = LookupCreationNamespace(newschema);

+   /* check permissions on schema */
+   aclresult = pg_namespace_aclcheck(nspOid, GetUserId(), ACL_CREATE);
+   if (aclresult != ACLCHECK_OK)
+       aclcheck_error(aclresult, ACL_KIND_NAMESPACE, newschema);
+
    if (oldNspOid == nspOid)
        ereport(ERROR,
                (errcode(ERRCODE_DUPLICATE_TABLE),
</quote>











Reviewer's memo for priv-reworks-03-relation patch
---------------------------------------------------

This memo introduces unobvious points in this patch to help understand.

This cleanup patch reorganizes the default PG privilege checks deployed
on various kind of core routines into abstracted checker functions.
It will become a set of common entry points for the upcoming security
features in the future. PostgreSQL has various kind of object classes
and it is too large to rework within a single patch/commit. So, this
patch tries to reorganize the inlined default PG checks corresponding
to pg_class and pg_attribute object class by the abstracted security
checker functions.

For example:
<quote>
*************** nextval_internal(Oid relid)
*** 464,475 ****
    /* open and AccessShareLock sequence */
    init_sequence(relid, &elm, &seqrel);

!   if (pg_class_aclcheck(elm->relid, GetUserId(), ACL_USAGE) != ACLCHECK_OK &&
!       pg_class_aclcheck(elm->relid, GetUserId(), ACL_UPDATE) != ACLCHECK_OK)
!       ereport(ERROR,
!               (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
!                errmsg("permission denied for sequence %s",
!                       RelationGetRelationName(seqrel))));

    if (elm->last != elm->cached)       /* some numbers were cached */
    {
--- 462,469 ----
    /* open and AccessShareLock sequence */
    init_sequence(relid, &elm, &seqrel);

!   /* Permission checks */
!   check_sequence_next_value(elm->relid);

    if (elm->last != elm->cached)       /* some numbers were cached */
    {
</quote>

It replaces the inlined pg_class_aclcheck() with ACL_USAGE and ACL_UPDATE
by the invocation of check_sequence_next_value().
The check_sequence_next_value() applies same checks in the function, so this
reworks does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.


* ExecRenameStmt

If the target object to be renamed is TABLE, SEQUENCE, VIEW, INDEX, COLUMN
or TRIGGER, the existing code calls CheckRelationOwnership() to check ownership
of the relation, and calls pg_namespace_aclcheck() to check CREATE privilege
on the namespace (if not COLUMN or TRIGGER).

This patch moved this checks to RenameRelation() and replaced by the
check_relation_alter_rename() hook. The ExecRenameStmt() is the only caller
for RenameRelation(), so here is not any other affects.

The renameatt() originally has its permission checks on the relation owning
the attribute to be renamed, to support recursive calls. It means duplicated
checks on the root relation. This patch replaces the pg_class_ownercheck()
by the check_attribute_alter(). The CheckRelationOwnership() also checks
the relation is not a system catalog, but renameatt() originally checks it.
The ExecRenameStmt() is the only caller for renameatt() also, so here is not
any other affects.

This patch also put CheckRelationOwnership() just before renametrig(), because
we don't intend to rework permission checks related to triggers.
But it shall be reworked in the future revision.


* ExecAlterObjectSchemaStmt

This patch removed CheckRelationOwnership() just before AlterTableNamespace(),
and replaced pg_namespace_aclcheck() in the AlterTableNamespace() by the
check_relation_alter_schema() which also checks ownership of the relation and
CREATE permission on the new namespace. It also put verifying it not being
a system catalog that was checked in the CheckRelationOwnerchip().
Also, it is the only code path, so here is not any other affects.

* DoCopy

COPY FROM/TO statement needs to apply identical permission checks with regular
DML statements. So, this patch replaces the existing permission checks by the
check_relation_perms(). It needs to deliver Bitmapset to tell what columns will
be accessed, so it also set up a Bitmapset object, instead of rte->selectedCols
or rte->modifiedCols.

* check_index_create()

When we define a new index, the default PG checks need the following privileges.
 - ownership of the relation to be indexed
 - CREATE privilege on the namespace, if not rebuilding an index
 - CREATE privilege on the tablespace, if not a database default

The relation ownership is checked in the caller of DefineIndex(), except for
bootstraping mode, so this patch replaced these checks by check_relation_alter().
The check_index_create() check rest of the permissions specific to creation
of new indexes.

* check_relation_create()

When we define a new relation, the default PG checks need the following
privileges.
 - CREATE privilege on the namespace
 - CREATE privilege on the tablespace, if not a database default

These checks are moved to the check_relation_create(), and upcoming feature
will want to check permission to create columns, so this hook is deployed
just after set up of TupleDesc.

* ATSimplePermissions()
ALTER TABLE is a multi-functional statement which allows to alter properties
of relation or attribute, and to create/drop attribute.
The default PG checks control these operations with ownership of the relation
to be altered. The existing ATSimplePermissions() applies ownership checks and
a few more sanity checks (appropriate relkind? not a system catalog?), and it
is called by most of ALTER TABLE options.
This patch added 'colName' argument of the function to inform whether the given
ALTER TABLE intends to alter properties of relation or attribute.
And, two exceptions were separated to ATAddColumnPermissions() and
ATDropColumnPermissions() to check privileges to create/drop a certain attribute.
These functions internally calls one of the security checker functions, and they
eventually calls pg_class_ownercheck(), so here is no actual differences.

* ATPrepAddOids()
On AT_AddOids, The ATPrepCmd() conditionally called ATPrepAddOids() when the
target relation does not have "oid" system column. At the top level recursion,
it makes a pseudo ColumnDef object, then it calls ATPrepAddColumn().
This patch moved this condition check after the creation of pseudo ColumnDef
object, because we want to use common routine with AT_AddColumn cases.

* ATPrepSetTableSpace()

This ALTER TABLE option also need to check CREATE permission on the new
tablespace, not only ownership of the relation, so this patch replaced
invocation of ATSimplePermissionsRelationOrIndex() and pg_tablespace_aclcheck()
by the check_relation_alter_tablespace().
It takes OID of the tablespace as an argument, so we have to deploy it
within ATPrepSetTableSpace(). In addition, a few sanity checks were also
copied to ATPrepSetTableSpace().

* ExecCheckRTEPerms()

The bottom half of the ExecCheckRTEPerms() is copied to check_relation_perms().
The way to check permissions is identical with the original implementation.

* standard_ProcessUtility with T_IndexStmt

The CheckRelationOwnership() is replaced by check_relation_alter() with OID of
the relation to be indexed, like ATSimplePermissions().
It also applied sanity checks on system catalogs, this patch also added this
check here.
(If ATSimplePermissions() is not static, we can call it here...)

* RI_Initial_Check

The purpose of this check is to ensure the rest of query does not failed due
to the access violation, so this patch replaced these checks by the
check_relation_perms() with columns to be referenced.
In this case, we cannot raise an error on access violations, so it may return
'false' to tell access violations will happen.




Reviewer's memo for priv-reworks-04-proc patch
-----------------------------------------------

This memo introduces unobvious points in this patch to help understand.

This cleanup patch reorganizes the default PG privilege checks deployed
on various kind of core routines into abstracted checker functions.
It will become a set of common entry points for the upcoming security
features in the future. PostgreSQL has various kind of object classes
and it is too large to rework within a single patch/commit. So, this
patch tries to reorganize the inlined default PG checks corresponding
to pg_proc object class by the abstracted security checker functions.

For example:
<quote>
*** 1067,1078 ****
  init_fcache(Oid foid, FuncExprState *fcache,
            MemoryContext fcacheCxt, bool needDescForSets)
  {
-   AclResult   aclresult;
-
    /* Check permission to call function */
!   aclresult = pg_proc_aclcheck(foid, GetUserId(), ACL_EXECUTE);
!   if (aclresult != ACLCHECK_OK)
!       aclcheck_error(aclresult, ACL_KIND_PROC, get_func_name(foid));

    /*
     * Safety check on nargs.  Under normal circumstances this should never
--- 1067,1074 ----
  init_fcache(Oid foid, FuncExprState *fcache,
            MemoryContext fcacheCxt, bool needDescForSets)
  {
    /* Check permission to call function */
!   check_proc_execute(foid);

    /*
     * Safety check on nargs.  Under normal circumstances this should never
</quote>

It replaces the inlined pg_proc_aclcheck() with ACL_EXECUTE by the invocation
of check_proc_execute().
The check_proc_execute() applies same checks in the function, so this reworks
does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.

* AggregateCreate() and DefineAggregate()

When we define a new aggregate function, the default PG check needs the
following privileges:
 - CREATE permission on the namespace
 - EXECUTE permission on the trans function by the aggregate owner
 - EXECUTE permission on the final function by the aggregate owner
The CREATE permission was checked in the DefineAggregate(), and the rest of
permissions are checked in the lookup_agg_function() from AggregateCreate().

This patch consolidated these checks into check_aggregate_create(),
and remove these inlined checks from above places. It eventually applies
same checks, so here is no compatibility issue.

* ProcedureCreate() and CreateFunction()

This patch replaced the second argument of the function (bool replace) by OID
of the function to be replaced, or InvalidOid if not replaced.
If it found a function to be replaced (same name, rettype and arguments), it
checks ownership of the function here, although any other permission checks
are applied on the caller (CreateFunction).
This patch also moves this check into check_proc_create(), and modified
CreateFunction() to test whether here is a function to be replaced, or not.
If exists, its OID shall be delivered to check_proc_create() and
ProcedureCreate(). Otherwise, InvalidOid shall be given.
The CreateProceduralLanguage() and AggregateCreate() are other caller of this
function, but they never allow function replacement, here is no compatible issue.
The check_proc_create() also consolidated permission checks on the schema
and procedural language.

* AlterFunctionNamespace()

This patch replaced checks on ownership of the function and CREATE permission
on the schema which was moved to the caller on the priv-reworks-02-schema patch.

* ExecInitAgg() and ExecInitWindowAgg()

When we call an aggregate function, it needs to check a few permissions on the
aggregate function itself and trans/final functions.
This patch replaced these checks by the check_aggregate_execute()

In window aggregate function case, the default PG permissions on trans/final
functions are checked in the initialize_peragg() called from ExecInitWindowAgg().
This patch moved these checks to the caller and replaced them by
check_aggregate_execute(), if window aggregate function.

* optimizer/util/clauses.c

It checks whether the given SQL function can be inlined, or not, for optimization.
The check_proc_canbe_inlined() replaced a few condition which disallow to inline
the SQL function.
This checker function returns false, if lack of EXECUTE permission or the function
is declared as security definer function.




