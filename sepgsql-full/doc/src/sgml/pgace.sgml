<chapter id="pgace-security-framework">
  <title>PGACE Security Framework</title>

  <para>
    This chapter introduces the design of PGACE (PostgreSQL Access
    Control Extension) security framework.
  </para>
  <para>
    It enables to host various kind of enhanced security features
    based on individual security design, granularity and platforms
    with minimum impact toward the core PostgreSQL implementation.
  </para>
  <para>
    Currently, it hosts two security features.

    The one is Row-level ACLs feature. It is always enabled as an
    enhancement of common database ACLs in row-level granularity,
    as a hardwired DAC (Discretionary Access Control) feature.

    It also allows users to choose a MAC (Mandatory Access Control)
    via a GUC option <literal>pgace_feature</literal> on the startup
    time. Its default is <literal>none</literal>, but currently we
    have <literal>selinux</literal> option as a candidate.
  </para>
  <para>
     PGACE consists of two major facilities.

     The one is a set of security hooks deployed on some of strategic
     points in the core PostgreSQL. It enables to implement new enhanced
     security features with minimum impact to the core code.
     The other is facilities to manage security attribute which can be
     used to make a decision in access controls.
  </para>

  <sect1 id="pgace-security-hooks">
    <title>PGACE Security Hooks</title>
    <para>
      This section introduces the overview of security hooks and
      the way to invoke your security feature via the hooks.
    </para>
    <para>
      All the security hooks are defined at
      <filename>src/backend/security/pgaceHooks.c</filename>.

      The security hooks are entry point of any enhanced security
      feature chosen by users, so invoked ones can return its
      decision on the given strategic point.
    </para>
    <para>
      For example, the following <literal>pgaceHeapTupleInsert</literal>
      is invoked just before inserting a new tuple into a relation.

      If the hook returns <literal>false</literal> to the caller,
      this insertion will be skipped. Otherwise, rest of steps will be
      done normally.

      The enhanced security feature can make its decision based on the
      given arguments which shows context in the invocation of hook.
      The <literal>rel</literal> and <literal>tuple</literal> show
      the target relation and tuple in this example.
    </para>
<programlisting>
bool
pgaceHeapTupleInsert(Relation rel, HeapTuple tuple,
                     bool is_internal, bool with_returning)
{
    /* A wired DAC check */
    if (!rowaclHeapTupleInsert(rel, tuple,
                               is_internal,
                               with_returning))
        return false;

    switch (pgace_feature)
    {
#ifdef HAVE_SELINUX
    case PGACE_FEATURE_SELINUX:
        if (sepgsqlIsEnabled())
            return sepgsqlHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
        break;
#endif
    default:
        break;
    }
    return true;
}
</programlisting>
    <para>
      This example shows a hard-wired security feature (Row-level ACLs)
      and one or no selectable feature can be invoked on a tuple insertion.

      Is allows users to shoose an enhanced security feature from the
      candidates via <literal>pgace_feature</literal> GUC option.
      An integer variable of <literal>pgace_feature</literal> reflects
      the configuration.
    </para>
    <para>
      In this example, SE-PostgreSQL is an only candidate when the binary
      is compiled with <option>--enable-selinux</option> option.
    </para>
    <para>
      If you add a new security feature, you should add a new case
      branch in the <literal>switch</literal> statement and an option
      to the GUC parameter, for users selection.

      The following example shows a case when someone add a new security
      feature compiled when <literal>HAVE_FOO_SECURITY</literal> is
      defined on build-time.
    </para>
<programlisting>
bool
pgaceHeapTupleInsert(Relation rel, HeapTuple tuple,
                     bool is_internal, bool with_returning)
{
    /* A wired DAC check */
    if (!rowaclHeapTupleInsert(rel, tuple,
                               is_internal,
                               with_returning))
        return false;

    switch (pgace_feature)
    {
#ifdef HAVE_SELINUX
    case PGACE_FEATURE_SELINUX:
        if (sepgsqlIsEnabled())
            return sepgsqlHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
        break;
#endif
#ifdef HAVE_FOO_SECURITY
    case PGACE_FEATURE_FOO_SECURITY:
        return fooSecurityHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
        break;
#endif
    default:
        break;
    }
    return true;
}
</programlisting>
    <para>
      Please note that individual specifications of security hooks are
      described in <filename>src/backend/security/pgaceHooks.c</filename>
      as a source code comment.
      It will help you to understand.

      If a part of given hooks are unnecessary for your security design,
      keep it as is.
    </para>
  </sect1>

  <sect1 id="pgace-security-label">
    <title>Management of Security Label</title>
    <para>
      A security label is a human readable security attribute which can
      be exported/imported via <literal>security_label</literal> system
      column

      PGACE provides a common facility to manage the security label of
      tuples for various kind of security features.
      It enables an enhanced security feature chosen to store and featch
      a security label of tuples, and allows it to make a decision in
      access controls based on the label.
    </para>
    <para>
      It enables us to handle security labels in text form, but they
      are internally handled as an alternative identifier.

      We call it as a <literal>security id</literal>.
      It is an object identifier (oid) of <literal>pg_security</literal>
      system catalog which holds human readable text form of security labels.

      So, we can mutually translate security id and security label via
      <literal>pg_security</literal> system catalog.
    </para>
    <para>
      The <literal>security id</literal> of tuple is stored within the
      padding field of <literal>HeapTupleHeader</literal>, as if oid doing.

      We can fetch it via <literal>HeapTupleGetSecLabel()</literal>
      macro. If <literal>pgaceTupleDescHasSecLabel()</literal> security
      hook returns <literal>true</literal> for the given relation, it
      means a new tuple within the relation should have a field to store
      its <literal>security id</literal>.

      We can set it via <literal>HeapTupleSetSecLabel()</literal> macro.
    </para>
    <para>
      A few utility functions are provided.

      <literal>pgaceLookupSecurityId()</literal> returns a security id
      towards given security label in text format. If it is not on
      <literal>pg_security</literal>, it automatically inserts a new
      entry and returns its security id.

      <literal>pgaceLookupSecurityLabel()</literal> returns a security
      label for the given sid.
      If it is not on <literal>pg_security</literal>, it returns
      <literal>NULL</literal>, so the guest should handle it as a
      something like default or unlabeled.
    </para>
    <para>
      The <literal>security_label</literal> system column allows users
      to input a security label in text format on <command>INSERT</command>,
      <command>UPDATE</command>, <command>COPY</command> and so on.

      The given security label is translated into security id automatically,
      and put on the security field of tuples. If user provides nothing as
      a security label, it is initialized as <literal>InvalidOid</literal>.

      The <literal>pgaceHeapTupleInsert()</literal> or others are invoked
      later, so the enhanced security feature can know whether user gives
      a proper security label or not. If no security label is given, it
      can assign a default security label. If violated security label is
      given, it can raise an error.

      Vice versa, when user refers <literal>security_label</literal>,
      the sid of tuples are automatically translated into text format.
      If the sid is invalid, the enhanced security feature can return
      an alternative string using
      <literal>pgaceUnlabeledSecurityLabel()</literal> hook.
    </para>
    <para>
      The Row-level Database ACLs uses this facility to manage security
      labels to store its ACLs. Tuples have a capability to store both types
      of security ids simultaneously, but enhanced security features should
      not touch the row-level ACLs.
    </para>
  </sect1>
</chapter>
