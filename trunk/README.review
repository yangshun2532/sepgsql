Reviewer's memo for pgace-01-database patch
---------------------------------------------

This memo introduces unobvious points in this patch to help understand.

The ACE framework provides a set of common entry points for various kind
of upcoming security providers, not only the default PG checks.
At this moment, the default PG checks is the only security provider, so
this patch tries to reorganize the inlined these checks related to
pg_database object class by the abstracted security hook invocations.

For example:
<quote>
*************** CheckMyDatabase(const char *name, bool a
*** 276,292 ****
                    name)));

        /*
!        * Check privilege to connect to the database.  (The am_superuser test
!        * is redundant, but since we have the flag, might as well check it
!        * and save a few cycles.)
         */
!       if (!am_superuser &&
!           pg_database_aclcheck(MyDatabaseId, GetUserId(),
!                                ACL_CONNECT) != ACLCHECK_OK)
!           ereport(FATAL,
!                   (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
!                    errmsg("permission denied for database \"%s\"", name),
!                    errdetail("User does not have CONNECT privilege.")));

        /*
         * Check connection limit for this database.
--- 277,285 ----
                    name)));

        /*
!        * Check privilege to connect to the database.
         */
!       check_database_connect(MyDatabaseId);

        /*
         * Check connection limit for this database.
</quote>

It replaces the inlined pg_database_aclcheck() with ACL_CONNECT by the
invocation of check_database_connect().
The check_database_connect() applies same checks in the function, so this
reworks does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.

In some points, we had to modify the core routines to abstract access control
logics. The following memo introduces these unobvious modifications and so on.

* check_database_create() hook

When we create a new database, the default PG checks the following privileges.
 - The user has superuser privilege?
  or
 - The user has "rolcreatedb" privilege?
 - The user has membership on the new database owner?
 - If the source is not a template, the user has ownership on the source
   database?
 - If an explicit tablespace in use, the user has CREATE permission on
   the tablespace?

We have to resolve name of the source database and tablespace (if given)
earlier than invocation of the check_database_create() hook, so this patch
moves the code to lookup the tablespace name ahead, and puts this call after
the get_db_info().

* check_database_alter_tablespace()

This hook needs both OIDs of database and tablespace, so we had to put this
call after the get_tablespace_oid().

* check_database_getattr()

It is called from the calculate_database_size(). It checks permission to refere
the properties of a certain database, so it was named as _getattr(), rather
than the too specific check_database_calculate_size().






Reviewer's memo for pgace-02-schema patch
------------------------------------------

This memo introduces unobvious points in this patch to help understand.

The ACE framework provides a set of common entry points for various kind
of upcoming security providers, not only the default PG checks.
At this moment, the default PG checks is the only security provider, so
this patch tries to reorganize the inlined these checks related to
pg_namespace object class by the abstracted security hook invocations.

For example:
<quote>
*************** LookupExplicitNamespace(const char *nspn
*** 2356,2365 ****
                (errcode(ERRCODE_UNDEFINED_SCHEMA),
                 errmsg("schema \"%s\" does not exist", nspname)));

!   aclresult = pg_namespace_aclcheck(namespaceId, GetUserId(), ACL_USAGE);
!   if (aclresult != ACLCHECK_OK)
!       aclcheck_error(aclresult, ACL_KIND_NAMESPACE,
!                      nspname);

    return namespaceId;
  }
--- 2355,2362 ----
                (errcode(ERRCODE_UNDEFINED_SCHEMA),
                 errmsg("schema \"%s\" does not exist", nspname)));

!   /* Permission checks */
!   check_schema_search(namespaceId, true);

    return namespaceId;
  }
</quote>

It replaces the inlined pg_namespace_aclcheck() with ACL_USAGE by the
invocation of check_schema_search().
The check_schema_search() applies same checks in the function, so this
reworks does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.

In some points, we had to modify the core routines to abstract access control
logics. The following memo introduces these unobvious modifications and so on.

* LookupCreationNamespace()

This function is called from the following three functions:
 - AlterFunctionNamespace()
 - AlterTableNamespace()
 - AlterTypeNamespace()
This patch moves the existing permission checks to the caller, because this
function is a part of properties of table, function and type object, not a
schema object itself. So, it should be checked within the upcoming
check_relation_alter_schema() rather than check_schema_xxx() hook.

For example, it add the following checks in the AlterTableNamespace().
It eventually applies same checks, so no compatibility issue.
<quote>
*************** AlterTableNamespace(RangeVar *relation,
*** 7789,7794 ****
--- 7790,7800 ----
    /* get schema OID and check its permissions */
    nspOid = LookupCreationNamespace(newschema);

+   /* check permissions on schema */
+   aclresult = pg_namespace_aclcheck(nspOid, GetUserId(), ACL_CREATE);
+   if (aclresult != ACLCHECK_OK)
+       aclcheck_error(aclresult, ACL_KIND_NAMESPACE, newschema);
+
    if (oldNspOid == nspOid)
        ereport(ERROR,
                (errcode(ERRCODE_DUPLICATE_TABLE),
</quote>











Reviewer's memo for pgace-03-relation patch
--------------------------------------------

This memo introduces unobvious points in this patch to help understand.

The ACE framework provides a set of common entry points for various kind
of upcoming security providers, not only the default PG checks.
At this moment, the default PG checks is the only security provider, so
this patch tries to reorganize the inlined these checks related to
pg_class and pg_attribute object class by the abstracted security hook
invocations.

For example:
<quote>
*************** nextval_internal(Oid relid)
*** 464,475 ****
    /* open and AccessShareLock sequence */
    init_sequence(relid, &elm, &seqrel);

!   if (pg_class_aclcheck(elm->relid, GetUserId(), ACL_USAGE) != ACLCHECK_OK &&
!       pg_class_aclcheck(elm->relid, GetUserId(), ACL_UPDATE) != ACLCHECK_OK)
!       ereport(ERROR,
!               (errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),
!                errmsg("permission denied for sequence %s",
!                       RelationGetRelationName(seqrel))));

    if (elm->last != elm->cached)       /* some numbers were cached */
    {
--- 462,469 ----
    /* open and AccessShareLock sequence */
    init_sequence(relid, &elm, &seqrel);

!   /* Permission checks */
!   check_sequence_next_value(elm->relid);

    if (elm->last != elm->cached)       /* some numbers were cached */
    {
</quote>

It replaces the inlined pg_class_aclcheck() with ACL_USAGE and ACL_UPDATE
by the invocation of check_sequence_next_value().
The check_sequence_next_value() applies same checks in the function, so this
reworks does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.


* ExecRenameStmt

If the target object to be renamed is TABLE, SEQUENCE, VIEW, INDEX, COLUMN
or TRIGGER, the existing code calls CheckRelationOwnership() to check ownership
of the relation, and calls pg_namespace_aclcheck() to check CREATE privilege
on the namespace (if not COLUMN or TRIGGER).

This patch moved this checks to RenameRelation() and replaced by the
check_relation_alter_rename() hook. The ExecRenameStmt() is the only caller
for RenameRelation(), so here is not any other affects.

The renameatt() originally has its permission checks on the relation owning
the attribute to be renamed, to support recursive calls. It means duplicated
checks on the root relation. This patch replaces the pg_class_ownercheck()
by the check_attribute_alter(). The CheckRelationOwnership() also checks
the relation is not a system catalog, but renameatt() originally checks it.
The ExecRenameStmt() is the only caller for renameatt() also, so here is not
any other affects.

This patch also put CheckRelationOwnership() just before renametrig(), because
we don't intend to rework permission checks related to triggers.


* ExecAlterObjectSchemaStmt

This patch removed CheckRelationOwnership() just before AlterTableNamespace(),
and replaced pg_namespace_aclcheck() in the AlterTableNamespace() by the
check_relation_alter_schema() which also checks ownership of the relation and
CREATE permission on the new namespace. It also put verifying it not being
a system catalog that was checked in the CheckRelationOwnerchip().
Also, it is the only code path, so here is not any other affects.

* DoCopy

COPY FROM/TO statement needs to apply identical permission checks with regular
DML statements. So, this patch replaces the existing permission checks by the
check_relation_perms(). It needs to deliver Bitmapset to tell what columns will
be accessed, so it also set up a Bitmapset object, instead of rte->selectedCols
or rte->modifiedCols.

* check_index_create()

When we define a new index, the default PG checks need the following privileges.
 - ownership of the relation to be indexed
 - CREATE privilege on the namespace, if not rebuilding an index
 - CREATE privilege on the tablespace, if not a database default

The relation ownership is checked in the caller of DefineIndex(), except for
bootstraping mode, so this patch replaced these checks by check_relation_alter().
The check_index_create() check rest of the permissions.

* check_relation_create()

When we define a new relation, the default PG checks need the following
privileges.
 - CREATE privilege on the namespace
 - CREATE privilege on the tablespace, if not a database default

These checks are moved to the check_relation_create(), and upcoming feature
will want to check permission to create columns, so this hook is deployed
just after set up of TupleDesc.

* ATSimplePermissions()

There are two main types of ALTER TABLE options which alter properties of
relation or attribute. The existing ATSimplePermissions() checks ownership
of the relation to be altered, and called to most of ALTER TABLE options.
These are eventually same things in the default PG checks. But upcoming
feature will want to distinguish an attribute from a relation, so this
patch add 'colName' argument to ATSimplePermissions() to show what column
to be altered. If NULL, it means altering properties of the relation,
then check_relaion_alter() shall be called. Otherwise, check_attribute_alter()
shall be called.
Both of them internally call pg_class_ownercheck(), so here is no difference.

* ATPrepAddColumn() and ATPrepDropColumn()

This patch modified ATSimplePermissions() to take argument of colName.
It works as a switch to call either of check_relation_alter() or
check_attribute_alter(). However, we want to call check_attribute_create()
for AT_AddColumn, and check_attribute_drop() for AT_DropColumn.
So, I added permission checks in ATPrepAddColumn() and new ATPrepDropColumn()
instead of the ATSimplePermissions(). Here is no actual differences.

* ATPrepSetTableSpace()

The default PG check needs CREATE permission on the new tablespace, not only
ownership of the relation, so we want to use check_relation_alter_tablespace()
instead of the check_relation_alter() called in the ATSimplePermissions().
This patch replaces ATSimplePermissions() and pg_tablespace_aclcheck() on
AT_SetTableSpace option by the check_relation_alter_tablespace().
So, it also needed to put sanity checks on relkind and system catalog here.

* ExecCheckRTEPerms()

The bottom half of the ExecCheckRTEPerms() is copied to check_relation_perms().
The way to check permissions is identical with the original implementation.

* standard_ProcessUtility with T_IndexStmt

The CheckRelationOwnership() is replaced by check_relation_alter() with OID of
the relation to be indexed, like ATSimplePermissions().
It also applied sanity checks on system catalogs, this patch also added this
check here.
(If ATSimplePermissions() is not static, we can call here...)


* RI_Initial_Check

The purpose of this check is to ensure the rest of query does not failed due
to the access violation, so this patch replaced these checks by the
check_relation_perms() with columns to be referenced.
In this case, we cannot raise an error on access violations, so it may return
'false' to tell access violations will happen.




Reviewer's memo for pgace-04-proc.patch
----------------------------------------

This memo introduces unobvious points in this patch to help understand.

The ACE framework provides a set of common entry points for various kind
of upcoming security providers, not only the default PG checks.
At this moment, the default PG checks is the only security provider, so
this patch tries to reorganize the inlined these checks related to
pg_proc object class by the abstracted security hook invocations.

For example:
<quote>
*** 1067,1078 ****
  init_fcache(Oid foid, FuncExprState *fcache,
            MemoryContext fcacheCxt, bool needDescForSets)
  {
-   AclResult   aclresult;
-
    /* Check permission to call function */
!   aclresult = pg_proc_aclcheck(foid, GetUserId(), ACL_EXECUTE);
!   if (aclresult != ACLCHECK_OK)
!       aclcheck_error(aclresult, ACL_KIND_PROC, get_func_name(foid));

    /*
     * Safety check on nargs.  Under normal circumstances this should never
--- 1067,1074 ----
  init_fcache(Oid foid, FuncExprState *fcache,
            MemoryContext fcacheCxt, bool needDescForSets)
  {
    /* Check permission to call function */
!   check_proc_execute(foid);

    /*
     * Safety check on nargs.  Under normal circumstances this should never
</quote>

It replaces the inlined pg_proc_aclcheck() with ACL_EXECUTE by the invocation
of check_proc_execute().
The check_proc_execute() applies same checks in the function, so this reworks
does not have any compatibility issue.

We omitted introductions about such kind of obvious replacements in this memo.

* AggregateCreate() and DefineAggregate()

When we define a new aggregate function, the default PG check needs the
following privileges:
 - CREATE permission on the namespace
 - EXECUTE permission on the trans function by the aggregate owner
 - EXECUTE permission on the final function by the aggregate owner
The CREATE permission was checked in the DefineAggregate(), and the rest of
permissions are checked in the lookup_agg_function() from AggregateCreate().

This patch consolidated these checks into check_aggregate_create() hook,
and remove these inlined checks from above places. It eventually applies
same checks, so here is no compatibility issue.

* ProcedureCreate() and CreateFunction()

This patch replaced the second argument of the function (bool replace) by OID
of the function to be replaced, or InvalidOid if not replaced.
If it found a function to be replaced (same name, rettype and arguments), it
checks ownership of the function here, although any other permission checks
are applied on the caller (CreateFunction).
This patch also moves this check into check_proc_create(), and modified
CreateFunction() to test whether here is a function to be replaced, or not.
If exists, its OID shall be delivered to check_proc_create() and
ProcedureCreate(). Otherwise, InvalidOid shall be given.
The CreateProceduralLanguage() and AggregateCreate() are other caller of this
function, but they never allow function replacement, here is no compatible issue.
The check_proc_create() also consolidated permission checks on the schema
and procedural language.

* AlterFunctionNamespace()

This patch replaced checks on ownership of the function and CREATE permission
on the schema which was moved to the caller on the pgace-02-schema patch.

* ExecInitAgg() and ExecInitWindowAgg()

When we call an aggregate function, it needs to check a few permissions on the
aggregate function itself and trans/final functions.
This patch replaced these checks by the check_aggregate_execute()

In window aggregate function case, the default PG permissions on trans/final
functions are checked in the initialize_peragg() called from ExecInitWindowAgg().
This patch moved these checks to the caller and replaced them by
check_aggregate_execute(), if window aggregate function.

* optimizer/util/clauses.c

It checks whether the given SQL function can be inlined, or not, for optimization.
The check_proc_canbe_inlined() replaced a few condition which disallow to inline
the SQL function.
This hook returns false, if lack of EXECUTE permission or the function is declared
as security definer function.




