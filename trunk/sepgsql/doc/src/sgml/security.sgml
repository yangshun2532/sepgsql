<appendix id="security">
 <title>Enhanced Security Features</title>

 <abstract>
   <para>
     This chapter introduces enhanced security features built in core
     PostgreSQL and its framework. These feature can provide mandatory
     access controls, fine-grained access controls, integration of security
     policy between operating system and database management system,
     and so on.
   </para>

   <para>
     The current version of PostgreSQL have two of enhanced security
     features. The one is SE-PostgreSQL (Security Enhanced PostgreSQL),
     and the other is Row-level Database ACLs.
     Both of them are implemented on the common security framework named
     as PGACE (PostgreSQL Access Control Extensions). It provides basic
     facilities to manage security attribute of database objects and
     hooks to acquire controls on some of strategic points. It enables
     to implement enhanced security features with minimum impact for
     the core PostgreSQL.
   </para>

   <para>
     SE-PostgreSQL provides additional fine-grained mandatory access
     controls on accesses to database objects via SQL. It makes a
     decision whether the given request come from clients should be
     allowed, or not, in communicating with in-kernel SELinux.

     SELinux holds its security policy which is a set of white listed
     rules, and provides its access control decisions to the kernel
     and userspace object manager.

     The key concept of SE-PostgreSQL is integration of access controls
     between operating system and database management systems.
     It makes and applies its access control decision based on a single
     unified security policy of operating system. It applies the security
     context of peer process as privileges of client, independent from
     database authentication.

     Its providing access controls are not bypassable for any clients
     even if they are privileged database user, so it is called as a
     MAC (Mandatory Access Controls) feature.

     It enables to prevent information leaks and manipulation from
     malicious insider, reduce damages from SQL injection and application
     bugs.
   </para>

   <para>
     The Row-level Database ACLs enables to apply existing DAC
     (Discretionary Access Control) policy in row-level granuality.

     It enables to set permissions for <command>SELECT</command>,
     <command>UPDATE</command> and <command>DELETE</command>.
     This facility filteres violated tuples from the result set,
     and user shows as if these are not exist here.
   </para>

   <para>
     The PGACE security framework allows to host two security
     features simultaneously. The DAC feature is hardcoded
     as Row-level Database ACLs, but MAC feature is selectable
     by users.

     SE-PostgreSQL is a candidate of MAC features, and we need
     to enable it explicitly.
     It need to specify <option>--enable-selinux</option> option
     at <command>configure</command> script,
     and <option>--pgace-feature=selinux</option> at
     <command>initdb</command>.
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make install</userinput>
<prompt>$ </prompt><userinput>initdb --pgace-feature=selinux</userinput>
</screen>

     The Row-level Database ACLs feature is always enabled in
     default build.
   </para>
 </abstract>

 <sect1 id="security-sepgsql-features">
   <title>SE-PostgreSQL Features</title>

   <sect2 id="security-sepgsql-single-unified-security-policy">
     <title>Single unified security policy</title>

     <para>
       We can find out that filesystem and database have similar
       capabilities which enables to store our information assets,
       and have to apply its access controls to keep confidentiality
       and integrity, when it got a request from users.
     </para>
     <para>
       In case of filesystem, user invokes a proper system call
       to access filesystem objects, like <command>write(2)</command>
       invocation for <filename>~/.bashrc</filename>.

       Meanwhile, he can also make a request to database objects
       via SQL queries.
     </para>
     <para>
       Both of filesystem and database have its access control
       feature. The UNIX permission is well known semantics
       with long history, and the database ACLs are also well
       knows based on SQL standards.

       However, unfortunately, they works independently each other,
       so we have a possibility either of subsystem makes inconsistent
       decison, even if they can store same information asset.

       Please note that the differences between filesystem and database
       is the way to store or access our information asset, not a
       differences in confidentiality, values and so on.
     </para>
     <para>
       Now we have SELinux on some of Linux distributions, which can
       be a reliable foundation for comprehensive and integrated
       security.

       SE-PostgreSQL makes its access control decision based on the
       security policy of SELinux, so we can get always consistent
       results in access controls.

       For example, when we store an information labeled as
       <literal>Classified</literal>, it does not allow users without
       proper privileges to refer it independent from whether it is
       stored in filesystem, or database.
     </para>
     <para>
       This characterisct gives us another benefit. The step to make
       decision works independently from the existing access controls
       in databases, so it enables to apply mandatory access control
       policy, even if user is a database superuser.

       It is similar that SELinux restricts privileges of
       <literal>root</literal> user on operating system.
     </para>

     <sect3 id="security-sepgsql-security-context">
       <title>Security Context</title>
       <para>
	 The security policy of SELinux is a set of access controls
	 rules which show who is allowed to do what kind of accesses
	 on what objects.

	 Any rules are described as a relationship of two entities
	 identified by common format called as security context.
       </para>
       <para>
	 The security context is a formatted string independent from
	 sort of objects, like:
	 <synopsis>system_u:object_r:postgresql_db_t:SystemHigh</synopsis>.

	 It is generally assigned to files of database cluster managed
	 by PostgreSQL, however, please note that it does not use any
	 filesystem specific attribute, like path-name.

	 In SELinux, it assigns a security context for any processes,
	 files, sockets and other resources, and makes its decision 
	 based on these security contexts.

	 It typically checks whether the policy has an allowed relationship
	 between a security context of process and the one of resource,
	 or not.
       </para>
       <para>
	 For example, when a process labeled as
	 <literal>system_u:system_r:postgresql_t:s0</literal> tries to
	 write a log message to <filename>/var/log/postgresql.log</filename>
	 labeled as <literal>system_u:object_r:postgresql_log_t:s0</literal>,
	 <literal>write(2)</literal> ystem call is hooked in the kernel and
	 SELinux search its security policy to find out an entry of
	 relationship of the two security contexts.

	 If founded entry allows the process to write it, SELinux does
	 nothing any more. Otherwise, SELinux prevent it.
       </para>

       <para>
	 Any object managers which want a decision come from SELinux
	 (including kernel) should have a capability to manage security
	 context of its objects.

	 For example, most of major filesystems support xattr (Extended
	 Attributes) facilities which allows to store individual security
	 context of files.

	 SE-PostgreSQL also provides a facility to manage security context
	 of database objects. We can import/export them via
	 <literal>security_label</literal> system column.
       </para>
     </sect3>

     <sect3 id="security-sepgsql-client-privileges">
       <title>Client Privileges</title>
       <para>
	 The privileges of client is a significant factor also.

	 Operating system assigns a process its user/group identifiers
	 and security context. These attributes are used in access
	 controls either of DAC and MAC.

	 Database management system also manages privileges of client.
	 It assigns authenticated database roles and applies its
	 access controls based on database ACLs.

	 Please note that here is no relationships between the attributes
	 of processes on operating system and client of databases.
       </para>
       <para>
	 One of the purpose in SE-PostgreSQL is to apply its access controls
	 on database objects, as if client accesses to filesystem objects.

	 It requires we have to apply the security context of client process
	 to make a decision in access controls. It is independently given
	 from the authenticated database roles.

	 Thus, SE-PostgreSQL need to know the security context of the
	 connected client process.
       </para>

       <para>
	 SELinux provides an interesting API named as
	 <literal>getpeercon()</literal>. It enables to obtain a security
	 context of the peer process connected via given socket descriptor.

	 We can see what security context is applied as the security
	 context of client, using <literal>sepgsql_getcon()</literal>
	 on SE-PostgreSQL as follows:
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t:Classified
<prompt>$ </prompt><userinput>psql -q</userinput>
<prompt>postgres=# </prompt><userinput>SELECT sepgsql_getcon();</userinput>
                  sepgsql_getcon
---------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:Classified
(1 row)
</screen>
       </para>

       <para>
	 We don't need any special configuration when we connect to
	 SE-PostgreSQL via UNIX domain socket (local connection).

	 However, when we connect to SE-PostgreSQL via TCP/IP socket
	 (remote connection), it is necessary to set up labeled networking.
	 See <xref linkend="security-sepgsql-labeled-networks"> for more
	   defails.
       </para>
     </sect3>

     <sect3 id="security-sepgsql-mac">
       <title>Mandatory Access Controls</title>
       <para>
	 MAC (Mandatory Access Controls) is a kind of security designs,
	 and has a few significant characteristics compared to DAC
	 (Discreational Access Controls) design, like filesystem
	 permissions, database ACLs and so on.
       </para>
       <para>
	 At first, MAC design requires to apply its access control
	 policy on all the accesses for managed objects without any
	 exception, including <literal>root</literal> and similar
	 concepts.

	 Next, any subject and object have to be identified by security
	 labels, and MAC policy is described as a set of relationship
	 between two labels. The security context of SELinux is a
	 sort of label, but is includes a bit more identifiers than
	 traditional trusted-operating system.

	 Finally, it should not allow resource owners to change its
	 access control rights arbitrarily. DAC design allows us
	 to change them using <command>chmod</command> or
	 <command>GRANT</command>. But security policy restricts
	 them in MAC design.
       </para>
       <para>
	 SELinux is a MAC feature in operating system, so it applies
	 MAC policy for accesses to resources managed by operating
	 system like files, sockets and so on.
       </para>
       <para>
	 SE-PostgreSQL is a symmetric feature in database management
	 system. It also applies MAC policy for accesses to any
	 database objects, managed by database management system
	 as a literal.
       </para>
     </sect3>
   </sect2>

   <sect2 id="security-sepgsql-functionality">
     <title>The functionality of SE-PostgreSQL</title>

     <sect3 id="security-sepgsql-security-label">
       <title>security_label system column</title>
       <para>
	 SE-PostgreSQL enables to import/export security context of
	 tuples via <literal>security_label</literal> system column
	 which is available v8.4, or later.
       </para>
       <para>
	 The following example shows a case when we export security
	 context of tuples and its data via <command>SELECT</command>.
       </para>
<screen>
<prompt>postgres=# </prompt><userinput>SELECT security_label, * FROM drink;</userinput>
                security_label                | id | name  | price
----------------------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t            |  1 | water |   100
 system_u:object_r:sepgsql_table_t            |  2 | coke  |   120
 system_u:object_r:sepgsql_table_t            |  3 | juice |   130
 system_u:object_r:sepgsql_table_t            |  4 | cofee |   180
 system_u:object_r:sepgsql_table_t:Classified |  5 | beer  |   240
 system_u:object_r:sepgsql_table_t:Classified |  6 | sake  |   320
(6 rows)
</screen>
       <para>
	 The security policy has rules to determine what security context
	 should be applied on newly inserted tuples.
	 SE-PostgreSQL assigns a proper security context for them according
	 to the rules in default.
       </para>
       <para>
	 However, we can explicitly specify a security context of a new
	 tuple with <literal>INSERT</literal> statement including
	 <literal>security_label</literal> system column as a target.
       </para>
<screen>
<prompt># </prompt><userinput>INSERT INTO drink (security_label, id, name, price)
     VALUES('system_u:object_r:sepgsql_ro_table_t', 7, 'tea', 130);</userinput>	 
</screen>
       <para>
	 We can also change security context of tuples using
	 <literal>UPDATE</literal> statement, as <literal>INSERT</literal>
	 doing.
       </para>
<screen>
<prompt># </prompt><userinput>UPDATE drink SET security_label = 'system_u:object_r:sepgsql_ro_table_t' WHERE id < 4;</userinput>
</screen>
       <para>
	 No need to say, client has to have privileges to insert or update
	 security context of tuples. If not so, SE-PostgreSQL prevents to
	 change them.
       </para>
       <para>
	 <command>SELECT INTO</command> or <command>CREATE TABLE AS</command>
	 including <literal>security_label</literal> system column as a target
	 is considered as an iteration of <literal>INSERT</literal> with an
	 explicit security context.
       </para>
<screen>
<prompt># </prompt><userinput>SELECT security_label, id, name, price / 2 AS price INTO discount FROM drink;</userinput>
SELECT
postgres=# SELECT security_label, * FROM discount;
                security_label                | id | name  | price
----------------------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t            |  1 | water |    50
 system_u:object_r:sepgsql_table_t            |  2 | coke  |    60
 system_u:object_r:sepgsql_table_t            |  3 | juice |    65
 system_u:object_r:sepgsql_table_t            |  4 | cofee |    90
 system_u:object_r:sepgsql_table_t:Classified |  5 | beer  |   120
 system_u:object_r:sepgsql_table_t:Classified |  6 | sake  |   160
(6 rows)
</screen>
       <para>
	 Please note that PostgreSQL uses system catalogs to represent
	 metadata of tables, columns and so on.
	 SE-PostgreSQL considers tuples within these system catalogs
	 show the security context of them.
	 For example, security context of tuples within
	 <literal>pg_class</literal> is considered as the one of table.
       </para>
     </sect3>

     <sect3>
       <title>Access controls on Tuples</title>
       <para>
	 SE-PostgreSQL applies its access controls for each tuple.

	 If client tries to select, update or delete violated tuples,
	 these tuples are filtered from the result set or ignored from
	 the target of updates/deletions, as if they are not exist
	 on the table.
       </para>
       <para>
	 The following example shows the case when two users with different
	 security context tries to <command>SELECT</command> same table
	 with same SQL.
	 A <literal>Classified</literal> user can whole of the table.
	 But <literal>Classified</literal> tuples are invisible from
	 other users.
       </para>
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t:Classified
<prompt>$ </prompt><userinput>psql -q postgres</userinput>
<prompt>postgres=# </prompt><userinput>SELECT security_label, * FROM drink;</userinput>
                security_label                | id | name  | price
----------------------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t            |  1 | water |   100
 system_u:object_r:sepgsql_table_t            |  2 | coke  |   120
 system_u:object_r:sepgsql_table_t            |  3 | juice |   130
 system_u:object_r:sepgsql_table_t            |  4 | cofee |   180
 system_u:object_r:sepgsql_table_t:Classified |  5 | beer  |   240
 system_u:object_r:sepgsql_table_t:Classified |  6 | sake  |   320
(6 rows)
</screen>
       <para>
	 It shows the <literal>Classified</literal> user got 6 tuples
	 with unconditional <command>SELECT</command> on drink table.

	 However, the unclassified (not labeled) user got 4 tuples
	 with same SQL, because of filtering violated tuples.
       </para>
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t
<prompt>$ </prompt><userinput>psql -q postgres</userinput>
<prompt>postgres=# </prompt><userinput>SELECT security_label, * FROM drink;</userinput>
postgres=# SELECT security_label, * FROM drink;
          security_label           | id | name  | price
-----------------------------------+----+-------+-------
 system_u:object_r:sepgsql_table_t |  1 | water |   100
 system_u:object_r:sepgsql_table_t |  2 | coke  |   120
 system_u:object_r:sepgsql_table_t |  3 | juice |   130
 system_u:object_r:sepgsql_table_t |  4 | cofee |   180
(4 rows)
</screen>
     </sect3>

     <sect3>
       <title>Access controls on Tables and Columns</title>
       <para>
	 SE-PostgreSQL also enables to apply its access controls on
	 tables and columns. It prevents clients to access violated
	 objects, but it has a difference from ones in row-leve.
       </para>
       <para>
	 When client gives a query tree, SE-PostgreSQL walks on the
	 given one to pick up all appeared tables and columns.
	 If it contains one or more violated objects, SE-PostgreSQL
	 aborts query execution and returns an error to the client.
       </para>
       <para>
	 The following example shows a case when we declared
	 <literal>ccredit</literal> column to store credit card numbers
	 as a secret column from unclassified users.
	 The following SQL is declaration of table and initial records.
       </para>
<screen>
CREATE TABLE customer (
    cid     integer primary key,
    cname   varchar(32),
    credit  varchar(32)
        SECURITY_LABEL = 'system_u:object_r:sepgsql_secret_table_t'
);
GRANT ALL ON customer TO PUBLIC;

INSERT INTO customer (cid, cname, credit)
    VALUES ( 10, 'jack', '1111-2222-3333-4444'),
           ( 13, 'adam', '5555-6666-7777-8888'),
           ( 14, 'liza', '9876-5432-1098-7654');
</screen>

<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql -q postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: denied { select } \
	scontext=staff_u:staff_r:staff_t \
	tcontext=system_u:object_r:sepgsql_secret_table_t \
	tclass=db_column name=customer.credit
postgres=# SELECT cid, cname FROM customer;
 cid | cname
-----+-------
  10 | jack
  13 | adam
  14 | liza
(3 rows)
</screen>
       <para>
	 At the first query, he tried to refer all the columns, but
	 SE-PostgreSQL prevents query execution because it contains
	 a reference to <literal>ccredit</literal> column which is
	 labeled as <literal>sepgsql_secret_table_t</literal>.

	 Then, he tried to refer rest of columns expect for the
	 <literal>ccredit</literal> column, so SE-PostgreSQL allows
	 to execute the query, because it does not contains any
	 violater tables and columns.
       </para>
     </sect3>
     <sect3>
       <title>Access Controls on Function</title>
       <para>
	 SE-PostgreSQL also picks up invocations of function during
	 walks on the given query tree. It prevent clients to invoke
	 functions without proper privileges.
       </para>
       <para>
	 In the current default security policy, a function declared by
	 administrative users (like <literal>unconfined_t</literal> domain)
	 is labeled as <literal>sepgsql_proc_t</literal>. But, ones declared
	 by normal users (like <literal>staff_t</literal> domain) are labeled
	 as <literal>staff_sepgsql_proc_exec_t</literal> which does not allow
	 administrative users to invoke.

	 Its purpose is to prevent administrative users to invoke malicious
	 function by mistake. They have to confirm its declaration and
	 relabel its security context to <literal>sepgsql_proc_t</literal>.
       </para>
       <para>
	 SE-PostgreSQL allows clients to change its privileges during
	 execution of specific functions called as trusted-procedures.
	 It has a similar concept to Set-uid program, security invoker
	 and so on.

	 In the current default security policy, trusted procedures are
	 functions labeled as <literal>sepgsql_trusted_proc_exec_t</literal>.
	 It enables to execute these functions with administrative privileges,
	 so gives us a secure method to access confidential objects.

	 It provides simplest all or nothing policy, however, it has
	 a capability to apply more flexible control, if you install your
	 own security policy module.
       </para>
       <para>
	 The following example declares a trusted procedure of
	 <literal>show_credit</literal> to expose information stored in
	 <literal>customer.credit</literal> with turned letter.

	 At first, a client within <literal>staff_t</literal> domain
	 does not access <literal>credit</literal> column. But, it
	 can be accessed via trusted procedure, because the sub-queries
	 come from the procedure is handled as an administrative domain.
       </para>
<screen>
# CREATE OR REPLACE FUNCTION show_credit (integer) RETURNS text
    LANGUAGE 'sql'
    SECURITY_LABEL = 'system_u:object_r:sepgsql_trusted_proc_exec_t'
    AS 'SELECT substring(credit from ''^[0-9]+-'') || ''xxxx-xxxx-xxxx''
            FROM customer WHERE CID = $1';
CREATE FUNCTION
# \q
</screen>
<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: denied { select }      \
    scontext=staff_u:staff_r:staff_t    \
    tcontext=system_u:object_r:sepgsql_secret_table_t   \
    tclass=db_column name=customer.credit
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname |     show_credit
-----+-------+---------------------
  10 | jack  | 1111-xxxx-xxxx-xxxx
  13 | adam  | 5555-xxxx-xxxx-xxxx
  14 | liza  | 9876-xxxx-xxxx-xxxx
(3 rows)

postgres=#
</screen>
     </sect3>
   </sect2>

   <sect2>
     <title>The limitation</title>
     <para>
       SE-PostgreSQL dose not care about information leaks via covert channels.
       It is a technical term used in security evaluation, and means a possibility
       of inference to invisible data via illicit flows.
     </para>
     <para>
       It had been originally required at upper B2 class of TCSEC, and evaluated
       products had to declare explicit maximum bandwidth of covert channels.
       It is now inherited to ISO/IEC15408 knows as CC (Common Criteria).
     </para>
     <para>
       If your requirements contains elimination of covert channels, we don't
       recommend to apply SE-PostgreSQL. However, it is generally considered
       as a requirement of extreame condidential military region.
     </para>
     <para>
       An example of covert channels are here.

       When a man tries to update or delete a tuple with primary key refered by
       one or more invisible foreign keys, SE-PostgreSQL prevent the action to
       keep its reference integrity, even if he cannot see the key.

       This error gives him a side-channel information which is an existance
       of invisible foreign key. Such a behavior is called as covert channel.
     </para>
     <para>
       An actual avoidance for the matter is to apply non-natural primary and
       foreign keys. It enables to be impossible he infer any meaningful data.
     </para>
   </sect2>
</sect1>

<sect1 id="security-sepgsql-admin">
   <title>SE-PostgreSQL Administration</title>

   <sect2>
     <title>Build and Installation</title>
     <sect3>
       <title>Requirement</title>
       <para>
	 We need the following packages to build and install
	 SE-PostgreSQL properly. Please check it at first.
       </para>
       <itemizedlist>
	 <listitem>
	   <para>
	     Linux kernel (2.6.23, or later)
	   </para>
	 </listitem>
	 <listitem>
	   <para>
	     libselinux and libselinux-devel (2.0.43, or later)
	   </para>
	 </listitem>
	 <listitem>
	   <para>
	     selinux-policy (3.4.2, or later)
	   </para>
	 </listitem>
	 <listitem>
	   <para>
	     policycoreutils (2.0.16, or later)
	   </para>
	 </listitem>
       </itemizedlist>
     </sect3>

     <sect3>
       <title>Build</title>
       <para>
	 SE-PostgreSQL feature is disabled in the default build.
	 So, we have to add <option>--enable-selinux</option> option
	 to configure script. It enables to build your PostgreSQL
	 with a feature to suppor SELinux.
       </para>
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make</userinput>
<prompt>$ </prompt><userinput>make -C src/backend/security/sepgsql/policy</userinput>
</screen>
       <para>
	 The current default security policy of SELinux contains a set of
	 rules for SE-PostgreSQL on <literal>selinux-policy-3.4.2</literal>
	 or later. So, we don't need to install special purpose security
	 policy module now.
       </para>
       <para>
	 However, SE-PostgreSQL also provides an optinal policy module
	 for development Purpose. It enables several operations like
	 regression test, toggle audit logs and so on.
       </para>
       <para>
	 It is stored on <filename>src/backend/security/sepgsql/policy</filename>,
	 and can be also build and installed as a binary security policy
	 module.
       </para>
     </sect3>

     <sect3>
       <title>Installation</title>
       <para>
	 Please note that SELinux requires installed files, directories and
	 others should be labeled properly. RPM installation do it implicitly.

	 But, when you install PostgreSQL from a tarball, you should assign
	 proper security context for them. The development policy module
	 has a list that shows what security context should be assigned to
	 what files, and will help you to manage them, so we recommend to
	 install the <filename>sepostgresql-devel.pp</filename> also.
       </para>
<screen>
<prompt># </prompt><userinput>make install</userinput>
<prompt># </prompt><userinput>/usr/sbin/semodule -i src/backend/security/sepgsql/policy/sepostgresql-devel.pp</userinput>
<prompt># </prompt><userinput>/sbin/restorecon -R /usr/local/pgsql</userinput>
</screen>
       <para>
	 <command>semodule</command> is a command to install and uninstall
	 a security policy module. <command>restorecon</command> is a command
	 to assign given directories its default security context recursively.
       </para>

       <para>
	 As we note later, all the files and directories to store database
	 cluster should be labeled as <literal>postgresql_db_t</literal>.
	 The default security policy assumes it is constructed at
	 <filename>/var/lib/pgsql/data</filename> as RPM doing.

	 If you want to set up it on another directory, you need to label
	 it by hand.
       </para>
<screen>
<prompt># </prompt><userinput>mkdir -p $PGDATA</userinput>
<prompt># </prompt><userinput>chcon -t postgresql_db_t -R $PGDATA</userinput>
</screen>
       <para>
	 Then, we need to run <command>initdb</command> to initialize
	 the database cluster. It is necessary to specify an option of
	 <option>--pgace-feature=selinux</option> which enables to initialize
	 database cluster with proper security context.

	 If we omit it, no enhanced security feature is activated on
	 the database cluster.
       </para>
<screen>
<prompt>$ </prompt><userinput>initdb --pgace-feature=selinux</userinput>
<prompt>$ </prompt><userinput>pg_ctl start</userinput>
</screen>
     </sect3>
   </sect2>

   <sect2>
     <title>Configuration</title>

     <sect3>
       <title>GUC Parameters</title>
       <para>
	 PGACE and SE-PostgreSQL have a few GUC parameters.
	 It is evaluated on startup time, so unable to change
	 them at runtime.
       </para>

       <variablelist>
	 <varlistentry>
	   <term><varname>pgace_feature</varname></term>
	   <listitem>
	     <para>
	       Currently, It has two possible values.
	       The one is <literal>none</literal> not to enable any
	       enhanced security features, and the other is
	       <literal>selinux</literal> to enable SE-PostgreSQL
	       feature.
	     </para>
	     <para>
	       If you run <command>initdb</command> with
	       <option>--pgace-feature=selinux</option>, this parameter is
	       automatically specified to <literal>selinux</literal>.
	       But its default is <literal>none</literal>.
	     </para>
	   </listitem>
	 </varlistentry>

	 <varlistentry>
	   <term><varname>sepostgresql</varname></term>
	   <listitem>
	     <para>
	       It has four possible values to specify working mode of
	       SE-PostgreSQL. The <literal>default</literal> is a default
	       selection. It always follows the configuration on operating
	       system. The <literal>enforcing</literal> and
	       <literal>permissive</literal> make SE-PostgreSQL work in the
	       specified mode, independent from kernel setting. Please note
	       that those configuration requires in-kernel SELinux is not
	       disabled. The <literal>disabled</literal> disables the feature
	       of SE-PostgreSQL, so it works as if vanilla PostgreSQL.
	     </para>
	   </listitem>
	 </varlistentry>

	 <varlistentry>
	   <term><varname>sepostgresql_row_level</varname></term>
	   <listitem>
	     <para>
	       It has two possible values <literal>true</literal>, or
	       <literal>false</literal>.
	       It enables to turn on/off the row-level access control feature,
	       however, we recomment you not to turn off the parameter, except
	       for the case when your system has extremely severe requirements
	       in storage comsumption.

	       Its default is <literal>true</literal> which means SE-PostgreSQL
	       applies row-level access controls.
	     </para>
	   </listitem>
	 </varlistentry>
       </variablelist>
     </sect3>
   </sect2>

   <sect2>
     <title>Backup and Restore</title>
     <para>
       When we restore a database from backups, we have to restore
       its security context correctly as GRANT statement doing on
       the restored table.
     </para>

     <para>
       The <command>pg_dump</command> and <command>pg_dumpall</command>
       have <option>--security-label</option> option to dump databases
       with its security context.

       The dumped image can be restored with proper security context.
     </para>

     <para>
       No need to say, a process which invokes <command>pg_dump</command>
       has to be allowed to refer whole of the database,
       because SE-PostgreSQL filters all violated tuples from the result
       set, or aborts query execution if it contains references violated
       columns and so on.

       These requirements are same when we restore the image.
       A process which invokes <command>pg_restore</command> has to have
       enough permission to create/insert these objects with specified
       security context.
     </para>

<screen>
<prompt>$ </prompt><userinput>pg_dump --security-label postgres</userinput>
	:
      (snip)
	:
--
-- Name: drink; Type: TABLE; Schema: public; Owner: kaigai; Tablespace:
--

CREATE TABLE drink (
    id integer NOT NULL,
    name character varying(48),
    price integer
) SECURITY_LABEL = 'system_u:object_r:sepgsql_table_t';
	:
      (snip)
	:
--
-- Data for Name: drink; Type: TABLE DATA; Schema: public; Owner: kaigai
--

COPY drink (security_label, id, name, price) FROM stdin;
system_u:object_r:sepgsql_table_t       1       water   100
system_u:object_r:sepgsql_table_t       2       coke    120
system_u:object_r:sepgsql_table_t       3       juice   130
system_u:object_r:sepgsql_table_t       4       cofee   180
system_u:object_r:sepgsql_table_t:Classified    5       beer    240
system_u:object_r:sepgsql_table_t:Classified    6       sake    320
\.
	:
      (snip)
	:
</screen>
     <para>
       This example shows a backup image with explicitly specified security
       context on tables and tuples.

       If a column has different security context from tables' one, it also
       specified explicitly in the <command>CREATE TABLE</command> statement.
     </para>
   </sect2>

   <sect2 id="security-sepgsql-labeled-networks">
     <title>Labeled Networks</title>
     <para>
       Labeled Networks is an excellent technology.
       It enables to obtain the security context of peer process communicating
       via TCP/IP connection.
     </para>

     <para>
       This technology contains two facilities.
       One is <literal>Labeled IPsec</literal>,
       and the other is <literal>Static Fallbacked Context</literal>.

       This section shows the way to set up both labeled networks
       technology.
     </para>

     <sect3>
       <title>Labeled IPsec</title>
       <para>
	 When we begin to communicate using an encrypted channel
	 with IPsec, <command>racoon</command> which is a key-exchange
	 daemon exchanges encryption keys of both peers.

	 It does not exchange only encryption keys in actually,
	 but the security context of process connecting to is also
	 delivered to the peer side.

	 The delivered security context is cached on the kernel, and
	 it is exported into applications, if it required via
	 <command>getpeercon()</command> API.
       </para>

       <para>
	 This section introduces the steps to set up labeled ipsec.

	 For more detailed information, visit <ulink url="http://www.redhat.com/docs/manuals/enterprise/RHEL-4-Manual/en-US/Security_Guide/s1-vpn-ipsec.html">Red Hat Enterprise Linux 4 - Security Guide</ulink>
       </para>

       <sect4>
	 <title>Example Environment</title>
	 <para>
	   In this introduction, we assume the server host where SE-PostgreSQL
	   works has an IP address of <literal>192.168.1.10</literal> and
	   the client host has IP address of <literal>192.168.1.200</literal>.

	   They are wired to same network, and can communicate each other
	   directly, without any router.
	 </para>

	 <para>
	   The purpose of the following configuration is to obtain
	   the security context of the process working on the client host
	   (<literal>192.168.1.200</literal>) from SE-PostgreSQL daemon
	   working on the server host (<literal>192.168.1.10</literal>), 
	   when a connection is established.
	 </para>
       </sect4>

       <sect4>
	 <title>Adding a SPD entry</title>
	 <para>
	   It is needed to add an SPD (Security Policy Database) entry
	   to indicate applying IPsec on channels between two host.

	   Note that SPD is not a term of SELinux, it is a configuration
	   parameter of IPsec, although it's a bit confusable.
	 </para>

	 <para>
	   This example shows esp/transport mode should be applied on
	   outbounding packets from <literal>192.168.1.10</literal>
	   to <literal>192.168.1.200</literal>, and inbounding packets
	   from <literal>192.168.1.200</literal> to
	   <literal>192.168.1.10</literal>.

<programlisting>
spdadd 192.168.1.10 192.168.1.200 any
-ctx 1 1 "system_u:object_r:ipsec_spd_t:s0"
-P out ipsec
esp/transport//require;

spdadd 192.168.1.200 192.168.1.10 any
-ctx 1 1 "system_u:object_r:ipsec_spd_t:s0"
-P in ipsec
esp/transport//require;
</programlisting>

	   In addition, the second line of each entries enables to
	   turn on security context delivery during key exchanging.
	 </para>

	 <para>
	   You can load the above configuration using
	   <command>setkey</command> command.

	   Save your configuration into a temporary file,
	   and invoke <command>setkey</command> with the file
	   as an argument.
<screen>
<prompt># </prompt><userinput>/sbin/setkey -f &lt;your configuration file&gt;</userinput>
</screen>
	 </para>

	 <para>
	   It is necessary to apply on both server side and client side.

	   Note that you have to invert IP addreses on the client side.
	 </para>
       </sect4>

       <sect4>
	 <title>Racoon configuration</title>
	 <para>
	   In the next, we have to edit a configuration file of
	   <command>racoon</command> to specify encryption algorithm,
	   authentication method and so on.

	   This example uses pre shared key to authenticate the peer
	   host (<literal>192.168.1.200</literal>) for simplification.

	   Note that you have to invert IP addresses on the client side.
	 </para>

	 <para>
	   An additional entry to <filename>/etc/racoon/racoon.conf</filename>.
<programlisting>
remote 192.168.1.200
{
	exchange_mode aggressive, main;
	my_identifier address;
	proposal {
		encryption_algorithm 3des;
		hash_algorithm sha1;
		authentication_method pre_shared_key;
		dh_group 2 ;
	}
}
</programlisting>
	 </para>

	 <para>
	   We have to put a set of key string and IP address of destination
	   in <filename>/etc/racoon/psk.txt</filename>.

	   The key string has also to be same in the client side.
<programlisting>
# file for pre-shared keys used for IKE authentication
# format is: 'identifier' 'key'
# For example:
#
# 10.1.1.1 flibbertigibbet
# www.example.com 12345
# foo@www.example.com micropachycephalosaurus
192.168.1.200	somethingsecrettext
</programlisting>
         </para>
       </sect4>

       <sect4>
	 <title>Restart Racoon</title>
	 <para>
	   Restart racoon daemon in both peers.
	 </para>
<screen>
<prompt># </prompt><userinput>service racoon restart</userinput>
</screen>
       </sect4>
     </sect3>

     <sect3>
       <title>Static Fallbacked Context</title>
       <para>
	 We cannot apply labeled IPsec for any situation.

	 It requires both server and cliets being SElinux'ed and IPsec is
	 available on their communication channel.
       </para>

       <para>
	 SELinux provides an alternative method to identify a security
	 context of peer process inside the <literal>getpeercon()</literal>
	 API, when a connection come from unlabeled networks.

	 This facility is called as static fallbacked context.
	 It enables to return a security context associated with IP address
	 or network interfaces, as if a new connection come from labeled
	 networks.
       </para>

       <para>
	 <command>netlabelctl</command> within <literal>netlabel_tools</literal>
	 package can be used to set up static fallbacked context.
       </para>

       <para>
	 The following example shows a case when we associate a security
	 context with connections come from <literal>192.168.1.0/24</literal>
	 via all network interfaces.
<screen>
<prompt># </prompt><userinput>/sbin/netlabelctl unlbl add default address:192.168.1.0/24 label:user_u:user_r:user_t:s0</userinput>
</screen>
	 The following example shows a case when we associate a security
	 context with connections come from <literal>192.168.2.0/24</literal>
	 via <literal>eth0</literal>.
<screen>
<prompt># </prompt><userinput>/sbin/netlabelctl unlbl add dev:eth0 address:192.168.2.0/24 label:staff_u:staff_r:staff_t:s0:c0</userinput>
</screen>
       </para>
     </sect3>
   </sect2>
 </sect1>

 <sect1 id="security-row-level-acl">
   <title>Row-level Database ACLs</title>
   <para>
     This chapter introduces design and implementation of the Row-level
     Database ACLs in PostgreSQL. It enables to assign indivisual ACLs
     for each tuples, and works as a supplemental facility of existing
     database ACLs applied to tables, columns and so on.
   </para>

   <sect2>
     <title>Design</title>
     <para>
       The design of Row-level Aatabase ACLs feature inherits many things
       from existing access control mechanism. For example, it is a sort
       of discretionary access control mechanism, so it allows owner of
       resources to change its access control rights. It does not prevent
       anything invoked from database superusers.
     </para>
     <para>
       This feature is implemented as a guest of PGACE security framework,
       but wired feature, not a selectable one.
     </para>
     <para>
       It works as if here is a filter to drop violated tuples on scanning
       the relation. Just before the executor scans relation, tables and
       columns level ACLs are also checked, and the feature makes decision
       whether the tuple should be returned, ot not.
     </para>
     <para>
       We provides four kind of permissions on tuples.
       These are <literal>SELECT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal> and <literal>REFERENCES</literal>.

       Please note that <literal>INSERT</literal> permission is not available,
       because the target does not exist when it should be checked.

       You should control insertion of tuples via table-level ACLs.
     </para>
     <para>
       PostgreSQL has foreign key constrint as built-in trigger functions,
       and it invokes another query to keep referential integrities.
       It is an exception case of the filtering. In this case, it raises
       an error to abort current transation, if the query tries to fetch
       a violated tuple.
       It helps referential integrities from global viewpoint, but,
       please note that it has a possibility unprivilged users infer
       existance of one or more invisible tuples.
     </para>
     <para>
       This feature is activated via table option of
       <literal>row_level_acl</literal>. It can heve either of
       <literal>on</literal> or <literal>off</literal> in the default.

       It enables us to refer or set per-tuple ACLs via
       <literal>security_acl</literal> system column newly added.
       We can modify it via <literal>UPDATE</literal>, <literal>INSERT</literal>
       with explict ACLs on the system column.

       A feature to set default ACLs is also available.
       A new table option of <literal>default_row_acl</literal> enables to
       specify a default ACLs of tuples, when no explicit ACLs are given
       from users on its insertion.
     </para>
   </sect2>

   <sect2>
     <title>Installation</title>
     <para>
       We don't need anything to install.
       The Row-level Database ACLs are compiled in the default.
     </para>
   </sect2>

   <sect2>
     <title>Administration</title>
     <sect3>
       <title>Setup Row-level ACLs</title>
       <para>
	 We need to add <literal>row_level_acl</literal> table option on
	 <literal>CREATE TABLE</literal> or <literal>ALTER TABLE</literal>
	 to activate the Row-level Database ACLs.
       </para>
<screen>
<prompt># </prompt><userinput>CREATE TABLE drink (
      id      int primary key,
      name    text,
      price   int
  ) WITH (row_level_acl=on);</userinput>
NOTICE:  CREATE TABLE / PRIMARY KEY will create implicit index "drink_pkey" for table "drink"
CREATE TABLE
</screen>
       <para>
	 We can set Row-level ACLs via <literal>security_acl</literal>
	 system column which is writable.
	 The following queries are example to set up them.
       </para>
<screen>
<prompt># </prompt><userinput>UPDATE drink SET security_acl = '{=r/postgres}' WHERE id in (3,4,5);</userinput>
UPDATE 3
<prompt># </prompt><userinput>SELECT security_acl, * FROM drink order by id;</userinput>
         security_acl           | id | name  | price
--------------------------------+----+-------+-------
 {kaigai=rwd/kaigai}            |  1 | water |   100
 {kaigai=rwd/kaigai}            |  2 | coke  |   120
 {=r/kaigai}                    |  3 | juice |   130
 {=r/kaigai}                    |  4 | cofee |   180
 {=r/kaigai}                    |  5 | beer  |   240
 {kaigai=r/kaigai,ymj=r/kaigai} |  6 | sake  |   320
(6 rows)
</screen>
       <para>
	 The database user must have ownership of the relation or privileges
	 of database superuser, whenever we tries to update the
	 <literal>security_acl</literal>.

	 Please note that the feature considers the owner of table is the
	 owner of tuples stored in, not a man who inserted the tuple.
       </para>
     </sect3>

     <sect3>
       <title>Backup and Restore</title>
       <para>
	 The <command>pg_dump</command> and <command>pg_dumpall</command>
	 has a option to dump tables with Row-level ACLs, which is
	 <literal>--security-acl</literal>.
       </para>
       <para>
	 It enables to contain <literal>security_acl</literal> system
	 column if Row-level ALCs feature is enabled on the target
	 table.
       </para>
<screen>
<prompt>$ </prompt><userinput>pg_dump --security-acl postgres</userinput>
          :
CREATE TABLE drink (
    id integer NOT NULL,
    name text,
    price integer
)
WITH (row_level_acl=on);
          :
--
-- Data for Name: drink; Type: TABLE DATA; Schema: public; Owner: kaigai
--

COPY drink (security_acl, id, name, price) FROM stdin;
{kaigai=rwd/kaigai}     1       water   100
{kaigai=rwd/kaigai}     2       coke    120
{=r/kaigai}     3       juice   130
{=r/kaigai}     4       coffee  180
{=r/kaigai}     5       beer    240
{kaigai=r/kaigai,ymj=rw/kaigai} 6       sake    320
\.
          :
</screen>
     </sect3>
   </sect2>
 </sect1>

 <sect1 id="security-pgace-framework">
   <title>PGACE Security Framework</title>
   <para>
     This chapter introduces the design of PGACE (PostgreSQL Access
     Control Extension) security framework.
   </para>
   <para>
     It enables to host various kind of enhanced security features
     based on different security design, granularity and platforms.

     The Row-level Database ACLs feature is always enabled as
     a common DAC policy on databses, and it also gives users
     a chance to choose one or no MAC features.
   </para>
   <para>
     It allows users to choose a MAC feature via a GUC parameter of
     <literal>pgace_feature</literal> at
     <filename>$PGDATA/postgresql.conf</filename>.
     Its default is <literal>none</literal>, and currently we have
     <literal>selinux</literal> as a candidate.
   </para>
   <para>
     PGACE consists of two major facilities.
     The one is a set of security hooks deployed on some of strategic
     points in the core PostgreSQL. It enables to implement new enhanced
     security features with minimum impact to the core code.
     The other is facilities to manage security attribute which can be
     used to make a decision in access controls.
   </para>

   <sect2>
     <title>Security Hooks</title>
     <para>
       All the security hooks are declared as inline functions at
       <filename>src/include/security/pgace.h</filename>.

       The security hooks have entry points to invoke an enhanced security
       feature chosen by users, so invoked one can return its decision on
       the source strategic point.
     </para>
     <para>
       For example, the following <literal>pgaceHeapTupleInsert</literal>
       is invoked just before inserting a new tuple into a relation.

       If the hook returns <literal>false</literal> to the caller,
       this insertion will be skipped. Otherwise, rest of steps will be
       done notmally.

       The enhanced security feature can make its decision based on the
       given arguments which shows context in the invocation of hook.
       The <literal>rel</literal> and <literal>tuple</literal> show
       the target relation and tuple in this example.
     </para>
<programlisting>
static inline bool
pgaceHeapTupleInsert(Relation rel, HeapTuple tuple,
                     bool is_internal, bool with_returning)
{
    /* A wired DAC check */
    if (!rowaclHeapTupleInsert(rel, tuple,
                               is_internal,
                               with_returning))
        return false;

    switch (pgace_feature)
    {
#ifdef HAVE_SELINUX
    case PGACE_FEATURE_SELINUX:
        if (sepgsqlIsEnabled())
            return sepgsqlHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
        break;
#endif
    default:
        break;
    }
    return true;
}
</programlisting>
     <para>
       This example shows a wired security feature (Row-level Database
       ACLs) and one or no selectable feature are invoked on a tuple
       insertion.

       It allows users to choose one of enhanced security feature from
       candidates via a GUC parameter of <literal>pgace_feature</literal>.
       In this case, SE-PostgreSQL is an only candidate when the binary
       is compiled with <option>--enable-selinux</option> option.
     </para>
     <para>
       If you add a new security feature, you should add a new case
       branch in the <literal>switch</literal> statement and an option
       to the GUC parameter, for users selection.

       The following example shows a case when someone add a new security
       feature compiled when <literal>HAVE_FOO_SECURITY</literal> is
       defined on build-time.
     </para>
<programlisting>
static inline bool
pgaceHeapTupleInsert(Relation rel, HeapTuple tuple,
                     bool is_internal, bool with_returning)
{
    /* A wired DAC check */
    if (!rowaclHeapTupleInsert(rel, tuple,
                               is_internal,
                               with_returning))
        return false;

    switch (pgace_feature)
    {
#ifdef HAVE_SELINUX
    case PGACE_FEATURE_SELINUX:
        if (sepgsqlIsEnabled())
            return sepgsqlHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
        break;
#endif
#ifdef HAVE_FOO_SECURITY
    case PGACE_FEATURE_FOO_SECURITY:
        return fooSecurityHeapTupleInsert(rel, tuple,
                                          is_internal,
                                          with_returning);
        break;
#endif
    default:
        break;
    }
    return true;
}
</programlisting>
     <para>
       Please note that individual specifications of security hooks are
       described in <filename>src/include/security/pgace.h</filename>
       as comment. It will help you to understand.

       If a part of given hooks are unnecessary for your security design,
       keep it as is.
     </para>
   </sect2>

   <sect2>
     <title>Security Label Management</title>
     <para>
       The security label is a human readable security attribute which
       can be export/import via <literal>security_label</literal> system
       column.
       PGACE provides a common facility to manage the security label of
       tuples for various kind of security features.
       It enables an enhanced security feature chosen to store and featch
       a security label of tuples, and allows it to make a decision in
       access controls based on the label.
     </para>
     <para>
       We can export/import the security labels in text format, but
       they are handled as an alternative identifier internally.

       We call it as a security identifier (sid), and it has a length
       of <literal>sizeof(Oid)</literal>. The sid references to
       an entry within <literal>pg_security</literal> system catalog,
       and the entry holds a human readable text representation.
     </para>
     <para>
       We can have the sid on the padding field of
       <literal>HeapTupleHeader</literal>, as if oid doing.
       We can fetch it with <literal>HeapTupleGetSecLabel()</literal>.

       If <literal>pgaceTupleDescHasSecLabel()</literal> hook returns
       <literal>true</literal> for the given relation, it indicates
       to allocate sid field on the tuples within the relation.
       In this case, we can set a sid using
       <literal>HeapTupleSetSecLabel()</literal> macro.
     </para>
     <para>
       PGACE provides a few utility functions.

       <literal>pgaceLookupSecurityId()</literal> returns a sid
       towards given security label in text format. If it is not on
       <literal>pg_security</literal>, it automatically inserts a new
       entry and returns its sid.

       <literal>pgaceLookupSecurityLabel()</literal> returns a security
       label for the given sid.
       If it is not on <literal>pg_security</literal>, it returns
       <literal>NULL</literal>, so the guest should handler it as a
       something like default or unlabeled.
     </para>
     <para>
       The <literal>security_label</literal> system column allows users
       to input a security label in text format on <command>INSERT</command>,
       <command>UPDATE</command>, <command>COPY</command> and so on.

       The given security label is translated into sid automatically, and
       put on the security field of tuples. If user provides nothing as
       a security label, it is initialized as <literal>InvalidOid</literal>.

       The <literal>pgaceHeapTupleInsert()</literal> or others are invoked
       later, so the enhanced security feature can know whether user gives
       a proper security label or not. If no security label is given, it
       can assign a default security label. If violated security label is
       given, it can raise an error.

       Vice versa, when user refers <literal>security_label</literal>,
       the sid of tuples are automatically translated into text format.
       If the sid is invalid, the enhanced security feature can return
       an alternative string using
       <literal>pgaceUnlabeledSecurityLabel()</literal> hook.
     </para>
     <para>
       The Row-level Database ACLs uses the facility to manage security
       labels to store its ACLs. Tules have a capability to store both
       of sids simultaneously, and enhanced security features should
       not touch them.
     </para>
   </sect2>
 </sect1>

</appendix>
