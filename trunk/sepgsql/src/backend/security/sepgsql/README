
SE-PostgreSQL developer documentation
=====================================

TABLE OF CONTENTS
=================

1. Overview
1-1. Brief overview of SE-PostgreSQL
1-2. Mandatory access control
1-3. Security context
1-4. Misc features
2. Internal architecture
2-1. communication with SELinux
2-2. management of security context
2-3. privilege of the client
2-4. security hooks
2-5. initialization
3. Object classes and permissions
3-1. common permissions of database object
3-2. db_database object class
3-3. db_schema object class
3-4. db_table object class
3-5. db_column object class
4. Code examples
4-1. Example of SE-PgSQL hooks
4-2. Example of third party module

1. Overview
============================================================

1-1. Brief overview of SE-PostgreSQL
------------------------------------
SE-PostgreSQL (hereafter SE-PgSQL) is a feature of PostgreSQL which applies
MAC policy on the given SQL queries. Its most significant feature is any access
control decisions are provided by SELinux, and SE-PgSQL correctly performs
according to the decisions.

SELinux is a subsystem in the Linux kernel. It also provides its access control
decision for various kind of kernel subsystems. For example, when we tries to
write on a certain file, VFS mechanism ask SELinux whether the given system-call
can be executable, or not. SELinux returns its access control decision based on
the security policy, then the caller (VFS) controls accesses according to the
decision.

We can consider SELinux as something like a function which returns a binary
state ("allowed" or "denied") for the given arguments. It requires the security
context of subject and object, and required permissions.
For example, when we write something on a certain file using shell commands,
VFS layer hooks write(2) calls to invoke SELinux, and it gives a pair of
security contexts of the shell process and the file to be written, and codes
corresponding to "file:{write}" permission.

In the system with SELinux, we can confirm security context of the current
process with "id -Z" command.

  [kaigai@saba ~]$ id -Z
  unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

We can confirm security context of the files with "ls -Z" command.

  [kaigai@saba ~]$ ls -Z /etc/passwd /etc/shadow
  -rw-r--r--. root root system_u:object_r:etc_t:s0       /etc/passwd
  -r--------. root root system_u:object_r:shadow_t:s0    /etc/shadow

SELinux lookups an entry matched with the given pair of security context from
the security policy which is a massive set of rules, and every rule has allowed
set of actions. If it contains all the required actions, "allowed" should be
returned, otherwise "denied".

We can apply this design on accesses to database objects, not only kernel, as
long as RDBMS correctly manages the security context of them.
SE-PgSQL assigns an individual security context on the managed database objects,
and asks SELinux whether the given accesses should be allowed, or not.


1-2. Mandatory access control
-----------------------------

SELinux provides MAC based policy, so here are several differences from
the default PG model (known as a kind of DAC). The characteristics of MAC
are a centralized security policy and unbypassable access controls.

The default PG model allows owners to grant/revoke discretionary access rights
on the owned objects. On the other hand, only a centralized security policy
controls all the accesses in MAC model. So, it does not allow users to set up
discretionary access rights without allowance by the policy, even if they are
owner of the database objects.

In addition, its access control is unbypassable, even if the client has
database superuser privileges. It checks all the needed permissions on
the database objects without any exception.
If we implicitly allows to bypass any permission checks on certain users, it
makes impossible to analyze data-flows from the viewpoint of security policy.

So, the point is no omission for MAC checks, even if it already checks 

For example, the default PG model does not apply access controls for database
superusers. It simply skips routines to check database acls. It is correct
manner in DAC, but undesirable manner in MAC.
If DAC checks are enclosed by something like "if (superuser())" block, SE-PgSQL
checks have to be invoked outside of the block.


1-3. Security context
---------------------

SELinux identifies any entities (such as processes, files, tables, ...) using
its security context. The security context is a short formatted text as:

  system_u:object_r:sepgsql_table_t:s0

It is the only identifier in SELinux model, instead of user-id or permission
bits. When the default PG model makes its access control decision, it checks
whats are allowed/disallowed on a certain pair of user-id and ACLs of the object
to be accessed. Note that user-id is a property of the client, and the ACLs is
also a property of the object to be accessed.
In similar way, SELinux makes its access control decision. It checks what is
allowed/disallowed on a certain pair of the security contexts of client and
object to be accessed.

A security context is separated into four fields, as follows:

  <selinux user>:<role>:<domain/type>:<range>

SELinux has a few kind of access control strategies (aka, RBAC, TE, MLS),
every fields are corresponding to a certain strategy. But it is encapsulated
within kernel code, all SE-PgSQL has to do is to follow the decision of SELinux.

When user create a new database object, a default security context shall be
assigned on the new object. It is provided by the security policy in kernel,
and SE-PgSQL assigns the offered one in the default.
The default security context is decided for a pair of security contexts of
the client and its parent object. See the later chapter for more details.


1-4. Misc features
------------------

o Enforcing/Permissive mode

These are a working mode in SELinux. In enforcing mode, it actually applies
its access controls, and raises an error if violated. On the other hand, it
also checks the security policy but does not prevent anything in permissive
mode, except for access violation logs.
The purpose of permissive mode is to debug the security policy itself.

A GUC option: sepostgresql controls this behavior.

  sepostgresql = [default | enforcing | permissive | disabled ]

    default    : It follows system setting.
    enforcing  : Always enforcing, if SELinux is enabled on the system
    permissive : Always permissive, if SELinux is enabled on the system
    disabled   : Always disabled (default setting)


o Security audit

The security policy also has rules to control generation of security audit.
It suggests SE-PgSQL to generate security audit logs on access violations
or access allowed. It is called 'auditdeny' and 'auditallow' rules.
In the default, it generates audit logs on access violations, but do nothing
when accesses are allowed.

Below is an example when SE-PgSQL prevent violated accesses on a column.

  LOG:  SELinux: denied { select }  \
      scontext=staff_u:staff_r:staff_t:Unclassified  \
      tcontext=system_u:object_r:sepgsql_secret_table_t:Unclassified  \
      tclass=db_column name=customer.ccredit


o MCS translation

The forth field of security context means its range in MLS (Multi Level
Security) rules. It is represented with a combination of symbols, so it is not
well human-readable. MCS translation enables to associate them with a human
readable alias.

For example, if "s0:c0" means an unclassified document in finance division
labeled as "Unclassified-Finance", the raw range is replaced by the human
readable form as follows:

    Raw-format  : system_u:object_r:sepgsql_table_t:s0:c0
  Human readable: system_u:object_r:sepgsql_table_t:Unclassified-Finance
                                                    ^^^^^^^^^^^^^^^^^^^^
SELinux provides an API to translate them. All the security contexts are stored
in raw-format, and it is translated on printing time.

A GUC option: sepostgresql_mcstrans = [on | off] controls this behavior.
If it is turned off, it print out security context in raw-format.


2. Internal architecture
============================================================

2-1. communication with SELinux
-------------------------------

SELinux provides a set of APIs to communicate between kernel and applications,
encapsulated in libselinux. It allows applications to ask SELinux whether the
given user's request should be executed, or not.
The following two APIs are especially important ones for SE-PgSQL.

o security_compute_av()

It returns a set of allowed permissions for a pair of security contexts and
a certain object class, so the caller can know what permissions are allowed.

This example shows a case when we ask SELinux what is the allowed set of
permissions on a pair of a client with "system_u:system_r:httpd_t:s0" and
a table with "system_u:object_r:sepgsql_table_t:s0" for the "db_table" object
class.
This API set up the av_decision structure correctly, then we can check returned
bitmask which contains allowed permissions later. If a bit corresponding to
the db_table:{select} permission is set, it should be allowed.

  Example)
    struct av_decision avd;
    char   *scontext = "system_u:system_r:httpd_t:s0";
    char   *tcontext = "system_u:object_r:sepgsql_table_t:s0";
    int16   tclass;
    uint32  permission;
              :
    tclass = string_to_security_class("db_table");
    if (security_compute_av(scontext, tcontext, 0, tclass, &avd) < 0)
        elog(ERROR, "SELinux internal error");
              :
    permission = string_to_av_perm(tclass, "select");
    if (avd.allowed & permission)
        elog(NOTICE, "%s is allowed to select %s", scontext, tcontext);
    else
        elog(NOTICE, "%s is disallowed to select %s", scontext, tcontext)


o security_compute_create()

It returns a default security context of a newly created object for a pair
of security contexts and a certain object class, so the caller can know what
security context should be assigned on the new one.

This example shows a case when we ask SELinux what security context should be
assigned on the new table created by a client with "system_u:system_r:httpd_t:s0"
in the schema with "system_u:object_r:sepgsql_schema_t:s0".
This API set up a default security context correctly, then we can assign it on
the new object later.

  Example)
    char   *scontext = "system_u:system_r:httpd_t:s0";
    char   *tcontext = "system_u:object_r:sepgsql_schema_t:s0";
    char   *ncontext;
    int16   tclass;
              :
    tclass = string_to_security_class("db_table");
    if (security_compute_create(scontext, tcontext, tclass, &ncontext) < 0)
        elog(ERROR, "SELinux internal error");
              :
    elog(NOTICE, "New security context is %s", ncontext);
              :
    freecon(ncontext);      /* must be free */


2-2. management of security context
-----------------------------------

A limited number of database object classes have its own security context in
this version, so we decided to store them as a text field of the following
system catalogs:

 - pg_database.datsecon   = security context of the database
 - pg_namespace.nspsecon  = security context of the schema
 - pg_class.relsecon      = security context of the table
                         (if relkind = RELKIND_RELATION, otherwise no label)
 - pg_attribute.attsecon  = security context of the column
                         (if it owned by the regular table, otherwise no label)

We have a plan to provide a facility to manage security context of various
kind of database objects, including individual tuples within user defined
tables. But it is postponed to keep the change-set more simple and small.

These fields means security context of the (managed) database objects.
In this version, only four object classes (database, schema, table and column)
are managed, so SE-PgSQL makes its access control decisions on them only.

When we create a new object, a default security context shall be assigned on
the fields, then it is used for its security identifier for SE-PgSQL.
If SE-PgSQL is disabled, NULL shall be set on.

From the viewpoint of implementation, SE-PgSQL provides a few hooks to check
permission to create a new object. It also returns the security context to be
assigned on the new object.

For example, it is a hook to check db_schema:{create} permission.

  extern Value *
  sepgsql_schema_create(const char *nspName, bool isTemp, Node *nspLabel);

The caller has to give required informations as arguments. This hook checks
permission, and returns the security context to be assigned.
We also modified the caller side a bit. It copies the returned security context
on the pg_namespace.nspsecon as a TEXT value before simple_heap_insert().
If hook returned NULL, the caller also set NULL on the pg_namespace.nspsecon.
(Note that the hook always returns NULL when SE-PgSQL is disabled.)


2-3. privilege of the client
----------------------------

SELinux also provides an interesting API: getpeercon(3). It enables to obtain
the security context of the peer process for the given file-descriptor of the
network socket.

If the given connection is unix domain socket, we don't need any special
configurations. If remote connection, it is necessary to set up labeled ipsec
connection between server and clients to deliver the security context of the
peer process when key exchange negotiations.
(we can set up static-fallback'ed security context based on the ip address of
clients for a case when SELinux is not unavailable on the client side.)

This example shows a case when we obtain a security context of the peer.

  Example)

    char   *scontext;
              :
    if (getpeercon(MyProcPort->sock, &scontext) < 0)
        elog(ERROR, "SELinux internal error");
              :
    elog(NOTICE, "security context of the client: %s", scontext);
              :
    freecon(scontext);


2-4. security hooks
-------------------

SE-PgSQL needs to deploy its security hooks on the strategic points.
These hooks are designed not to affect anything for code paths, if SE-PgSQL
is disabled on either compile-time or run-time.

Its specifications and purposes are described as source code comments, so we
can find detailed information at src/backend/security/sepgsql/*.c files.
The caller has to provide needed information for the hooks.

For example, sepgsql_check_rte_perms() which checks access permissions for
the given RangeTblEntry (which contains OID of the target relation and
Bitmapset of selected/modified columns). The caller has to give enough
information SE-PgSQL to make its access control decision correctly.

The sepgsql_check_rte_perms() makes its access control decision based on
the given information (RangeTblEntry object to be checked) and MAC policy
in the kernel. If allowed, it simply returns to the called. Otherwise, it
raises an error to abort current transaction.
The specification and behavior of individual security hooks are described
in the source code comments.


2-5. Initialization
-------------------

The initdb command set up a initial database on an empty directory.
At first, it launches PgSQL in bootstraping mode (--boot) to insert initial
contents of system catalogs from the postgres.bki, then it launches PgSQL in
single-user mode (--single) to apply rest of initialization.

In the bootstraping mode, SE-PgSQL is automatically disabled, because it does
not have enough data integrity to apply its security policy correctly.
For example, it computes a default security context of the table based on the
pair of client and schema which owns the new table, but pg_namespace catalog
is declared after the pg_catalog catalog.

So, SE-PgSQL initializes security contexts of the managed database objects
in the "template1" database on the second phase in initdb.
If initdb is launched with "--enable-selinux" option, it invokes a special
purpose function to assign initial security contexts on them. This function 
is available only when single-user mode for the security reason.


3. Object classes and permissions
============================================================

Object class is a terminology that means a certain type of object, such as
files, processes, tables in database and so on. Every object classes have
its own set of permissions which reflect characteristics of the object class,
but some of permissions are commonly defined for various kind of database object
classes to handle common object behavior; creation, deletion, setting and getting
attributes, and relabeling its own security context.

Unless an explicit explanation, these permission is checked on a pair of the
client and the object to be accessed. In other word, security_compute_av()
will take the following arguments:

 subject context = security context of the client
 target context  = security context of the object to be accessed

For example, when a client with "user_u:user_r:user_t:s0" tries to drop
a table with "system_u:object_r:sepgsql_ro_table_t:s0", SE-PgSQL calls
security_compute_av() with both of security context and the code for
db_table object class, then checks whether the allowed set of permissions
contains a bit for db_table:{drop} permission, or not.


3-1. common permissions of database object
------------------------------------------

The following six permissions are commonly defined for database object classes.

o create

It is checked when a client tries to create a new database object.

SE-PgSQL assigns a default security context (if no explicit one is not given)
on the new objects, then "create" permission shall be checked on a pair of the
client and the new object labeled correctly.

For example, when a client labeled as "staff_u:staff_r:staff_t:s0" tries
to create a new table, SE-PgSQL computes its default security context with
communicating SELinux. If "staff_u:object_r:sepgsql_table_t:s0" is given,
SE-PgSQL assigns it on the new table, and checks "db_table:{create}" permission
on a pair of the security contexts.

CREATE statement typically invokes a check for "create" permission.
However, note that no needs to check for objects creation by system internal
stuff, such as TOAST relations, initdb works and so on.

Some statements have OR REPLACE option. In the case when a client replaces
an existing database object, "setattr" is applied instead of "create", even
if CREATE statement is given. Because it does not create any new object, and
its security context is remained.

o drop

It is checked when a client tries to drop an existing database object.
This check is also applied on cascaded deletions, not only original one.

For example, when a client labeled as "staff_u:staff_r:staff_t:s0" tries
to drop a schema with "system_u:object_r:sepgsql_schema_t:s0" that contains
a table with "system_u:object_r:sepgsql_table_t:s0".
In this case, SE-PgSQL checks "db_schema:{drop}" permission on a pair of
the client and the schema, and "db_table:{drop}" permission on a pair of
the client and the table. Both of them should be allowed.

Note that no needs to check for objects deletion by system internal
stuff, such as cleanups of temporary objects.

o getattr (not implemented yet)

It is checked when a client tries to read any metadata of database objects.
This check is implemented using row-level access controls on the system
catalog (such as, SELECT * FROM pg_class), so the current version does not
provide "getattr" checks.

Note that no need to check this permission, as long as the fetched metadata
is consumed internally, without returning to the client. For example, catcache
stuff provide an easy way to access system catalog, the fetched data is not
returned to clients in normal way, so we don't check this permission here.


o setattr

It is checked when a client tries to modify any metadata of database objects.

ALTER statement typically invokes a check for "setattr" permission.
However, no need to check when system internal stuff updates system catalogs
to keep data integrity, such as dependency mechanism or increment/decrement
of attinhcount in pg_attribute system catalog.


o relabelfrom

It is checked when a client tries to change security context of a certain
database object, on a pair of the client's security context and the older
security context.


o relabelto

It is checked when a client tries to change security context of a certain
database object, on a pair of the client's security context and the newer
security context.



3-2. db_database object class
-----------------------------

The db_database represents the database object itself which is an entry within
pg_database system catalog.
It has three its own permissions and inherits the common permissions.

o default security context

The default security context for db_database is decided based on a pair of
the client and the data directory (specified by -D option).


o access

It is checked when the client tries to connect to a certain database.


o load_module (not implemented yet)

It is checked when a dynamic link library is loaded to the server process.
Note that this permission is checked on a pair of the current database and
the dynamic link library file. In other word, it checks capability to load
a certain file into a certain database.

In this case, security_compute_av() takes the following arguments:
 subject context = security context of the current database
 target context  = security context of the dynamic link library file

Note that shared_preload_libraries is an exception for this check,
because it is not controllable with any client's request.

o install_module (not implemented yet)


o superuser

It is checked when the client tries to perform as a superuser on the current
database. If it is not allowed, the client cannot perform as a superuser, but
SE-PgSQL does not raise an error. He can just perform as a non-privileged
database user.



3-2. db_schema object class
---------------------------

o default security context


o search

o add_name

o remove_name


3-3. db_table object class
--------------------------

o default security context

o select

o update

o insert

o delete

o lock

o inherit (not implemented yet)

3-4. db_column object class
---------------------------

The db_column represents the column object which is an entry within
pg_attribute system catalog, and its attrelid refers a db_table object
(relkind = RELKIND_RELATION).
It has four its own permissions and inherits the commoen permissions.

The db_column object class has a hardwired constraint corresponding to table
inheritance. A inherited column cannot have different security context from
the source column in the inheritance tree.
If table "t2" is a inheritance of "t1" which has a column: "t1.x", the "t2"
also have a column "t2.x". (Its attinhcount will be 1). In this case, "t2.x"
always has same security context inherited from the "t1.x".

We don't allow users to change the security context of "t2.x". When "t1.x" is
relabeled, it implicitly relabels "t2.x" also, using ALTER TABLE.


o default security context

The default security context for db_column is decided based on a pair of
the client and table owning the new column.

When a new column is inherited from other table's definition, SE-PgSQL
also copied the security context of the original one, independent from
the default security context. If a column has multiple parents, all the
security contexts have to be matched.

o select


o update


o insert



4. Code examples
============================================================




