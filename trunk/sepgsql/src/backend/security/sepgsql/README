
SE-PostgreSQL developer documentation
=====================================

TABLE OF CONTENTS
=================

1. Overview
1-1. Brief overview of SE-PostgreSQL
1-2. Mandatory access control
1-3. Security context
1-4. Misc features
2. Internal architecture
2-1. communication with SELinux
2-2. management of security context
2-3. privilege of the client
2-4. security hooks
2-5. initialization
3. Object classes and permissions
3-1. common permissions of database object
3-2. db_database object class
3-3. db_schema object class
3-4. db_table object class
3-5. db_column object class
4. Code examples
4-1. Example of SE-PgSQL hooks
4-2. Example of third party module

1. Overview
============================================================

1-1. Brief overview of SE-PostgreSQL
------------------------------------
SE-PostgreSQL (hereafter SE-PgSQL) is a feature of PostgreSQL which applies
MAC policy on the given SQL queries. Its most significant feature is any access
control decisions are provided by SELinux, and SE-PgSQL correctly performs
according to the given decisions.

SELinux is a subsystem in the Linux kernel. It also provides its access control
decision for various kind of kernel subsystems. For example, when we tries to
write on a certain file, VFS layer asks SELinux whether the given system call
can be executable, or not. SELinux returns its access control decision based on
the security policy, then the caller (VFS) controls user's accesses according
to the decision.

We can consider SELinux as something like a function which returns a binary
state ("allowed" or "denied") for the given arguments. It needs a set of
required permissions and a pair of the security contexts of subject and object.
For example, when we write something on a certain file using shell commands,
VFS layer hooks write(2) calls to invoke SELinux, and it also gives a pair of
security contexts of the shell process (as subject) and the file to be written
(as object), and an identifier of "file:{write}" permission.

In the system with SELinux, we can confirm security context of the current
process using "id -Z" command.

  [kaigai@saba ~]$ id -Z
  unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

We can also confirm security context of the files with "ls -Z" command.

  [kaigai@saba ~]$ ls -Z /etc/passwd /etc/shadow
  -rw-r--r--. root root system_u:object_r:etc_t:s0       /etc/passwd
  -r--------. root root system_u:object_r:shadow_t:s0    /etc/shadow

SELinux finds up an entry matched to the given pair of security contexts from
the security policy which is a massive set of rules, and every rule has allowed
set of actions. If it contains all the required actions, "allowed" should be
returned, otherwise "denied".

We can apply this design on accesses to database objects, not only kernel, as
long as RDBMS correctly manages the security context of them.
SE-PgSQL assigns an individual security context on the managed database objects,
and asks SELinux whether the given accesses should be allowed, or not.


1-2. Mandatory access control
-----------------------------

SELinux provides MAC based policy, so here are a few differences from the
default PG model (also known as a DAC model). The characteristics of MAC
are a centralized security policy and unbypassable access controls.

The default PG model allows owners to grant/revoke discretionary access rights
on the owning objects. On the other hand, MAC model does not allow resource
owners to grant/revoke permissions (it is an equivalent operation to relabel
security context of resources), unless the centralized security policy
explicitly allows the operation, even if user has a ownership of the resources.

In addition, its checks are not bypassable, even if the client has database
superuser privileges. MAC checks all the needed permissions to access certain
database objects without any exception. Note that the database superuser is
a property in the default PG model, but SELinux makes its access control
decision based on a pair of security context, orthogonal to the properties in
the default PG model.

The following code is a typical example. The ATExecChangeOwner() updates
owner of the relation. In DAC model, any permission checks are bypassed
when user has superuser privilege.

  void
  ATExecChangeOwner(Oid relationOid, Oid newOwnerId, bool recursing)
  {
          :
      /* Superusers can always do it */
      if (!superuser())
      {
          Oid         namespaceOid = tuple_class->relnamespace;
          AclResult   aclresult;

          /* Otherwise, must be owner of the existing object */
          if (!pg_class_ownercheck(relationOid, GetUserId()))
              aclcheck_error(ACLCHECK_NOT_OWNER, ACL_KIND_CLASS,
                             RelationGetRelationName(target_rel));

          /* Must be able to become new owner */
          check_is_member_of_role(GetUserId(), newOwnerId);

          /* New owner must have CREATE privilege on namespace */
          aclresult = pg_namespace_aclcheck(namespaceOid, newOwnerId,
                                            ACL_CREATE);
          if (aclresult != ACLCHECK_OK)
              aclcheck_error(aclresult, ACL_KIND_NAMESPACE,
                             get_namespace_name(namespaceOid));
      }
      /* SE-PgSQL checks permission to alter property of tables */
      sepgsql_relation_alter(relationOid, NULL, InvalidOid);
          :
  }

However, we can never deploy any SE-PgSQL checks inside "if (!superuser())"
block, because it means MAC allows database superusers anything, although
it is a property in DAC model.

The point is that MAC makes its access control decision based on the security
policy and its properties known as security context, orthogonal to any other
properties such as database role, resource owner and so on.


1-3. Security context
---------------------

SELinux identifies any entities (such as processes, files, tables, ...) using
its security context. The security context is a short formatted text as:

  system_u:object_r:sepgsql_table_t:s0

It is the only identifier in SELinux model, instead of user-id or permission
bits. When the default PG model makes its access control decision, it checks
whats are allowed/disallowed on a certain pair of user-id and ACLs of the
object to be accessed. Note that user-id is a property of the client, and
the ACLs is also a property of the object to be accessed.
In similar way, SELinux makes its access control decision. It checks what is
allowed/disallowed on a certain pair of the security contexts of client and
object to be accessed.

A security context can be separated into four fields, as follows:

  <selinux user>:<role>:<domain/type>:<range>

SELinux has a few kind of access control strategies (aka, RBAC, TE, MLS),
and every fields are corresponding to a certain strategy.
But it is encapsulated within kernel code, so userspace applications don't
need to have detailed knowledge about this.
All we need to do is to provide correct security context and to control
accesses from users according to the access control decision.

When user create a new database object, a default security context shall be
assigned on the new object. It is provided by the security policy in kernel,
and SE-PgSQL assigns the offered one in the default.
The default security context is decided for a pair of security contexts of
the client and its parent object. See the later chapter for more details.


1-4. Misc features
------------------

o Enforcing/Permissive mode

These are a working mode in SELinux. In enforcing mode, it actually applies
its access controls, and raises an error if violated. On the other hand, it
also checks the security policy but does not prevent anything in permissive
mode, except for access violation logs.
The purpose of permissive mode is to debug the security policy itself.

A GUC option: sepostgresql controls this behavior.

  sepostgresql = [default | enforcing | permissive | disabled ]

    default    : It follows system setting.
    enforcing  : Always enforcing, if SELinux is enabled on the system
    permissive : Always permissive, if SELinux is enabled on the system
    disabled   : Always disabled (default setting)


o Security audit

The security policy also has rules to control generation of security audit.
It suggests SE-PgSQL to generate security audit logs on access violations
or access allowed. It is called 'auditdeny' and 'auditallow' rules.
In the default, it generates audit logs on access violations, but do nothing
when accesses are allowed.

Below is an example when SE-PgSQL prevent violated accesses on a column.

  LOG:  SELinux: denied { select }  \
      scontext=staff_u:staff_r:staff_t:Unclassified  \
      tcontext=system_u:object_r:sepgsql_secret_table_t:Unclassified  \
      tclass=db_column name=customer.ccredit


o MCS translation

The forth field of security context means its range in MLS (Multi Level
Security) rules. It is represented with a combination of symbols, so it is not
well human-readable. MCS translation enables to associate them with a human
readable alias.

For example, if "s0:c0" means an unclassified document in finance division
labeled as "Unclassified-Finance", the raw range is replaced by the human
readable form as follows:

    Raw-format  : system_u:object_r:sepgsql_table_t:s0:c0
  Human readable: system_u:object_r:sepgsql_table_t:Unclassified-Finance
                                                    ^^^^^^^^^^^^^^^^^^^^
SELinux provides an API to translate them. All the security contexts are
stored in raw-format, and it is translated on exporting/importing time.

A GUC option: sepostgresql_mcstrans = [on | off] controls this behavior.
If it is turned off, it print out security context in raw-format.


2. Internal architecture
============================================================

2-1. communication with SELinux
-------------------------------

SELinux provides a set of APIs to communicate between kernel and applications,
encapsulated in libselinux. It allows applications to ask SELinux whether the
given requests from users should be executable, or not.
The following two APIs are especially important for SE-PgSQL.

o security_compute_av()

It returns a set of allowed permissions on a pair of security contexts and
a certain object class, so the caller can know what permissions are allowed.

This example shows a case when we ask SELinux what is the allowed set of
permissions on a pair of a client with "system_u:system_r:httpd_t:s0" and
a table with "system_u:object_r:sepgsql_table_t:s0" for the "db_table" object
class.
This API set up the av_decision structure correctly, then we can check returned
bitmask which contains allowed permissions later. If a bit corresponding to
the db_table:{select} permission is set, it should be allowed.

  Example)
    struct av_decision avd;
    char   *scontext = "system_u:system_r:httpd_t:s0";
    char   *tcontext = "system_u:object_r:sepgsql_table_t:s0";
    int16   tclass;
    uint32  permission;
              :
    tclass = string_to_security_class("db_table");
    if (security_compute_av(scontext, tcontext, 0, tclass, &avd) < 0)
        elog(ERROR, "SELinux internal error");
              :
    permission = string_to_av_perm(tclass, "select");
    if (avd.allowed & permission)
        elog(NOTICE, "%s is allowed to select %s", scontext, tcontext);
    else
        elog(NOTICE, "%s is disallowed to select %s", scontext, tcontext)

    (*) Note that user's context is given from the peer socket,
        table's context is given from the pg_catalog system catalog
        in actually.


o security_compute_create()

It returns a default security context of a newly created object on a pair
of security contexts and a certain object class, so the caller can know what
security context should be assigned on the new one.

This example shows a case that we ask SELinux what security context should be
assigned on a new table when a client (system_u:system_r:httpd_t:s0) tries to
create it under the schema (system_u:object_r:sepgsql_schema_t:s0).
This API shall return with a default security context at the third argument,
then we can assign it on the new object later.

  Example)
    char   *scontext = "system_u:system_r:httpd_t:s0";
    char   *tcontext = "system_u:object_r:sepgsql_schema_t:s0";
    char   *ncontext;
    int16   tclass;
              :
    tclass = string_to_security_class("db_table");
    if (security_compute_create(scontext, tcontext, tclass, &ncontext) < 0)
        elog(ERROR, "SELinux internal error");
              :
    elog(NOTICE, "New security context is %s", ncontext);
              :
    freecon(ncontext);      /* must be free */

    (*) Note that user's context is given from the peer socket,
        schema's context is given from the pg_namespace system catalog
        in actually.


2-2. management of security context
-----------------------------------

A limited number of database object classes have its own security context in
this version, so we decided to store them as a text field of the following
system catalogs:

 - pg_database.datsecon   = security context of the database
 - pg_namespace.nspsecon  = security context of the schema
 - pg_class.relsecon      = security context of the table
                         (if relkind = RELKIND_RELATION, otherwise no label)
 - pg_attribute.attsecon  = security context of the column
                         (if it owned by the regular table, otherwise no label)

We have a plan to provide a facility to manage security context of various
kind of database objects, including individual tuples within user defined
tables. But it is postponed to keep the change-set more simple and small.

These fields means security context of the (managed) database objects.
In this version, only four object classes (database, schema, table and column)
are managed, so SE-PgSQL makes its access control decisions on them only.

When we create a new object, a default security context shall be assigned on
the fields, then it is used for its security identifier for SE-PgSQL.
If SE-PgSQL is disabled, NULL shall be set on.

From the viewpoint of implementation, SE-PgSQL provides a few hooks to check
permission to create a new object. It also returns the security context to be
assigned on the new object.

For example, it is a hook to check db_schema:{create} permission.

  extern Value *
  sepgsql_schema_create(const char *nspName, bool isTemp, Node *nspLabel);

The caller has to give required informations as arguments. This hook checks
permission, and returns the security context to be assigned.
We also modified the caller side a bit. It copies the returned security context
on the pg_namespace.nspsecon as a TEXT value before simple_heap_insert().
If hook returned NULL, the caller also set NULL on the pg_namespace.nspsecon.
(Note that the hook always returns NULL when SE-PgSQL is disabled.)


2-3. privilege of the client
----------------------------

SELinux also provides an interesting API: getpeercon(3). It enables to obtain
the security context of the peer process for the given file-descriptor of the
network socket.

If the given connection is unix domain socket, we don't need any special
configurations. If remote connection, it is necessary to set up labeled ipsec
connection between server and clients to deliver the security context of the
peer process when key exchange negotiations.
(we can set up static-fallback'ed security context based on the ip address of
clients for a case when SELinux is not unavailable on the client side.)

This example shows a case when we obtain a security context of the peer.

  Example)

    char   *scontext;
              :
    if (getpeercon(MyProcPort->sock, &scontext) < 0)
        elog(ERROR, "SELinux internal error");
              :
    elog(NOTICE, "security context of the client: %s", scontext);
              :
    freecon(scontext);


2-4. security hooks
-------------------

SE-PgSQL needs to deploy its security hooks on the strategic points.
These hooks are designed not to affect anything for code paths, if SE-PgSQL
is disabled on either compile-time or run-time.

Its specifications and purposes are described as source code comments, so we
can find detailed information at src/backend/security/sepgsql/*.c files.
The caller has to provide needed information for the hooks.

For example, sepgsql_check_rte_perms() which checks access permissions for
the given RangeTblEntry (which contains OID of the target relation and
Bitmapset of selected/modified columns). The caller has to give enough
information SE-PgSQL to make its access control decision correctly.

The sepgsql_check_rte_perms() makes its access control decision based on
the given information (RangeTblEntry object to be checked) and MAC policy
in the kernel. If allowed, it simply returns to the called. Otherwise, it
raises an error to abort current transaction.
The specification and behavior of individual security hooks are described
in the source code comments.


2-5. Initialization
-------------------

The initdb command set up a initial database on an empty directory.
At first, it launches PgSQL in bootstraping mode (--boot) to insert initial
contents of system catalogs from the postgres.bki, then it launches PgSQL in
single-user mode (--single) to apply rest of initialization.

In the bootstraping mode, SE-PgSQL is automatically disabled, because it does
not have enough data integrity to apply its security policy correctly.
For example, it computes a default security context of the table based on the
pair of client and schema which owns the new table, but pg_namespace catalog
is declared after the pg_catalog catalog.

So, SE-PgSQL initializes security contexts of the managed database objects
in the "template1" database on the second phase in initdb.
If initdb is launched with "--enable-selinux" option, it invokes a special
purpose function to assign initial security contexts on them. This function 
is available only when single-user mode for the security reason.


3. Object classes and permissions
============================================================

Object class is a terminology that means a certain type of object, such as
files, processes, tables in database and so on. Every object classes have
its own set of permissions which reflect characteristics of the object class,
but some of permissions are commonly defined for various kind of database
object classes to handle common object behavior; creation, deletion, setting
and getting its attributes, and relabeling its own security context.

Unless an explicit explanation, these permission is checked on a pair of the
client and the object to be accessed. In other word, security_compute_av()
will take the following arguments:

 subject context = security context of the client
 target context  = security context of the object to be accessed

For example, when a client with "user_u:user_r:user_t:s0" tries to drop
a table with "system_u:object_r:sepgsql_ro_table_t:s0", SE-PgSQL calls
security_compute_av() with both of security context and the code for
db_table object class. Then, it checks whether the allowed set of permissions
contains a bit for db_table:{drop} permission, or not.


3-1. common permissions of database object
------------------------------------------

The following six permissions are commonly defined for database object classes.

o create

It is checked when a client creates a new database object on the new object
labeled with a default or an explicit security context.

Prior to access control decision, a new object has to be labeled correctly.
There are two ways to label the new object. If user gives an explicit security
context on its creation, it shall be assigned with validation checks.
Othrwise, SE-PgSQL compute a default security context and it shall be assigned.
In either cases, a security context shall be assigned on the new object, then
SE-PgSQL checks db_xxx:{create} permission on the new object with the security
context.

For example, when a client labeled as "staff_u:staff_r:staff_t:s0" create a new
table, SE-PgSQL computes its default security context with communication to
SELinux. If "staff_u:object_r:sepgsql_table_t:s0" is returned, SE-PgSQL assigns
it on the new table, then checks db_table:{create} permission on a pair of
security contexts.

Some statements have OR REPLACE option. In the case when a client replaces
an existing database object, "setattr" should be applied instead of "create",
even if CREATE statement is used, because it can be considered as modification
of the object's properties, not creation.


o drop

It is checked when a client drop an existing database object.
This check is also applied on cascaded deletions, not only original one,
triggered by user's operation.

Note that "drop" always doesn't mean deletion from system catalog.
For example, ALTER TABLE ... DROP COLUMN just marks an pg_attribute entry as
already dropped, using simple_heap_update(). In fact, it is modification of
property of the column, but we consider it as a deletion.

Note that no needs to check for objects deletion by system internal
stuff, such as cleanups of temporary objects.


o getattr (not implemented yet)

It is checked when a client read properties of database object.

Typically, it is required on scanning database objects within system catalogs,
such as "SELECT * FROM pg_class". Because this check requires row-level access
control facilities, it is not implemented yet in this version.

Note that no need to check this permission, unless fetched properties are
consumed internally without returning to clients. For example, catcache stuff
provides system internal stuff an easy way to refer system catalog. It is used
to implement backend routines, and fetched properties are not returned to the
client in normal way, so we don't check this permission here.


o setattr

It is checked when a client modifies properties of database object.

Typically, ALTER statement is used to modify properties of database object.

Note that an entry of a certain system catalog is all the properties of the
database objects. For example, an entry of pg_class indeed represents the
properties of a certain relation. But it is not all. An entry corresponding
to a certain relation in pg_description catalog is also a property of the
table, so we also need to check db_table:{setattr} permission to create,
replace or remove the comment.
It depends on characteristics of individual database objects. In basically,
SE-PgSQL follows the way to handle this in the default PG model.


o relabelfrom

It is checked when a client relabel security context of a certain database
object on the older security context, in addition to {setattr} permission.
Security context is a part of the properties, so we need to check {setattr}
here. 


o relabelto

It is checked when a client relabel security context of a certain database
object on the newer security context.
Briefly, SE-PgSQL requires three permissions (setattr, relabelfrom and
relabelto) to relabel security context of a certain database object.


3-2. db_database object class
-----------------------------

The db_database class represents the database itself. An individual tuple
in the pg_database system catalog corresponds them.
It has three its own permissions and inherits the common sixes.

o default security context

The default security context for db_database class shall be computed based on
a pair of the client and its template database.

For example, when a client ("staff_u:staff_r:staff_t:s0") creates a new
database with "template0" labeled as "system_u:object_r:sepgsql_db_t:s0",
SE-PgSQL gives the two contexts for security_compute_create(3) which
returns a default security context from SELinux in the kernel.

Note that we label the first database ("template1") with an explicit
security context, not a default security context. SE-PgSQL is disabled
in the bootstraping mode, so all the database objects are created without
any security context. Then, initdb kicks queries to assign initial security
context on all the managed database objects, if --enable-selinux is given.
In this time, we gives an explicit security context provided by configuration
of SELinux.


o access

It is checked when the client open a connection to the database.
If violated, the connection shall be closed soon. So, all the clients must
be allowed to access any database objects owned by the database at least.


o load_module (not implemented yet)

It is checked when a dynamic link library is loaded to the server process
due to client's requests.

Note this permission shall be checked on a pair of the current database and
the dynamic link library file. In other word, it checks capability of database
to load a certain shared library.

The security_compute_av() takes security context of the current database
as subject and the dynamic link library file as object in the arguments,
then it returns access control decision.

Also note that we don't check anything on libraries listed on the
"shared_preload_libraries" option, because it is not a request from client.


o superuser

It is checked when the client tries to perform as a superuser on the current
database. If violated, client performs as a non-privileged database user,
even if the default PG model allows them to perform as a database superuser.

Note that this permission only controls whether the client can performs as
a database superuser in the default PG access control, or not. It does not
mean any 'super privileges' in SELinux model.


3-2. db_schema object class
---------------------------

The db_schema class represents the schema object. An individual tuple in
the pg_namespace system catalog corresponds them.
It has three its own permissions and inherits the common sixes.

o default security context

The default security context for db_schema class shall be computed based on
a pair of the client and database owning the new schema in creation.

o search

It is checked when the client resolves name of the database objects owned by
a certain schema object.
The client cannot resolve any named database objects anyway, unless this
permission is allowed. Its behavior is similar to ACL_USAGE permission on
the namespace objects in the default PG model. If it is checked on
constructing the schema search path and violated, the unallowed schema shall
be dropped from the path. Otherwise, it raises an error.

o add_name

It is checked when the client adds a new name into a certain schema.

Typically, it is checked on creation of a new object, renaming an object and
moving an object to other schema.

o remove_name

It is checked when the client removes an existing name from a certain schema.

Typically, it is checked on deletion of a new object, renaming an object and
moving an object to other schema.

Note that "ALTER xxx RENAME TO" is considered as a pair of operations.
So, it requires add_name and remove_name permissions on the same schame.
Needless to say, it is an atomic operation, so both of permissions must
be allowed on the pair of client and schema.


3-3. db_table object class
--------------------------

The db_table class represents the table object. An individual tuple in the
pg_class system catalog with relkind = RELKIND_RELATION corresponds them.
It has five its own permissions and inherits the common sixes.

o default security context

The default security context for db_table class shall be computed based on
a pair of the client and database owning the new schema in creation.

o select

It is checked when the client refers tuples in the table contents.

o insert

It is checked when the client add tuples into the table contents.

o update

It is checked when the client modify tuples in the table contents.

o delete

It is checked when the client remove tuples from the table contens.

These four permissions are a key to control data-flows between clients and
table contents. Note that it is one of the most significant feature in MAC
system.
The db_table:{select} permission controls data-flows from the table contents
to the client. Rest of the three permissions also control data-flows from the
client to the table contents.

For example, if a client X can write data to the table T, and a client Y can
read data from the table T, we can observe an communication channel between X
and Y via T.


o lock

It is checked when the client acquires explicit table locks.
Note that it shall be applied on only explicit locks, not implicit one.


o inherit (not implemented yet)

It is checked when we set up an inheritance relationship between two tables
on a pair of the tables.

Note this permission shall be checked on a pair of the parent table and the
child table. In other word, it checks capability of two tables to set up an
inheritance relationship.

Also note that this permission shall be checked when relabeling the tables,
not only CREATE or ALTER TABLE with INHERIT option.


3-4. db_column object class
---------------------------

The db_column class represents the column object. An individual tuple in
the pg_attribute system catalog owned by regular tables (its relkind is
RELKIND_RELATION) corresponds them.
It has three its own permissions and inherits the common sixes.

Here is a hardwired constraint that columns inherited from the parent tables
must have identical security context with its source. When we create a table
inherited from others, the table inherits column's definition including its
security context. In this case, the client must have permission to create
a new column with inherited security context.

o default security context

The default security context for db_column class shall be computed based on
a pair of the client and the table owning the new columns in creation.

o select

It is checked when the client refers a value via the column.
It also includes the case when UPDATE or DELETE statement contains WHERE
clause with references to certain columns.

o update

It is checked when the client modifies a value on the column.

o insert

It is checked when the client inserts a new value on the column.
Note that it is not checked when a value is given due to DEFAULT setting,
not provided by clients.


4. Code examples
============================================================

In this section, we introduce how SE-PgSQL works using a few examples.

4-1. Example of SE-PgSQL hooks

We pick up the sepgsql_relation_alter() hook as an example.

It is declared as follows:

  /*
   * relOid  : OID of the relation to be altered
   * newName : new name of the relation, if renamed. Otherwise, NULL.
   * newNsp  : new namespace of the relation, if schema is changed.
   *           Otherwise, InvalidOid.
   */
  extern void
  sepgsql_relation_alter(Oid relOid, const char *newName, Oid newNsp);

We deployed this hook on several strategic points to check permission to
alter a certain relation, such as ATSimplePermissions(), ExecRenameStmt()
and so on.

When user gives ALTER TABLE with RENAME TO option, the ExecRenameStmt() calls
this hook with OID of the relation to be renamed (relOid) and given new
name (newName), but InvalidOid shall be given for the 3rd argument (newNsp),
because it does not have SCHEMA TO option.

If this hook is called from ATSimplePermissions(), only first argument will
be valid, because this code path does not change both of name and schema.

The sepgsql_relation_alter() is implemented as follows:

  void
  sepgsql_relation_alter(Oid relOid, const char *newName, Oid newNsp)
  {
      /* (1) SE-PgSQL is enabled? */
      if (!sepgsql_is_enabled())
          return;

      /* (2) Permission check on the relation */
      sepgsql_relation_common(relOid, SEPG_DB_TABLE__SETATTR, true);

      /* (3) Permission check on the schema, if RENAME TO */
      if (newName)
          sepgsql_schema_common(get_rel_namespace(relOid),
                                SEPG_DB_SCHEMA__ADD_NAME |
                                SEPG_DB_SCHEMA__REMOVE_NAME, true);

      /* (4) Permission check on the schema, if SCHEMA TO */
      if (OidIsValid(newNsp))
      {
          sepgsql_schema_common(get_rel_namespace(relOid),
                                SEPG_DB_SCHEMA__REMOVE_NAME, true);
          sepgsql_schema_common(newNsp, SEPG_DB_SCHEMA__ADD_NAME, true);
      }
  }

On the (1), it checks whether SE-PgSQL is enabled, or not. Even if we build
the binary with SE-PgSQL, it can be turned of by the 'sepostgresql' GUC
option or system state. If SE-PgSQL is disabled, it returns soon without any
side-effect.

On the (2), it checks permission to execute ALTER TABLE statement. It modifies
properties of the table, so we needs to check db_table:{setattr} permission on
the pair of client and table.
We introduce details of sepgsql_relation_common() later.

On the (3) and (4), it checks permission to add/remove an entry to/from
a certain schema, if the ALTER TABLE has options to act a certain schema.
The newName is a valid pointer, if RENAME TO. The newNsp is also a valid
OID, if SCHEMA TO. In these cases, we checks db_schema:{add_name} and
db_schema:{remove_name} permission on appropriate schemas.


Next, we introduce the details of sepgsql_relation_common().

  /*
   * relOid   : OID of the relation to be checked
   * required : Bitmask of SEPG_DB_TABLE__*; all the required permissions
   * abort    : True, if caller want to raise an error on violatation.
   *            Otherwise, it returns false on access violation.
   */
  bool
  sepgsql_relation_common(Oid relOid, uint32 required, bool abort)
  {
      HeapTuple   tuple;
      Datum       datum;
      bool        rc, isnull;
      char        relkind;
      char       *audit_name;
      char       *context = NULL;

      /* (1) Fetch HeapTuple for the OID of relation */  
      tuple = SearchSysCache(RELOID,
                             ObjectIdGetDatum(relOid),
                             0, 0, 0);
      if (!HeapTupleIsValid(tuple))
          elog(ERROR, "cache lookup failed for relation %u", relOid);

      relkind = ((Form_pg_class) GETSTRUCT(tuple))->relkind;

      /* (2) No need to check anything except for regular tables */
      if (relkind != RELKIND_RELATION)
      {
          ReleaseSysCache(tuple);
          return true;
      }

      /* (3) fetch security context of the table */
      datum = SysCacheGetAttr(RELOID, tuple,
                              Anum_pg_class_relsecon, &isnull);
      if (!isnull)
          context = TextDatumGetCString(datum);

      /* (4) validation check for the security context */
      if (!context || security_check_context_raw(context) < 0)
          context = sepgsql_get_unlabeled_context();

      /* (5) call the decision making routine  */
      audit_name = NameStr(((Form_pg_class) GETSTRUCT(tuple))->relname);
      rc = sepgsql_compute_perms(sepgsql_get_client_context(),
                                 context,
                                 SEPG_CLASS_DB_TABLE,
                                 required,
                                 audit_name, abort);
      ReleaseSysCache(tuple);
  
      return rc;
  }

On the (1) and (2), it fetches an entry for the OID of relation, and returns
without any checks if the relation is not a regular table such as a view.
Note that we don't support checks on the database objects except for
databases, schemas, tables and columns in this version.

On the (3), it fetches security context of the relation from pg_class.relsecon
field. It stores the security context in text form.

On the (4), it applies validation checks on the fetched context.
If it is NULL (unlabeled) or labeled with invalid security context, SE-PgSQL
assumes it has an "unlabeled" security context instead of actual one.
The "unlabeled" security context is provided by the operating system.
The sepgsql_get_unlabeled_context() obtains it using libselinux API, and
returns it as a palloc()'ed cstring.

The (5) is core of the decision making in SE-PgSQL.

The sepgsql_compute_perms() asks SELinux whether the required permissions
should be allowed, or not, on a pair of security contexts of the client and
the table to be accessed.

The sepgsql_get_client_context() returns a security context of the client.
The sepgsql_compute_perms() takes two security contexts as identifiers of
the client and table. Note that it does not look at any other properties
such as database role or ownership of resource.

Its 3rd/4th arguments are object class and permissions. These are defined
in the security/sepgsql.h.

If we gives db_table:{ select update }, these constants are used.
            ^^^^|^^^   ^^^^^^|^^^^^^
                |            +------------> ( SEPG_DB_TABLE__SELECT
                |                             | SEPG_DB_TABLE__UPDATE )
                +---->  SEPG_CLASS_DB_TABLE

The 5th argument is used as a name of the database object to record audit
logs on access violation. In this example, it passes the table's name.
An the 6th argument is a flag to control the behavior on violations.

Back to the section 2-1. The sepgsql_compute_perms() translate the internal
representation of object class (SEPG_CLASS_*) and permissions (SEPG_*__*) 
into external representation to communicate SELinux in the kernel.
Then, it calls security_compute_av() API which returns a set of allowed
permissions on a pair of the security contexts.
If all the required permissions are contained within the allowed set,
it shall be allowed. Otherwise, it is access violation.

If violated, it records an audit log record (according to the security
policy setting), and raises an error or returns false depending on the
last argument (abort).

It is a typical flow when SE-PgSQL checks its permissions.


4-2. Example of SE-PgSQL hooks with returning a security context

It is another variation of security hook. It also checks permissions and
returns a security context to the caller.
The CreateSchemaCommand() is a caller of the hook. It stores the returned
security context to the pg_namespace.nspsecon field in the creation.
(Note that it may be NULL, if SE-PgSQL is disabled.)

  /*
   * nspName  : Name of the new schema
   * isTemp   : True, if temporary schema (not in used now)
   * nspLabel : An explicit security context to be assigned, or NULL
   *            if user didn't use SECURITY_CONTEXT option.
   */
  Value *
  sepgsql_schema_create(const char *nspName, bool isTemp, Node *nspLabel)
  {
      char   *context;

      if (!sepgsql_is_enabled())
          return NULL;
  
      if (!nspLabel)
          context = sepgsql_default_schema_context(MyDatabaseId);
      else
      {
          Assert(IsA(nspLabel, String));

          context = sepgsql_mcstrans_in(strVal(nspLabel));
          if (security_check_context_raw(context) < 0)
              ereport(ERROR,
                      (errcode(ERRCODE_INVALID_SECURITY_CONTEXT),
                       errmsg("invalid security context \"%s\"", context)));
      }
  
      sepgsql_compute_perms(sepgsql_get_client_context(),
                            context,
                            SEPG_CLASS_DB_SCHEMA,
                            SEPG_DB_SCHEMA__CREATE,
                            nspName, true);
  
      return makeString(context);
  }





  Oid
  NamespaceCreate(const char *nspName, Oid ownerId, Value *nspsecon)
  {
          :
      if (!nspsecon)
          nulls[Anum_pg_namespace_nspsecon - 1] = true;
      else
          values[Anum_pg_namespace_nspsecon - 1]
              = CStringGetTextDatum(strVal(nspsecon));
          :
      nspoid = simple_heap_insert(nspdesc, tup);
          :
  }

4-3. Example of third party module




