<chapter id="enhanced-security-and-sepostgresql">
  <title>Enhanced Security and SE-PostgreSQL</title>
  <para>
    This chapter introduces enhanced security features which enable
    <productname>PostgreSQL</productname> to provide mandatory
    access controls, fine-grained access controls, and integration
    of security policy between the operating system and
    <productname>PostgreSQL</productname>.
  </para>

  <para>
    The current version of <productname>PostgreSQL</productname>
    has an enhanced security facility named as SE-PostgreSQL
    (Security Enhanced PostgreSQL).

    SE-PostgreSQL provides additional fine-grained mandatory access
    controls on accesses to database objects via SQL. It makes a
    decision whether a given client-request should be allowed, or not,
    with communicating with in-kernel SELinux.

    SELinux holds its security policy which is a set of white listed
    rules, and provides its access control decisions to the kernel
    and userspace object manager.

    The key concept of SE-PostgreSQL is integration of access controls
    between operating system and database management systems.
    It makes and applies its access control decision based on a single
    unified security policy of operating system. It applies the security
    context of peer process as privileges of client, independent from
    database authentication.

    The access controls implemented by SE-PostgrSQL may not be bypassed even
    by privileged database users, making it an implementation of
    MAC (Mandatory Access Control).  This enables it to prevent information
    leaks and manipulation from a hypothetical malicious insider and reduced
    the risks invoked by SQL injection or other application-level bugs.
  </para>

  <para>
    To enable SE-PostgreSQL, specify <option>--enable-selinux</option> option
    at <command>configure</command> time,
    and use the <option>--enable-selinux</option> option to
    <command>initdb</command>.
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make install</userinput>
<prompt>$ </prompt><userinput>initdb --enable-selinux</userinput>
</screen>
  </para>

  <sect1 id="sepostgresql-features">
    <title>SE-PostgreSQL Features</title>

    <sect2 id="sepostgresql-single-unified-security-policy">
      <title>Single unified security policy</title>

      <para>
	Because files and databases have similar capabilities to store
	information assets, similar access controls are needed to maintain
	confidentiality and data integrity.  Information stored in the
	filesystem is accessed through system calls, such as
	<command>write(2)</command>, while database objects are accessed
	via SQL queries.
      </para>
      <para>
	Without specific support from the database, there is no way for a
	system-level mandatory access control policy to also apply to database
	objects.  While access to the database files themselves could be
	controlled, selective access to the contents of the database would
	be forced to rely on whatever set of discretionary access controls
	the database system provided.
      </para>
      <para>
	SE-PostgreSQL overcomes this problem by making its access control
	decision based on the security policy of SELinux.  This means that
	the same security contexts and policies which are applied to filesystem
	objects can also be applied to database objects, providing a 
	reliable foundation for comprehensive and integrated
	security.
      </para>
      <para>
	For example, when we store information labeled as
	<literal>Classified</literal>, it cannot be accesed by users without
	proper privileges regardless of whether it is stored in the filesystem
	or within the database.  Because the decision to allow or deny access
	is based only on the kernel's mandatory access control policy, and
	not on PostgreSQL's existing Discretionary Access Control (DAC)
	mechanisms, it cannot be subverted even by a database superuser.
	(Similarly, SELinux in general can restrict privileges of any system
	user, including <literal>root</literal>.)
      </para>

      <sect3 id="sepostgresql-security-context">
	<title>Security Context</title>
	<para>
	  The SELinux security policy is a set of access controls
	  rules which define who is allowed to perform which operations
	  on which objects.

	  These rules are described as a relationship of two entities
	  identified by common format called a security context.
	</para>
	<para>
	  The security context is a formatted string independent of 
	  the kind of object being labeled, such as:
	  <synopsis>system_u:object_r:postgresql_db_t:SystemHigh</synopsis>.

	  Security contexts are used to label files, sockets, and other
	  resources, and access decisions are made by testing whether
	  a particular relationship between two labels is permitted by
	  the access control rules.
	</para>
	<para>
	  For example, when a process labeled as
	  <literal>system_u:system_r:postgresql_t:s0</literal> tries to
	  write a log message to <filename>/var/log/postgresql.log</filename>
	  labeled as <literal>system_u:object_r:postgresql_log_t:s0</literal>,
	  it issues a <literal>write(2)</literal> system call; SELinux searches
	  its security policy database to determine the relationship between
	  the two security contexts.

	  If the entry found entry allows the operation, SELinux takes no
	  action;
	  otherwise, SELinux blocks the write.
	</para>
	<para>
	  Any object managers which want a decision come from SELinux
	  (including kernel) should have the capability to manage the security
	  contexts of their objects.

	  For example, most of major filesystems support xattr (Extended
	  Attributes) facilities which allows to store individual security
	  context of files.

	  SE-PostgreSQL also provides a facility to manage security context
	  of a few kind of database objects (databases, tables, columns and
	  procedures). We can set up them via enhanced DDL statement.
	</para>
      </sect3>

      <sect3 id="sepostgresql-client-privileges">
	<title>Client Privileges</title>
	<para>
	  In order to properly apply SELinux access controls, SE-PostgreSQL
	  needs to know the security context of each connected client.
	  It does this using the SELinux-supplied
	  <literal>getpeercon(3)</literal>, which provides the security
	  context of the process connected to the remote end of a particular
	  socket.

	  Note that the peer's security context is unrelated to the database
	  role used to authenticate, although the role-based permissions are
	  still applied and can deny access to database objects independently
	  of SE-PostgreSQL.
	</para>

	<para>
	  The security context of the connected client can be fetched using
	  the <literal>sepgsql_getcon()</literal> function, like this:
<screen>
<prompt>$ </prompt><userinput>id -Z</userinput>
unconfined_u:unconfined_r:unconfined_t:Classified
<prompt>$ </prompt><userinput>psql -q</userinput>
<prompt>postgres=# </prompt><userinput>SELECT sepgsql_getcon();</userinput>
                  sepgsql_getcon
---------------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:Classified
(1 row)
</screen>
	</para>

	<para>
	  When connecting to SE-PostgreSQL via a TCP/IP socket, labeled
	  networking must be set up to ensure that
	  <literal>getpeercon(3)</literal> returns the correct security
	  context.
	  See <xref linkend="sepostgresql-labeled-networks"> for more
	  defails.
	</para>
      </sect3>

      <sect3 id="sepostgresql-mac">
       <title>Mandatory Access Controls</title>
       <para>
	 MAC (Mandatory Access Controls) a system of security controls that
	 is significantly different from DAC (Discretionary Access Controls)
	 such as filesystem permissions and database ACLs.

	 The major difference is that MAC requires that access controls be
	 applied to all managed objects without exception, including,
	 for example, the <literal>root</literal> user.

	 Every subject and object must be identified by security
	 labels, and MAC policy is described as a set of relationships
	 between pairs of labels. The security context of SELinux is a
	 sort of label, but includes more identifiers than
	 traditional trusted-operating system.

	 Finally, MAC should not allow resource owners to change its
	 access control rights arbitrarily. DAC design allows us
	 to change them using <command>chmod</command> or
	 <command>GRANT</command>. But in a MAC design, security policy
	 restricts these types of changes.
       </para>
       <para>
	 SELinux is a MAC feature in operating system, so it applies
	 MAC policy for accesses to resources managed by operating
	 system like files, sockets and so on.
       </para>
       <para>
	 SE-PostgreSQL is a symmetric feature in database management
	 system. It also applies MAC policy for accesses to any
	 database objects, managed by database management system
	 as a literal.
       </para>
      </sect3>
    </sect2>

    <sect2 id="sepostgresql-functionality">
      <title>The functionality of SE-PostgreSQL</title>

     <sect3>
       <title>Access controls on Tables and Columns</title>
       <para>
	 SE-PostgreSQL also applies access controls to
	 tables and columns, but these are handled differently than row-level
	 security.
       </para>
       <para>
	 SE-PostgreSQL walks each query and considers the security contexts
	 of all tables and columns which appeare therin.  If any of those
	 tables or columns are ones which the client is not permitted to
	 access, SE-PostgreSQL aborts query execution and returns an error
	 to the client.
       </para>
       <para>
	 The following example shows a case when we declared a
	 <literal>ccredit</literal> column to store credit card numbers
	 as a secret column, hidden from unclassified users.
       </para>
<screen>
CREATE TABLE customer (
    cid     integer primary key,
    cname   varchar(32),
    credit  varchar(32)
        SECURITY_LABEL = 'system_u:object_r:sepgsql_secret_table_t'
);
GRANT ALL ON customer TO PUBLIC;

INSERT INTO customer (cid, cname, credit)
    VALUES ( 10, 'jack', '1111-2222-3333-4444'),
           ( 13, 'adam', '5555-6666-7777-8888'),
           ( 14, 'liza', '9876-5432-1098-7654');
</screen>

<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql -q postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: denied { select } \
	scontext=staff_u:staff_r:staff_t \
	tcontext=system_u:object_r:sepgsql_secret_table_t \
	tclass=db_column name=customer.credit
postgres=# SELECT cid, cname FROM customer;
 cid | cname
-----+-------
  10 | jack
  13 | adam
  14 | liza
(3 rows)
</screen>
       <para>
	 In the first query, the user tried to refer all the columns;
	 SE-PostgreSQL prevents query execution because it contains
	 a reference to <literal>ccredit</literal> column which is
	 labeled as <literal>sepgsql_secret_table_t</literal>.

	 Then, the user tried to refer to all columns except the
	 <literal>ccredit</literal> column, so SE-PostgreSQL allowed the user
	 to execute the query, because no access control rules were violated.
       </para>
     </sect3>
     <sect3>
       <title>Access Controls on Functions</title>
       <para>
	 SE-PostgreSQL also prevents clients from invoking functions for
	 which they do not have the necessary privileges.
       </para>
       <para>
	 In the current default security policy, a function declared by
	 administrative users (like <literal>unconfined_t</literal> domain)
	 is labeled as <literal>sepgsql_proc_t</literal>. Those declared
	 by normal users (like <literal>staff_t</literal> domain) are labeled
	 as <literal>staff_sepgsql_proc_exec_t</literal> and therefore can't
	 be invoked by administrative users.

	 This system prevents administrative users from invoking malicious
	 function by mistake. They have to confirm its declaration and
	 relabel its security context to <literal>sepgsql_proc_t</literal>.
       </para>
       <para>
	 SE-PostgreSQL allows clients to change privileges during
	 execution of specific functions called as trusted procedures.
	 These are similar to security definer functions, but for security
	 contexts rather than database roles.

	 In the current default security policy, trusted procedures are
	 functions labeled as <literal>sepgsql_trusted_proc_exec_t</literal>.
	 This enables users to execute these functions with administrative
	 privileges, providing a secure method for accessing confidential
	 objects.

	 This provides a simple all or nothing policy, but more complex
	 controls are possible if you install your own security policy module.
       </para>
       <para>
	 The following example declares a trusted procedure
	 <literal>show_credit</literal> to expose some, but not all, of the
	 information stored in <literal>customer.credit</literal>.

	 Assume that a client within <literal>staff_t</literal> domain
	 cannot access the <literal>credit</literal> column.  A trusted
	 trusted procedure can provide access, because the sub-queries
	 from the procedure are handled as an administrative domain.
       </para>
<screen>
# CREATE OR REPLACE FUNCTION show_credit (integer) RETURNS text
    LANGUAGE 'sql'
    SECURITY_LABEL = 'system_u:object_r:sepgsql_trusted_proc_exec_t'
    AS 'SELECT substring(credit from ''^[0-9]+-'') || ''xxxx-xxxx-xxxx''
            FROM customer WHERE CID = $1';
CREATE FUNCTION
# \q
</screen>
<screen>
$ id -Z
staff_u:staff_r:staff_t
$ psql postgres
postgres=# SELECT * FROM customer;
ERROR:  SELinux: denied { select }      \
    scontext=staff_u:staff_r:staff_t    \
    tcontext=system_u:object_r:sepgsql_secret_table_t   \
    tclass=db_column name=customer.credit
postgres=# SELECT cid, cname, show_credit(cid) FROM customer;
 cid | cname |     show_credit
-----+-------+---------------------
  10 | jack  | 1111-xxxx-xxxx-xxxx
  13 | adam  | 5555-xxxx-xxxx-xxxx
  14 | liza  | 9876-xxxx-xxxx-xxxx
(3 rows)

postgres=#
</screen>
     </sect3>
    </sect2>

    <sect2>
      <title>Limitations</title>
      <para>
	SE-PostgreSQL does not prevent information leaks via covert channels.
	In other words, clients may be able to infer information about data
	they cannot directly access.

	If your requirements include elimination of covert channels,
	SE-PostgreSQL may not be an adequate solution.  Covert channel
	analysis was required by the upper B2 class of TCSEC and by
	ISO/IEC15408 now, also known as CC (Common Criteria).
      </para>
      <para>
	Covert channels are possible when, for example, a client attempts
	to update or delete a tuple with primary key refered by
	one or more invisible foreign keys. SE-PostgreSQL will prevent the
	action to preserve reference integrity, even though the client
	cannot see the key.

	From this, the client can infer the existence of the invisible foreign
	key, an inference to which he is not entitled.

	As a practical matter, this scenario can sometimes be avoided by using
	non-natural primary and foreign keys, such as UUIDs.  This may make it
	impossible to infer any meaningful data.
      </para>
    </sect2>
  </sect1>

  <sect1 id="sepostgresql-administration">
    <title>SE-PostgreSQL Administration</title>

    <sect2>
      <title>Build and Installation</title>
      <sect3>
	<title>Requirement</title>
	<para>
	  We need the following packages to build and install
	  SE-PostgreSQL properly. Please check it at first.
	</para>

	<variablelist>
	  <varlistentry>
	    <term><literal>Linux kernel</literal></term>
	    <listitem>
	      <para>
		Linux kernel has to support SELinux feature, at least.
		In addition, it is necessary to provide an interface to
		obtain a list of supported object classes and permissions
		via <filename>/selinux/class</filename>, which is available
		on the Linux kernel 2.6.23 or later.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>Security policy</literal></term>
	    <listitem>
	      <para>
		The security policy of SELinux is neccesary to contain access
		control rules related to database objects.
		The upstreamed security policy (<literal>20080702</literal>
		or later) already has a set of rules for SE-PostgreSQL,
		as a part of PostgreSQL policy.
	      </para>
	      <para>
		In <literal>Red Hat EL</literal> or <literal>Fedora</literal>,
		check the version number of <literal>selinux-policy</literal>
		rpm package is <literal>3.4.2</literal>, or later.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><literal>libselinux</literal></term>
	    <listitem>
	      <para>
		<literal>libselinux</literal> is a library to communicate
		between applications and in-kernel SELinux, so it provides
		us various kind of APIs and header definitions.
		It is necessary to provide header definitions of object
		classes and permissions related to database. Rest of
		requirements are already included in older version.
	      </para>
	      <para>
		In <literal>Red Hat EL</literal> or <literal>Fedora</literal>,
		check the version number of <literal>libselinux</literal>
		and <literal>libselinux-devel</literal> rpm packages are
		<literal>2.0.46</literal>, or later.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>checkmodule</command></term>
	    <listitem>
	      <para>
		The <command>checkmodule</command> is a policy compiler
		for a modular policy package, such as
		<literal>sepostgresql-devel.pp</literal> we provided.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>semodule</command></term>
	    <listitem>
	      <para>
		The <command>semodule</command> is a command to manage
		modular policy packages. It enables to link/unlink,
		upgrade or load/unload modular policy packages, such as
		<literal>sepostgresql-devel.pp</literal> we provided.
	      </para>
	    </listitem>
	  </varlistentry>

	  <varlistentry>
	    <term><command>restorecon</command></term>
	    <listitem>
	      <para>
		The <command>restorecon</command> enables to assign
		correct security context for files, directories and
		any other objects on filesystem, based on the security
		policy configuration.
		It helps to assign correct security context on
		installed files by hand.
	      </para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </sect3>

      <sect3>
	<title>Build</title>
	<para>
	  SE-PostgreSQL feature is disabled in the default build.
	  So, we have to add <option>--enable-selinux</option> option
	  to configure script. It enables to build your PostgreSQL
	  with a feature to suppor SELinux.
	</para>
<screen>
<prompt>$ </prompt><userinput>./configure --enable-selinux</userinput>
<prompt>$ </prompt><userinput>make</userinput>
<prompt>$ </prompt><userinput>make -C src/backend/security/sepgsql/policy</userinput>
</screen>
        <para>
	  Please note that the recent upstreamed security policy of SELinux
	  contains a set of rules for SE-PostgreSQL, so we are not always 
	  necessary to build security policy module.
	</para>
	<para>
	  However, SE-PostgreSQL also provides an optinal policy module
	  for development Purpose. It enables several operations like
	  regression test, toggle audit logs and so on.
	</para>
	<para>
	  It is stored in
	  <filename>src/backend/security/sepgsql/policy</filename>,
	  and can be also build and installed as a binary security policy
	  module.
	</para>
      </sect3>

      <sect3>
	<title>Installation</title>
	<para>
	  Please note that SELinux requires installed files, directories and
	  others should be labeled properly. RPM installation do it implicitly.

	  But, when you install PostgreSQL from a tarball, you should assign
	  proper security context for them. The development policy module
	  has a list that shows what security context should be assigned to
	  what files, and will help you to manage them, so we recommend to
	  install the <filename>sepostgresql-devel.pp</filename> also.
	</para>
<screen>
<prompt># </prompt><userinput>make install</userinput>
<prompt># </prompt><userinput>/usr/sbin/semodule -i src/backend/security/sepgsql/policy/sepostgresql-devel.pp</userinput>
<prompt># </prompt><userinput>/sbin/restorecon -R /usr/local/pgsql</userinput>
</screen>
        <para>
	  <command>semodule</command> is a command to install and uninstall
	  a security policy module. <command>restorecon</command> is a command
	  to assign given directories its default security context recursively.
	</para>

	<para>
	  As we note later, all the files and directories to store database
	  cluster should be labeled as <literal>postgresql_db_t</literal>.
	  The default security policy assumes it is constructed at
	  <filename>/var/lib/pgsql/data</filename> as RPM doing.

	  If you want to set up it on another directory, you need to label
	  it by hand.
	</para>
<screen>
<prompt># </prompt><userinput>mkdir -p $PGDATA</userinput>
<prompt># </prompt><userinput>chcon -t postgresql_db_t -R $PGDATA</userinput>
</screen>
        <para>
	  Then, we need to run <command>initdb</command> to initialize
	  the database cluster. It is necessary to specify an option of
	  <option>--pgace-feature=selinux</option> which enables to initialize
	  database cluster with proper security context.

	  Without this option, no enhanced security feature will be activated
	  for the database cluster.
	</para>
<screen>
<prompt>$ </prompt><userinput>initdb --pgace-feature=selinux</userinput>
<prompt>$ </prompt><userinput>pg_ctl start</userinput>
</screen>
      </sect3>
    </sect2>

    <sect2>
      <title>Backup and Restore</title>
      <para>
	When we restore a database from backups, we have to restore
	its security context correctly as GRANT statement doing on
	the restored table.
      </para>

      <para>
	The <command>pg_dump</command> and <command>pg_dumpall</command>
	have <option>--security-label</option> option to dump databases
	with its security context.

	The dumped image can be restored with proper security context.
      </para>

      <para>
	Needless to say, a process which invokes <command>pg_dump</command>
	must be allowed to refer whole of the database,
	because SE-PostgreSQL filters all inaccessible tuples from the result
	set, or aborts query execution if it references inaccessible
	columns, tables, or functions.

	These requirements are same when we restore the image.
	A process which invokes <command>pg_restore</command> has to have
	enough permission to create/insert these objects with the specified
	security context.
      </para>
<screen>
<prompt>$ </prompt><userinput>pg_dump --security-label postgres</userinput>
	:
      (snip)
	:
--
-- Name: drink; Type: TABLE; Schema: public; Owner: kaigai; Tablespace:
--

CREATE TABLE drink (
    id integer NOT NULL,
    name character varying(48),
    price integer
) SECURITY_LABEL = 'system_u:object_r:sepgsql_table_t';
	:
</screen>
      <para>
	This example shows a backup image with explicitly specified security
	context on tables and tuples.

	If a column has different security context from that of the table, it
	must be specified explicitly in the <command>CREATE TABLE</command>
	statement.
      </para>
    </sect2>

    <sect2 id="sepostgresql-labeled-networks">
      <title>Labeled Networks</title>
      <para>
	Labeled Networks is a technology which makes it possible to
	obtain the security context of peer process communicating
	via a TCP/IP connection.
      </para>

      <para>
	This technology contains two facilities.
	One is <literal>Labeled IPsec</literal>,
	and the other is <literal>Static Fallback Context</literal>.

	This section shows the way to set up both labeled networks
	technology.
      </para>

      <sect3>
	<title>Labeled IPsec</title>
	<para>
	  When communicating using an encrypted channel
	  with IPsec, the key-exchange daemon <command>racoon</command>
	  on each machine exchanges encryption keys with its peer.

	  In addition, the security context of the connecting process is
	  delivered to the peer.

	  The delivered security context is cached on the kernel, and
	  it is exported into applications via the
	  <command>getpeercon(3)</command>.
	</para>

	<para>
	  This section introduces the steps to set up labeled ipsec,
	  but it is necessity minimum configuration, so we recommend
	  you to refer external technical documents related to ipsec
	  for more details.
	</para>

	<sect4>
	  <title>Example Environment</title>
	  <para>
	    In this introduction, we assume the server host where SE-PostgreSQL
	    works has an IP address of <literal>192.168.1.10</literal> and
	    the client host has IP address of <literal>192.168.1.200</literal>.

	    They are wired to same network, and can communicate each other
	    directly, without any router.
	  </para>

	  <para>
	    The purpose of the following configuration is to obtain
	    the security context of the process working on the client host
	    (<literal>192.168.1.200</literal>) from SE-PostgreSQL daemon
	    working on the server host (<literal>192.168.1.10</literal>), 
	    when a connection is established.
	  </para>
	</sect4>

	<sect4>
	  <title>Adding a SPD entry</title>
	  <para>
	    It is needed to add an SPD (Security Policy Database) entry
	    to indicate applying IPsec on channels between two host.

	    Note that SPD is not a term of SELinux, it is a configuration
	    parameter of IPsec, although it's a bit confusable.
	  </para>

	  <para>
	    This example shows esp/transport mode should be applied on
	    outbounding packets from <literal>192.168.1.10</literal>
	    to <literal>192.168.1.200</literal>, and inbounding packets
	    from <literal>192.168.1.200</literal> to
	    <literal>192.168.1.10</literal>.
<programlisting>
spdadd 192.168.1.10 192.168.1.200 any
-ctx 1 1 "system_u:object_r:ipsec_spd_t:s0"
-P out ipsec
esp/transport//require;

spdadd 192.168.1.200 192.168.1.10 any
-ctx 1 1 "system_u:object_r:ipsec_spd_t:s0"
-P in ipsec
esp/transport//require;
</programlisting>
            In addition, the second line of each entries enables to
            turn on security context delivery during key exchanging.
	  </para>
	  <para>
	    You can load the above configuration using
	    <command>setkey</command> command.

	    Save your configuration into a temporary file,
	    and invoke <command>setkey</command> with the file
	    as an argument.
<screen>
<prompt># </prompt><userinput>/sbin/setkey -f &lt;your configuration file&gt;</userinput>
</screen>
	  </para>
	  <para>
	    It is necessary to do this on both server side and client side.

	    Note that you have to switch the IP addreses on the client side.
	  </para>
	</sect4>

	<sect4>
	  <title>Racoon configuration</title>
	  <para>
	    In the next, we have to edit a configuration file of
	    <command>racoon</command> to specify encryption algorithm,
	    authentication method and so on.

	    This example uses pre shared key to authenticate the peer
	    host (<literal>192.168.1.200</literal>) for simplification.

	    Note that you have to switch the IP addresses on the client side.
	  </para>

	  <para>
	    An additional entry to
	    <filename>/etc/racoon/racoon.conf</filename>.
<programlisting>
remote 192.168.1.200
{
	exchange_mode aggressive, main;
	my_identifier address;
	proposal {
		encryption_algorithm 3des;
		hash_algorithm sha1;
		authentication_method pre_shared_key;
		dh_group 2 ;
	}
}
</programlisting>
	  </para>
	  <para>
	    We have to put a set of key string and IP address of destination
	    in <filename>/etc/racoon/psk.txt</filename>.

	    The key string has also to be same in the client side.
<programlisting>
# file for pre-shared keys used for IKE authentication
# format is: 'identifier' 'key'
# For example:
#
# 10.1.1.1 flibbertigibbet
# www.example.com 12345
# foo@www.example.com micropachycephalosaurus
192.168.1.200	somethingsecrettext
</programlisting>
          </para>
	</sect4>

	<sect4>
	  <title>Restart Racoon</title>
	  <para>
	    Restart racoon daemon in both peers.
	  </para>
<screen>
<prompt># </prompt><userinput>service racoon restart</userinput>
</screen>
	</sect4>
      </sect3>

      <sect3>
	<title>Static Fallback Context</title>
	<para>
	  We cannot apply labeled IPsec for any situation.

	  It requires both server and cliets being SElinux'ed and IPsec is
	  available on their communication channel.
	</para>
	<para>
	  SELinux provides an alternative method to identify a security
	  context of peer process inside the <literal>getpeercon(3)</literal>,
	  when a connection come from unlabeled networks.

	  This facility is called as static fallback context.
	  It enables to return a security context associated with IP address
	  or network interfaces, as if a new connection come from labeled
	  networks.
	</para>
	<para>
	  <command>netlabelctl</command> within
	  <literal>netlabel_tools</literal>
	  package can be used to set up static fallback context.
	</para>
	<para>
	  The following example shows a case when we associate a security
	  context with connections come from <literal>192.168.1.0/24</literal>
	  via all network interfaces.
<screen>
<prompt># </prompt><userinput>/sbin/netlabelctl unlbl add default address:192.168.1.0/24 label:user_u:user_r:user_t:s0</userinput>
</screen>
          The following example shows a case when we associate a security
          context with connections come from <literal>192.168.2.0/24</literal>
          via <literal>eth0</literal>.
<screen>
<prompt># </prompt><userinput>/sbin/netlabelctl unlbl add dev:eth0 address:192.168.2.0/24 label:staff_u:staff_r:staff_t:s0:c0</userinput>
</screen>
	</para>
      </sect3>
    </sect2>
  </sect1>

  <sect1 id="sepostgresql-policy">
    <title>Making a Security Policy Module</title>
    <para>
      This section introduces the way to make your own security policy
      modules, and steps to install them, using a simple example.
    </para>
    <para>
      At first, check whether the toolchain for SELinux security policy.
      We need <command>checkmodule</command> and <command>semodule</command>
      command installed correctly, and pre-defined policy templates which
      is installed at <filename>/usr/share/selinux/devel</filename> in
      generally.

      In Fedora/RedHat, these are provided by
      <literal>policycoreutils</literal>, <literal>checkpolicy</literal>
      and <literal>selinux-policy</literal> package.
    </para>
    <para>
      Then, we begin to write a security policy.
      The source file of security policy is named as
      <filename>(policy module name).te</filename> conventionally.
      Here we defines two types of tables and functions for administrative
      domain's private use. See the following example:
<programlisting>
policy_module(testpolicy,1.0.1)

gen_require(`
    class db_table all_db_table_perms;
    class db_procedure all_db_procedure_perms;
    class db_column all_db_column_perms;
    class db_tuple all_db_tuple_perms;

    # externally defined administrative domain
    attribute sepgsql_unconfined_type;
')

# We defines two types for tables/functions
type admin_sepgsql_table_t;
postgresql_table_object(admin_sepgsql_table_t)

type admin_sepgsql_proc_t;
postgresql_procedure_object(admin_sepgsql_proc_t)

# It allows only administrative domains
allow sepgsql_unconfined_type admin_sepgsql_table_t : db_table *;
allow sepgsql_unconfined_type admin_sepgsql_table_t : db_column *;
allow sepgsql_unconfined_type admin_sepgsql_table_t : db_tuple *;

allow sepgsql_unconfined_type admin_sepgsql_proc_t :
   db_procedure { relabelfrom relabelto create drop getattr setattr execute };
</programlisting>      
    </para>
    <para>
      The <literal>policy_module</literal> at the head is a macro to
      declare the name of security policy module and its version.
      Its name is also used as a basename of sourcefile conventionally.
      In this case, <filename>testpolicy.te</filename> is a proper name.
    </para>
    <para>
      Then, we put <literal>gen_require</literal> block.
      It is necessary to declare all the external dependency.
      This example requires related object classes/permissions and
      externally defined administrative domain types.

      In the standard policy, the attribute of
      <literal>sepgsql_unconfined_type</literal> has same meaning with
      administrative domains on SE-PostgreSQL.
      Most distributions assigns <literal>unconfined_t</literal> domain
      for the default login shell, it is also contained as administrative
      domain.
    </para>
    <para>
      Next, we declare two types.
      The one is <literal>admin_sepgsql_table_t</literal> for administrative
      domain's private tables,
      the other is <literal>admin_sepgsql_proc_t</literal> for procedures in
      similar purpose.

      The suffix of <literal>_t</literal> is attached to identifiers of
      types/domains conventionally, but not a grammatical requirement.

      The <literal>postgresql_table_object</literal> and
      <literal>postgresql_procedure_object</literal> are pre-defined
      macros to characterize given types as tables/procedures.
    </para>
    <para>
      At the last, we allows administrative domains some of privileges.
      SELinux adopts white-list-rules, so any actions except for
      rules explicitly allowed ones.

      Please note that we allows administrative domains anything on
      newly defined types, but we don't describe rules for any others.
    </para>
    <para>
      The toolchain provides a makefile to build and pack user defined
      security policy. In generally, it is installed at
      <filename>/usr/share/selinux/devel/Makefile</filename>,
      so we can apply it as follows:
<screen>
<prompt>$ </prompt><userinput>make -f /usr/share/selinux/devel/Makefile</userinput>
Compiling targeted testpolicy module
/usr/bin/checkmodule:  loading policy configuration from tmp/testpolicy.tmp
/usr/bin/checkmodule:  policy configuration loaded
/usr/bin/checkmodule:  writing binary representation (version 8) to tmp/testpolicy.mod
Creating targeted testpolicy.pp policy package
rm tmp/testpolicy.mod.fc tmp/testpolicy.mod
<prompt>$ </prompt><userinput>ls</userinput>
testpolicy.fc  testpolicy.if  testpolicy.pp  testpolicy.te  tmp
</screen>
      Please note that we assume the policy source is named as
      <filename>testpolicy.te</filename> here.
    </para>
    <para>
      The toolchain generates a loadable policy module named as
      <filename>testpolicy.pp</filename>.
      In addition, it implicitly generates <filename>testpolicy.if</filename>
      and <filename>testpolicy.fc</filename>. But its purposes are to define
      pre-defined macros exposed to other policy modules and relationship
      between filesystem object and its default security context, so
      we don't need touch them here.
    </para>
    <para>
      Next, the <filename>testpolicy.pp</filename> should be installed to the
      kernel using <command>semodule</command>.
<screen>
<prompt>$ </prompt><userinput>su</userinput>
Password:
<prompt># </prompt><userinput>semodule -i <filename>testpolicy.pp</filename></userinput>
</screen>
    </para>
    <para>
      You can confirm the security policy module is installed correctly using
      <command>semodule -l</command>.
<screen>
<prompt># </prompt><userinput>semodule -l</userinput>
      :
telnet  1.7.0
testpolicy      1.0.1
tftp    1.9.0
      :
</screen>
    </para>
    <para>
      Then, these new policies got available. <literal>unconfined_t</literal>
      is an administrative domain pre defined, and grouped by
      <literal>sepgsql_unconfined_type</literal>.
      In the following example, <literal>t.b</literal> is labeled as
      <literal>system_u:object_r:admin_sepgsql_table_t:s0</literal> and
      <literal>f(int)</literal> is labeled as
      <literal>system_u:object_r:admin_sepgsql_proc_t</literal>.
      The installed policy module does not allow non-administrative domain's
      to access these objects.
<screen>
postgres=# SELECT sepgsql_getcon();
              sepgsql_getcon
-------------------------------------------
 unconfined_u:unconfined_r:unconfined_t:s0
(1 row)

postgres=# CREATE TABLE t (a int, b text SECURITY_LABEL = 'system_u:object_r:admin_sepgsql_table_t:s0');
CREATE TABLE
postgres=# SELECT sepgsql_column_getcon('t','b');
          sepgsql_column_getcon
-----------------------------------------
 system_u:object_r:admin_sepgsql_table_t
(1 row)

postgres=# INSERT INTO t VALUES (1, 'aaa'), (2, 'bbb');
INSERT 0 2
postgres=# CREATE FUNCTION f (int) RETURNS int LANGUAGE 'sql'
              SECURITY_LABEL = 'system_u:object_r:admin_sepgsql_proc_t'
              AS 'SELECT $1 + $1';
CREATE FUNCTION
postgres=# SELECT f(5);
 f
----
 10
(1 row)
</screen>
    </para>
    <para>
      The <literal>sepgsql_test_t</literal> is a domain for test purpose.
      It provides a same privileges compared to web servers, included in
      <literal>sepostgresql-devel.pp</literal> module.

      You can run <command>psql</command> under different domain using
      <command>runcon</command>.
<screen>
postgres=# SELECT sepgsql_getcon();
               sepgsql_getcon
---------------------------------------------
 unconfined_u:unconfined_r:sepgsql_test_t:s0
(1 row)

postgres=# SELECT * FROM t;
ERROR:  SELinux: denied { select } scontext=unconfined_u:unconfined_r:sepgsql_test_t tcontext=system_u:object_r:admin_sepgsql_table_t tclass=db_column name=t.b
postgres=# SELECT a FROM t;
 a
---
 1
 2
(2 rows)
postgres=# SELECT f(10) FROM t;
NOTICE:  SELinux: denied { execute } scontext=unconfined_u:unconfined_r:sepgsql_test_t tcontext=system_u:object_r:admin_sepgsql_proc_t tclass=db_procedure name=f
ERROR:  permission denied for function f
postgres=#
</screen>
    </para>
    <para>
      It shows non-administrative domain is not allowed to access a column
      labeled as <literal>system_u:object_r:admin_sepgsql_table_t</literal>
      and to execute a function labeled as
      <literal>system_u:object_r:admin_sepgsql_proc_t</literal>.
    </para>
    <para>
      If you cannot connect server, please check the following items:
      <itemizedlist>
	<listitem>
	  <para>
	    <literal>sepostgresql-devel.pp</literal> has to be installed.
	  </para>
	</listitem>
	<listitem>
          <para>
	    A <literal>allow_user_postgresql_connect</literal> boolean is
	    enabled.
	  </para>
	</listitem>
        <listitem>
	  <para>
	    A <literal>sepgsql_regression_test_mode</literal> boolean is
	    enabled.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    The postgresql server process works within
	    <literal>postgresql_t</literal> domain.
	    If not so, do <command>/sbin/restorecon -R</command> on
	    instllation path and restart it.
	  </para>
	</listitem>
      </itemizedlist>
    </para>
  </sect1>
</chapter>
